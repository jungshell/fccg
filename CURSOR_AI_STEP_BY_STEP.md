# 🎯 Cursor AI 단계별 실행 가이드 (복사-붙여넣기용)

> **초보자를 위한 완전 자동화 가이드**  
> 각 단계의 명령어를 그대로 복사해서 Cursor AI에 붙여넣기만 하면 됩니다.  
> 한 단계가 완료되면 다음 단계로 진행하세요.

---

## ⚠️ 중요 안내

1. **순서대로 진행**: 번호 순서대로 하나씩 진행하세요
2. **완료 확인**: 각 단계 완료 후 "완료되었나요?" 또는 "에러 있나요?" 확인
3. **에러 발생 시**: 에러 메시지를 복사해서 "이 에러를 수정해줘"라고 요청
4. **한 번에 하나씩**: 여러 단계를 동시에 요청하지 마세요

---

## 📦 1단계: 프로젝트 기본 구조 생성

### 명령어 1-1: 프로젝트 폴더 구조 생성

```
프로젝트 루트 디렉토리에 다음 폴더 구조를 만들어줘:
- backend/
- frontend/
- scripts/

각 폴더가 제대로 생성되었는지 확인해줘.
```

**완료 확인**: `ls` 명령어로 폴더가 생성되었는지 확인

---

### 명령어 1-2: Backend package.json 생성

```
backend 폴더에 package.json 파일을 만들어줘. 다음 내용을 포함해줘:

{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only --ignore-watch node_modules src/app.ts",
    "build": "tsc",
    "start": "node dist/app.js",
    "postinstall": "prisma generate"
  },
  "engines": {
    "node": "18.x"
  },
  "dependencies": {
    "@prisma/client": "^6.12.0",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node-cron": "^3.0.11",
    "axios": "^1.11.0",
    "bcrypt": "^6.0.0",
    "cloudinary": "^2.8.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.0",
    "express": "^5.1.0",
    "express-rate-limit": "^8.1.0",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.1",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.6",
    "prisma": "^6.12.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3",
    "winston": "^3.18.3"
  }
}

파일이 제대로 생성되었는지 확인해줘.
```

---

### 명령어 1-3: Frontend package.json 생성

```
frontend 폴더에 package.json 파일을 만들어줘. 다음 내용을 포함해줘:

{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .ts,.tsx",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@chakra-ui/icons": "^2.1.0",
    "@chakra-ui/react": "^2.7.2",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "axios": "^1.12.2",
    "dayjs": "^1.11.18",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.7.0",
    "react-youtube": "^10.1.0",
    "recharts": "^3.2.1",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.6.0",
    "typescript": "~5.8.3",
    "vite": "^7.0.4",
    "eslint": "^9.30.1"
  }
}

파일이 제대로 생성되었는지 확인해줘.
```

---

### 명령어 1-4: .gitignore 파일 생성

```
프로젝트 루트에 .gitignore 파일을 만들어줘. 다음 내용을 포함해줘:

# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/

# Production
dist/
build/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Database
*.db
*.db-journal
backend/dev.db
backend/prisma/dev.db

# Uploads
backend/uploads/
backend/backups/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

파일이 제대로 생성되었는지 확인해줘.
```

---

## 🗄️ 2단계: 데이터베이스 스키마 설정

### 명령어 2-1: Prisma 초기화

```
backend 폴더에서 Prisma를 초기화해줘:
1. prisma 폴더 생성
2. schema.prisma 파일 생성
3. 기본 설정 추가

PostgreSQL을 사용하도록 설정해줘.
```

---

### 명령어 2-2: Prisma Schema 작성

```
backend/prisma/schema.prisma 파일을 만들어줘. 다음 모델들을 모두 포함해줘:

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  password      String
  name          String
  phone         String?
  role          String    @default("MEMBER") // SUPER_ADMIN, ADMIN, MEMBER
  status        String    @default("ACTIVE") // ACTIVE, INACTIVE, SUSPENDED, DELETED
  avatarUrl     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  createdGames  Game[]
  votes         Vote[]
  galleryUploads Gallery[]
  galleryLikes  GalleryLike[]
  galleryComments GalleryComment[]
}

model Game {
  id            Int       @id @default(autoincrement())
  date          DateTime
  time          String?
  location      String
  eventType     String    // 매치, 자체, 회식, 기타
  gameType      String?   // 정식, 연습
  autoGenerated Boolean   @default(false)
  createdById   Int
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  createdBy     User      @relation(fields: [createdById], references: [id])
}

model VoteSession {
  id            Int       @id @default(autoincrement())
  weekStartDate DateTime
  startTime     DateTime
  endTime       DateTime
  isActive      Boolean   @default(true)
  isCompleted   Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  votes         Vote[]
}

model Vote {
  id            Int       @id @default(autoincrement())
  voteSessionId Int
  userId        Int
  selectedDays  Json      // ["월", "화"] 또는 ["불참"]
  createdAt     DateTime  @default(now())
  
  voteSession   VoteSession @relation(fields: [voteSessionId], references: [id])
  user          User      @relation(fields: [userId], references: [id])
  
  @@unique([voteSessionId, userId])
}

model Gallery {
  id            Int       @id @default(autoincrement())
  title         String
  imageUrl      String
  uploaderId    Int
  eventDate     DateTime?
  eventType     String    @default("기타")
  clickCount    Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  uploader      User      @relation(fields: [uploaderId], references: [id])
  likes         GalleryLike[]
  comments      GalleryComment[]
  tags          Tag[]
}

model GalleryLike {
  id        Int      @id @default(autoincrement())
  galleryId Int
  userId    Int
  createdAt DateTime @default(now())
  
  gallery   Gallery  @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])
  
  @@unique([galleryId, userId])
}

model GalleryComment {
  id        Int      @id @default(autoincrement())
  galleryId Int
  userId    Int
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  gallery   Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id])
}

model Tag {
  id        Int      @id @default(autoincrement())
  name      String
  galleryId Int
  
  gallery   Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
}

model VideoViewStat {
  id          Int      @id @default(autoincrement())
  videoKey    String   @unique
  viewCount   Int      @default(0)
  lastViewedAt DateTime?
}

모든 관계가 올바르게 설정되었는지 확인해줘.
```

---

### 명령어 2-3: TypeScript 설정 파일 생성

```
backend 폴더에 tsconfig.json 파일을 만들어줘. 다음 내용을 포함해줘:

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "types": ["node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

frontend 폴더에도 tsconfig.json을 만들어줘. Vite + React 프로젝트에 맞게 설정해줘.
```

---

## 🔧 3단계: Backend 기본 설정

### 명령어 3-1: Express 서버 기본 파일 생성

```
backend/src/app.ts 파일을 만들어줘. 다음을 포함해줘:

1. Express 서버 초기화
2. CORS 설정 (모든 origin 허용)
3. body-parser 미들웨어 (JSON, URL-encoded)
4. Helmet 보안 미들웨어
5. Morgan 로깅 미들웨어
6. 기본 라우트 설정 (/api/auth)
7. 에러 핸들링 미들웨어
8. 포트 4000에서 서버 시작

dotenv를 사용해서 환경변수를 로드해줘.
```

---

### 명령어 3-2: 환경 변수 예제 파일 생성

```
backend 폴더에 .env.example 파일을 만들어줘. 다음 내용을 포함해줘:

# Database
DATABASE_URL="postgresql://user:password@localhost:5432/dbname"

# JWT
JWT_SECRET="your-secret-key-change-this-in-production"

# Server
PORT=4000
NODE_ENV=development

# Kakao Map API
KAKAO_API_KEY="your-kakao-api-key"

# Cloudinary
CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"

# Gmail (선택사항)
GMAIL_USER="your-email@gmail.com"
GMAIL_PASS="your-app-password"

각 환경변수에 대한 설명 주석도 추가해줘.
```

---

### 명령어 3-3: 인증 미들웨어 생성

```
backend/src/middlewares/authMiddleware.ts 파일을 만들어줘:

1. authenticateToken 함수:
   - Authorization 헤더에서 Bearer 토큰 추출
   - JWT 토큰 검증
   - 검증 성공 시 req.user에 사용자 정보 저장
   - 토큰이 없거나 유효하지 않으면 401 에러 반환

2. optionalAuthenticate 함수:
   - 토큰이 있으면 사용자 정보 저장
   - 토큰이 없으면 req.user를 null로 설정
   - 에러 발생하지 않음

jsonwebtoken과 @prisma/client를 사용해줘.
```

---

### 명령어 3-4: 보안 미들웨어 생성

```
backend/src/middlewares/security.ts 파일을 만들어줘:

1. express-rate-limit 설정:
   - 일반 API: 300회/15분
   - 인증 API: 15회/15분

2. Helmet 설정:
   - 기본 보안 헤더 설정

3. CORS 설정:
   - 모든 origin 허용
   - credentials: true

각 미들웨어를 export해줘.
```

---

## 🔐 4단계: 인증 API 구현

### 명령어 4-1: 회원가입 API

```
backend/src/routes/auth.ts 파일을 만들어줘. 다음 엔드포인트를 포함해줘:

POST /api/auth/register
- 요청 본문: { name, email, password, phone? }
- 비밀번호를 bcrypt로 해싱 (bcrypt.hash, salt rounds: 10)
- 이메일 중복 체크 (Prisma로 User 조회)
- 중복이면 409 에러 반환
- 새 사용자 생성 (role: "MEMBER", status: "ACTIVE")
- JWT 토큰 생성 (jsonwebtoken.sign)
- 응답: { token, user: { id, email, name, role } }
- 에러 처리: 400 (입력 오류), 409 (중복 이메일), 500 (서버 오류)

에러 메시지는 한국어로 반환해줘.
```

---

### 명령어 4-2: 로그인 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

POST /api/auth/login
- 요청 본문: { email, password }
- 이메일로 사용자 조회 (Prisma)
- 사용자가 없으면 401 에러 반환
- bcrypt.compare로 비밀번호 검증
- 비밀번호가 틀리면 401 에러 반환
- JWT 토큰 생성
- 응답: { token, user: { id, email, name, role } }
- 에러 처리: 401 (인증 실패), 500 (서버 오류)

에러 메시지는 한국어로 반환해줘.
```

---

### 명령어 4-3: 프로필 조회 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

GET /api/auth/profile
- authenticateToken 미들웨어 사용 (로그인 필요)
- req.user에서 사용자 ID 가져오기
- Prisma로 사용자 정보 조회
- 응답: { user: { id, email, name, phone, role, status, ... } }
- 에러 처리: 401 (인증 필요), 404 (사용자 없음), 500 (서버 오류)
```

---

### 명령어 4-4: 라우터 등록

```
backend/src/app.ts 파일에 auth 라우터를 등록해줘:

1. auth.ts에서 라우터 import
2. app.use('/api/auth', authRouter) 추가
3. 라우터가 /api/auth 경로로 등록되었는지 확인

서버를 실행해서 라우터가 제대로 등록되었는지 확인해줘.
```

---

## 🎨 5단계: Frontend 기본 설정

### 명령어 5-1: Vite 프로젝트 초기화

```
frontend 폴더에서 Vite + React + TypeScript 프로젝트를 초기화해줘:

1. vite.config.ts 파일 생성
2. index.html 파일 생성
3. src/main.tsx 파일 생성
4. src/App.tsx 파일 생성
5. 기본 React 앱 구조 설정

Chakra UI는 나중에 추가할 예정이니 일단 기본 구조만 만들어줘.
```

---

### 명령어 5-2: Chakra UI 설정

```
frontend/src/main.tsx 파일을 수정해줘:

1. @chakra-ui/react의 ChakraProvider import
2. ChakraProvider로 App 컴포넌트 감싸기
3. 기본 테마 설정 (색상: brand blue #004ea8)

Chakra UI가 제대로 설정되었는지 확인해줘.
```

---

### 명령어 5-3: React Router 설정

```
frontend/src/App.tsx 파일을 수정해줘:

1. react-router-dom의 BrowserRouter, Routes, Route import
2. 기본 라우트 설정:
   - /: MainDashboard (나중에 만들 예정)
   - /login: LoginPage (나중에 만들 예정)
   - /signup: SignupPage (나중에 만들 예정)
3. 각 페이지 컴포넌트는 일단 "페이지 준비 중" 텍스트만 표시

라우터가 제대로 작동하는지 확인해줘.
```

---

### 명령어 5-4: API 클라이언트 설정

```
frontend/src/config/api.ts 파일을 만들어줘:

1. getApiBaseUrl 함수:
   - 로컬 개발: '/api/auth' 반환
   - 프로덕션: 환경변수 VITE_API_BASE_URL 사용
   - 없으면 '/api/auth' 기본값

2. getApiUrl 함수:
   - 엔드포인트 경로를 받아서 완전한 URL 반환
   - 예: getApiUrl('/register') → '/api/auth/register' 또는 'https://.../api/auth/register'

3. buildUrl 헬퍼 함수:
   - baseUrl과 path를 조합
   - 슬래시 중복 제거

각 함수에 타입을 명시해줘 (TypeScript).
```

---

### 명령어 5-5: API 요청 유틸리티 생성

```
frontend/src/api/auth.ts 파일을 만들어줘:

1. request 함수:
   - fetch를 래핑
   - 타임아웃 30초 설정 (AbortController 사용)
   - Authorization 헤더에 토큰 자동 추가 (localStorage에서 가져오기)
   - 에러 처리 (네트워크 오류, 타임아웃, HTTP 오류)
   - JSON 응답 파싱

2. register 함수:
   - POST /api/auth/register 호출
   - { name, email, password, phone? } 전송
   - { token, user } 반환

3. login 함수:
   - POST /api/auth/login 호출
   - { email, password } 전송
   - { token, user } 반환

4. getProfile 함수:
   - GET /api/auth/profile 호출
   - { user } 반환

각 함수에 타입을 명시해줘.
```

---

### 명령어 5-6: Zustand 상태 관리 설정

```
frontend/src/store/auth.ts 파일을 만들어줘:

1. Zustand store 생성:
   - user: User | null
   - token: string | null
   - setUser: (user: User | null) => void
   - setToken: (token: string | null) => void
   - logout: () => void

2. localStorage 연동:
   - 초기화 시 localStorage에서 user, token 복원
   - setUser, setToken 호출 시 localStorage에 저장
   - logout 시 localStorage 클리어

User 타입은 { id: number, email: string, name: string, role: string }로 정의해줘.
```

---

## 📝 6단계: 로그인/회원가입 페이지 구현

### 명령어 6-1: 회원가입 페이지 생성

```
frontend/src/pages/Signup.tsx 파일을 만들어줘:

1. Chakra UI 컴포넌트 사용:
   - Box, VStack, FormControl, FormLabel, Input, Button, useToast

2. 입력 필드:
   - 이름 (name)
   - 이메일 (email)
   - 비밀번호 (password, type="password")
   - 전화번호 (phone, 선택사항)

3. 유효성 검증:
   - 이메일 형식 검증
   - 비밀번호 최소 6자

4. 제출 처리:
   - register API 호출
   - 성공 시 토큰 저장 (setToken, setUser)
   - 로그인 페이지로 리다이렉트 (useNavigate)
   - 에러 시 토스트 메시지 표시

5. 로딩 상태 표시 (isLoading)

디자인은 깔끔하고 현대적으로 만들어줘.
```

---

### 명령어 6-2: 로그인 페이지 생성

```
frontend/src/pages/Login.tsx 파일을 만들어줘:

1. Chakra UI 컴포넌트 사용:
   - Box, VStack, FormControl, FormLabel, Input, Button, useToast

2. 입력 필드:
   - 이메일 (email)
   - 비밀번호 (password, type="password")

3. 제출 처리:
   - login API 호출
   - 성공 시 토큰 저장 (setToken, setUser)
   - 홈 페이지로 리다이렉트
   - 에러 시 토스트 메시지 표시

4. 로딩 상태 표시

5. "회원가입" 링크 추가 (회원가입 페이지로 이동)

디자인은 회원가입 페이지와 일관성 있게 만들어줘.
```

---

### 명령어 6-3: ProtectedRoute 컴포넌트 생성

```
frontend/src/components/ProtectedRoute.tsx 파일을 만들어줘:

1. useAuthStore에서 user, token 가져오기
2. user와 token이 없으면:
   - Navigate 컴포넌트로 /login으로 리다이렉트
   - state에 현재 경로 저장 (로그인 후 돌아올 수 있도록)
3. 있으면 children 렌더링

이 컴포넌트를 App.tsx에서 사용할 수 있도록 export해줘.
```

---

### 명령어 6-4: App.tsx에 라우트 등록

```
frontend/src/App.tsx 파일을 수정해줘:

1. Login, Signup 페이지 import
2. ProtectedRoute 컴포넌트 import
3. 라우트 추가:
   - /login: Login
   - /signup: Signup
   - /admin: ProtectedRoute로 감싼 AdminPage (나중에 만들 예정)
   - /profile: ProtectedRoute로 감싼 ProfilePage (나중에 만들 예정)

라우트가 제대로 작동하는지 확인해줘.
```

---

## ✅ 7단계: 테스트 및 확인

### 명령어 7-1: 백엔드 서버 실행 확인

```
backend 폴더에서 다음을 실행해줘:

1. npm install (의존성 설치)
2. npx prisma generate (Prisma 클라이언트 생성)
3. npm run dev (개발 서버 실행)

서버가 http://localhost:4000에서 실행되는지 확인해줘.
에러가 있으면 에러 메시지를 알려줘.
```

---

### 명령어 7-2: 프론트엔드 서버 실행 확인

```
frontend 폴더에서 다음을 실행해줘:

1. npm install (의존성 설치)
2. npm run dev (개발 서버 실행)

서버가 http://localhost:5173 (또는 다른 포트)에서 실행되는지 확인해줘.
에러가 있으면 에러 메시지를 알려줘.
```

---

### 명령어 7-3: 회원가입 테스트

```
브라우저에서 회원가입 페이지를 열고 다음을 테스트해줘:

1. 이름, 이메일, 비밀번호 입력
2. "회원가입" 버튼 클릭
3. 성공 시 로그인 페이지로 이동하는지 확인
4. 콘솔에 에러가 없는지 확인

문제가 있으면 알려줘.
```

---

### 명령어 7-4: 로그인 테스트

```
브라우저에서 로그인 페이지를 열고 다음을 테스트해줘:

1. 회원가입한 이메일과 비밀번호 입력
2. "로그인" 버튼 클릭
3. 성공 시 홈 페이지로 이동하는지 확인
4. localStorage에 token이 저장되었는지 확인

문제가 있으면 알려줘.
```

---

## 📋 다음 단계 안내

위 단계들이 모두 완료되면 다음 기능들을 순서대로 구현할 수 있습니다:

- 일정 관리 시스템 (투표, 달력)
- 갤러리 시스템 (사진, 동영상)
- 관리자 페이지
- 자동화 시스템

각 기능도 동일한 방식으로 단계별 명령어를 제공할 수 있습니다.

---

## 🆘 문제 해결

### 에러가 발생했을 때

1. **에러 메시지 복사**: 터미널이나 브라우저 콘솔의 에러 메시지를 복사
2. **에러 내용 전달**: "이 에러를 수정해줘: [에러 메시지 붙여넣기]"
3. **수정 확인**: 수정 후 다시 테스트

### 명령어가 작동하지 않을 때

1. **단계 확인**: 이전 단계가 완료되었는지 확인
2. **파일 확인**: 필요한 파일들이 생성되었는지 확인
3. **의존성 확인**: npm install이 실행되었는지 확인

---

**이 가이드를 따라하면 기본 인증 시스템이 완성됩니다!** 🎉

