# 🎯 Cursor AI 단계별 실행 가이드 (복사-붙여넣기용)

> **초보자를 위한 완전 자동화 가이드**  
> 각 단계의 명령어를 그대로 복사해서 Cursor AI에 붙여넣기만 하면 됩니다.  
> 한 단계가 완료되면 다음 단계로 진행하세요.

---

## ⚠️ 중요 안내

1. **순서대로 진행**: 번호 순서대로 하나씩 진행하세요
2. **완료 확인**: 각 단계 완료 후 "완료되었나요?" 또는 "에러 있나요?" 확인
3. **에러 발생 시**: 에러 메시지를 복사해서 "이 에러를 수정해줘"라고 요청
4. **한 번에 하나씩**: 여러 단계를 동시에 요청하지 마세요

---

## 📦 1단계: 프로젝트 기본 구조 생성

### 명령어 1-1: 프로젝트 폴더 구조 생성

```
프로젝트 루트 디렉토리에 다음 폴더 구조를 만들어줘:
- backend/
- frontend/
- scripts/

각 폴더가 제대로 생성되었는지 확인해줘.
```

**완료 확인**: `ls` 명령어로 폴더가 생성되었는지 확인

---

### 명령어 1-2: Backend package.json 생성

```
backend 폴더에 package.json 파일을 만들어줘. 다음 내용을 포함해줘:

{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only --ignore-watch node_modules src/app.ts",
    "build": "tsc",
    "start": "node dist/app.js",
    "postinstall": "prisma generate"
  },
  "engines": {
    "node": "18.x"
  },
  "dependencies": {
    "@prisma/client": "^6.12.0",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node-cron": "^3.0.11",
    "axios": "^1.11.0",
    "bcrypt": "^6.0.0",
    "cloudinary": "^2.8.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.0",
    "express": "^5.1.0",
    "express-rate-limit": "^8.1.0",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.1",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.6",
    "prisma": "^6.12.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3",
    "winston": "^3.18.3"
  }
}

파일이 제대로 생성되었는지 확인해줘.
```

---

### 명령어 1-3: Frontend package.json 생성

```
frontend 폴더에 package.json 파일을 만들어줘. 다음 내용을 포함해줘:

{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .ts,.tsx",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@chakra-ui/icons": "^2.1.0",
    "@chakra-ui/react": "^2.7.2",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "axios": "^1.12.2",
    "dayjs": "^1.11.18",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.7.0",
    "react-youtube": "^10.1.0",
    "recharts": "^3.2.1",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.6.0",
    "typescript": "~5.8.3",
    "vite": "^7.0.4",
    "eslint": "^9.30.1"
  }
}

파일이 제대로 생성되었는지 확인해줘.
```

---

### 명령어 1-4: .gitignore 파일 생성

```
프로젝트 루트에 .gitignore 파일을 만들어줘. 다음 내용을 포함해줘:

# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/

# Production
dist/
build/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Database
*.db
*.db-journal
backend/dev.db
backend/prisma/dev.db

# Uploads
backend/uploads/
backend/backups/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

파일이 제대로 생성되었는지 확인해줘.
```

---

## 🗄️ 2단계: 데이터베이스 스키마 설정

### 명령어 2-1: Prisma 초기화

```
backend 폴더에서 Prisma를 초기화해줘:
1. prisma 폴더 생성
2. schema.prisma 파일 생성
3. 기본 설정 추가

PostgreSQL을 사용하도록 설정해줘.
```

---

### 명령어 2-2: Prisma Schema 작성

```
backend/prisma/schema.prisma 파일을 만들어줘. 다음 모델들을 모두 포함해줘:

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  password      String
  name          String
  phone         String?
  role          String    @default("MEMBER") // SUPER_ADMIN, ADMIN, MEMBER
  status        String    @default("ACTIVE") // ACTIVE, INACTIVE, SUSPENDED, DELETED
  avatarUrl     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  createdGames  Game[]
  votes         Vote[]
  galleryUploads Gallery[]
  galleryLikes  GalleryLike[]
  galleryComments GalleryComment[]
}

model Game {
  id            Int       @id @default(autoincrement())
  date          DateTime
  time          String?
  location      String
  eventType     String    // 매치, 자체, 회식, 기타
  gameType      String?   // 정식, 연습
  autoGenerated Boolean   @default(false)
  createdById   Int
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  createdBy     User      @relation(fields: [createdById], references: [id])
}

model VoteSession {
  id            Int       @id @default(autoincrement())
  weekStartDate DateTime
  startTime     DateTime
  endTime       DateTime
  isActive      Boolean   @default(true)
  isCompleted   Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  votes         Vote[]
}

model Vote {
  id            Int       @id @default(autoincrement())
  voteSessionId Int
  userId        Int
  selectedDays  Json      // ["월", "화"] 또는 ["불참"]
  createdAt     DateTime  @default(now())
  
  voteSession   VoteSession @relation(fields: [voteSessionId], references: [id])
  user          User      @relation(fields: [userId], references: [id])
  
  @@unique([voteSessionId, userId])
}

model Gallery {
  id            Int       @id @default(autoincrement())
  title         String
  imageUrl      String
  uploaderId    Int
  eventDate     DateTime?
  eventType     String    @default("기타")
  clickCount    Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  uploader      User      @relation(fields: [uploaderId], references: [id])
  likes         GalleryLike[]
  comments      GalleryComment[]
  tags          Tag[]
}

model GalleryLike {
  id        Int      @id @default(autoincrement())
  galleryId Int
  userId    Int
  createdAt DateTime @default(now())
  
  gallery   Gallery  @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])
  
  @@unique([galleryId, userId])
}

model GalleryComment {
  id        Int      @id @default(autoincrement())
  galleryId Int
  userId    Int
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  gallery   Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id])
}

model Tag {
  id        Int      @id @default(autoincrement())
  name      String
  galleryId Int
  
  gallery   Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
}

model VideoViewStat {
  id          Int      @id @default(autoincrement())
  videoKey    String   @unique
  viewCount   Int      @default(0)
  lastViewedAt DateTime?
}

모든 관계가 올바르게 설정되었는지 확인해줘.
```

---

### 명령어 2-3: TypeScript 설정 파일 생성

```
backend 폴더에 tsconfig.json 파일을 만들어줘. 다음 내용을 포함해줘:

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "types": ["node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

frontend 폴더에도 tsconfig.json을 만들어줘. Vite + React 프로젝트에 맞게 설정해줘.
```

---

## 🔧 3단계: Backend 기본 설정

### 명령어 3-1: Express 서버 기본 파일 생성

```
backend/src/app.ts 파일을 만들어줘. 다음을 포함해줘:

1. Express 서버 초기화
2. CORS 설정 (모든 origin 허용)
3. body-parser 미들웨어 (JSON, URL-encoded)
4. Helmet 보안 미들웨어
5. Morgan 로깅 미들웨어
6. 기본 라우트 설정 (/api/auth)
7. 에러 핸들링 미들웨어
8. 포트 4000에서 서버 시작

dotenv를 사용해서 환경변수를 로드해줘.
```

---

### 명령어 3-2: 환경 변수 예제 파일 생성

```
backend 폴더에 .env.example 파일을 만들어줘. 다음 내용을 포함해줘:

# Database
DATABASE_URL="postgresql://user:password@localhost:5432/dbname"

# JWT
JWT_SECRET="your-secret-key-change-this-in-production"

# Server
PORT=4000
NODE_ENV=development

# Kakao Map API
KAKAO_API_KEY="your-kakao-api-key"

# Cloudinary
CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"

# Gmail (선택사항)
GMAIL_USER="your-email@gmail.com"
GMAIL_PASS="your-app-password"

각 환경변수에 대한 설명 주석도 추가해줘.
```

---

### 명령어 3-3: 인증 미들웨어 생성

```
backend/src/middlewares/authMiddleware.ts 파일을 만들어줘:

1. authenticateToken 함수:
   - Authorization 헤더에서 Bearer 토큰 추출
   - JWT 토큰 검증
   - 검증 성공 시 req.user에 사용자 정보 저장
   - 토큰이 없거나 유효하지 않으면 401 에러 반환

2. optionalAuthenticate 함수:
   - 토큰이 있으면 사용자 정보 저장
   - 토큰이 없으면 req.user를 null로 설정
   - 에러 발생하지 않음

jsonwebtoken과 @prisma/client를 사용해줘.
```

---

### 명령어 3-4: 보안 미들웨어 생성

```
backend/src/middlewares/security.ts 파일을 만들어줘:

1. express-rate-limit 설정:
   - 일반 API: 300회/15분
   - 인증 API: 15회/15분

2. Helmet 설정:
   - 기본 보안 헤더 설정

3. CORS 설정:
   - 모든 origin 허용
   - credentials: true

각 미들웨어를 export해줘.
```

---

## 🔐 4단계: 인증 API 구현

### 명령어 4-1: 회원가입 API

```
backend/src/routes/auth.ts 파일을 만들어줘. 다음 엔드포인트를 포함해줘:

POST /api/auth/register
- 요청 본문: { name, email, password, phone? }
- 비밀번호를 bcrypt로 해싱 (bcrypt.hash, salt rounds: 10)
- 이메일 중복 체크 (Prisma로 User 조회)
- 중복이면 409 에러 반환
- 새 사용자 생성 (role: "MEMBER", status: "ACTIVE")
- JWT 토큰 생성 (jsonwebtoken.sign)
- 응답: { token, user: { id, email, name, role } }
- 에러 처리: 400 (입력 오류), 409 (중복 이메일), 500 (서버 오류)

에러 메시지는 한국어로 반환해줘.
```

---

### 명령어 4-2: 로그인 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

POST /api/auth/login
- 요청 본문: { email, password }
- 이메일로 사용자 조회 (Prisma)
- 사용자가 없으면 401 에러 반환
- bcrypt.compare로 비밀번호 검증
- 비밀번호가 틀리면 401 에러 반환
- JWT 토큰 생성
- 응답: { token, user: { id, email, name, role } }
- 에러 처리: 401 (인증 실패), 500 (서버 오류)

에러 메시지는 한국어로 반환해줘.
```

---

### 명령어 4-3: 프로필 조회 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

GET /api/auth/profile
- authenticateToken 미들웨어 사용 (로그인 필요)
- req.user에서 사용자 ID 가져오기
- Prisma로 사용자 정보 조회
- 응답: { user: { id, email, name, phone, role, status, ... } }
- 에러 처리: 401 (인증 필요), 404 (사용자 없음), 500 (서버 오류)
```

---

### 명령어 4-4: 라우터 등록

```
backend/src/app.ts 파일에 auth 라우터를 등록해줘:

1. auth.ts에서 라우터 import
2. app.use('/api/auth', authRouter) 추가
3. 라우터가 /api/auth 경로로 등록되었는지 확인

서버를 실행해서 라우터가 제대로 등록되었는지 확인해줘.
```

---

## 🎨 5단계: Frontend 기본 설정

### 명령어 5-1: Vite 프로젝트 초기화

```
frontend 폴더에서 Vite + React + TypeScript 프로젝트를 초기화해줘:

1. vite.config.ts 파일 생성
2. index.html 파일 생성
3. src/main.tsx 파일 생성
4. src/App.tsx 파일 생성
5. 기본 React 앱 구조 설정

Chakra UI는 나중에 추가할 예정이니 일단 기본 구조만 만들어줘.
```

---

### 명령어 5-2: Chakra UI 설정

```
frontend/src/main.tsx 파일을 수정해줘:

1. @chakra-ui/react의 ChakraProvider import
2. ChakraProvider로 App 컴포넌트 감싸기
3. 기본 테마 설정 (색상: brand blue #004ea8)

Chakra UI가 제대로 설정되었는지 확인해줘.
```

---

### 명령어 5-3: React Router 설정

```
frontend/src/App.tsx 파일을 수정해줘:

1. react-router-dom의 BrowserRouter, Routes, Route import
2. 기본 라우트 설정:
   - /: MainDashboard (나중에 만들 예정)
   - /login: LoginPage (나중에 만들 예정)
   - /signup: SignupPage (나중에 만들 예정)
3. 각 페이지 컴포넌트는 일단 "페이지 준비 중" 텍스트만 표시

라우터가 제대로 작동하는지 확인해줘.
```

---

### 명령어 5-4: API 클라이언트 설정

```
frontend/src/config/api.ts 파일을 만들어줘:

1. getApiBaseUrl 함수:
   - 로컬 개발: '/api/auth' 반환
   - 프로덕션: 환경변수 VITE_API_BASE_URL 사용
   - 없으면 '/api/auth' 기본값

2. getApiUrl 함수:
   - 엔드포인트 경로를 받아서 완전한 URL 반환
   - 예: getApiUrl('/register') → '/api/auth/register' 또는 'https://.../api/auth/register'

3. buildUrl 헬퍼 함수:
   - baseUrl과 path를 조합
   - 슬래시 중복 제거

각 함수에 타입을 명시해줘 (TypeScript).
```

---

### 명령어 5-5: API 요청 유틸리티 생성

```
frontend/src/api/auth.ts 파일을 만들어줘:

1. request 함수:
   - fetch를 래핑
   - 타임아웃 30초 설정 (AbortController 사용)
   - Authorization 헤더에 토큰 자동 추가 (localStorage에서 가져오기)
   - 에러 처리 (네트워크 오류, 타임아웃, HTTP 오류)
   - JSON 응답 파싱

2. register 함수:
   - POST /api/auth/register 호출
   - { name, email, password, phone? } 전송
   - { token, user } 반환

3. login 함수:
   - POST /api/auth/login 호출
   - { email, password } 전송
   - { token, user } 반환

4. getProfile 함수:
   - GET /api/auth/profile 호출
   - { user } 반환

각 함수에 타입을 명시해줘.
```

---

### 명령어 5-6: Zustand 상태 관리 설정

```
frontend/src/store/auth.ts 파일을 만들어줘:

1. Zustand store 생성:
   - user: User | null
   - token: string | null
   - setUser: (user: User | null) => void
   - setToken: (token: string | null) => void
   - logout: () => void

2. localStorage 연동:
   - 초기화 시 localStorage에서 user, token 복원
   - setUser, setToken 호출 시 localStorage에 저장
   - logout 시 localStorage 클리어

User 타입은 { id: number, email: string, name: string, role: string }로 정의해줘.
```

---

## 📝 6단계: 로그인/회원가입 페이지 구현

### 명령어 6-1: 회원가입 페이지 생성

```
frontend/src/pages/Signup.tsx 파일을 만들어줘:

1. Chakra UI 컴포넌트 사용:
   - Box, VStack, FormControl, FormLabel, Input, Button, useToast

2. 입력 필드:
   - 이름 (name)
   - 이메일 (email)
   - 비밀번호 (password, type="password")
   - 전화번호 (phone, 선택사항)

3. 유효성 검증:
   - 이메일 형식 검증
   - 비밀번호 최소 6자

4. 제출 처리:
   - register API 호출
   - 성공 시 토큰 저장 (setToken, setUser)
   - 로그인 페이지로 리다이렉트 (useNavigate)
   - 에러 시 토스트 메시지 표시

5. 로딩 상태 표시 (isLoading)

디자인은 깔끔하고 현대적으로 만들어줘.
```

---

### 명령어 6-2: 로그인 페이지 생성

```
frontend/src/pages/Login.tsx 파일을 만들어줘:

1. Chakra UI 컴포넌트 사용:
   - Box, VStack, FormControl, FormLabel, Input, Button, useToast

2. 입력 필드:
   - 이메일 (email)
   - 비밀번호 (password, type="password")

3. 제출 처리:
   - login API 호출
   - 성공 시 토큰 저장 (setToken, setUser)
   - 홈 페이지로 리다이렉트
   - 에러 시 토스트 메시지 표시

4. 로딩 상태 표시

5. "회원가입" 링크 추가 (회원가입 페이지로 이동)

디자인은 회원가입 페이지와 일관성 있게 만들어줘.
```

---

### 명령어 6-3: ProtectedRoute 컴포넌트 생성

```
frontend/src/components/ProtectedRoute.tsx 파일을 만들어줘:

1. useAuthStore에서 user, token 가져오기
2. user와 token이 없으면:
   - Navigate 컴포넌트로 /login으로 리다이렉트
   - state에 현재 경로 저장 (로그인 후 돌아올 수 있도록)
3. 있으면 children 렌더링

이 컴포넌트를 App.tsx에서 사용할 수 있도록 export해줘.
```

---

### 명령어 6-4: App.tsx에 라우트 등록

```
frontend/src/App.tsx 파일을 수정해줘:

1. Login, Signup 페이지 import
2. ProtectedRoute 컴포넌트 import
3. 라우트 추가:
   - /login: Login
   - /signup: Signup
   - /admin: ProtectedRoute로 감싼 AdminPage (나중에 만들 예정)
   - /profile: ProtectedRoute로 감싼 ProfilePage (나중에 만들 예정)

라우트가 제대로 작동하는지 확인해줘.
```

---

## ✅ 7단계: 테스트 및 확인

### 명령어 7-1: 백엔드 서버 실행 확인

```
backend 폴더에서 다음을 실행해줘:

1. npm install (의존성 설치)
2. npx prisma generate (Prisma 클라이언트 생성)
3. npm run dev (개발 서버 실행)

서버가 http://localhost:4000에서 실행되는지 확인해줘.
에러가 있으면 에러 메시지를 알려줘.
```

---

### 명령어 7-2: 프론트엔드 서버 실행 확인

```
frontend 폴더에서 다음을 실행해줘:

1. npm install (의존성 설치)
2. npm run dev (개발 서버 실행)

서버가 http://localhost:5173 (또는 다른 포트)에서 실행되는지 확인해줘.
에러가 있으면 에러 메시지를 알려줘.
```

---

### 명령어 7-3: 회원가입 테스트

```
브라우저에서 회원가입 페이지를 열고 다음을 테스트해줘:

1. 이름, 이메일, 비밀번호 입력
2. "회원가입" 버튼 클릭
3. 성공 시 로그인 페이지로 이동하는지 확인
4. 콘솔에 에러가 없는지 확인

문제가 있으면 알려줘.
```

---

### 명령어 7-4: 로그인 테스트

```
브라우저에서 로그인 페이지를 열고 다음을 테스트해줘:

1. 회원가입한 이메일과 비밀번호 입력
2. "로그인" 버튼 클릭
3. 성공 시 홈 페이지로 이동하는지 확인
4. localStorage에 token이 저장되었는지 확인

문제가 있으면 알려줘.
```

---

## 📋 다음 단계 안내

위 단계들이 모두 완료되면 다음 기능들을 순서대로 구현할 수 있습니다:

- 일정 관리 시스템 (투표, 달력)
- 갤러리 시스템 (사진, 동영상)
- 관리자 페이지
- 자동화 시스템

각 기능도 동일한 방식으로 단계별 명령어를 제공할 수 있습니다.

---

## 🆘 문제 해결

### 에러가 발생했을 때

1. **에러 메시지 복사**: 터미널이나 브라우저 콘솔의 에러 메시지를 복사
2. **에러 내용 전달**: "이 에러를 수정해줘: [에러 메시지 붙여넣기]"
3. **수정 확인**: 수정 후 다시 테스트

### 명령어가 작동하지 않을 때

1. **단계 확인**: 이전 단계가 완료되었는지 확인
2. **파일 확인**: 필요한 파일들이 생성되었는지 확인
3. **의존성 확인**: npm install이 실행되었는지 확인

---

**이 가이드를 따라하면 기본 인증 시스템이 완성됩니다!** 🎉

---

## 📅 8단계: 일정 관리 시스템 (투표 시스템)

### 명령어 8-1: 투표 세션 생성 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

POST /api/auth/votes/sessions
- authenticateToken 미들웨어 사용 (관리자만)
- 요청 본문: { weekStartDate: "2025-11-10" } (다음 주 월요일)
- weekStartDate로 이번 주 월요일 계산
- startTime: weekStartDate의 00:01
- endTime: weekStartDate + 3일 (목요일) 17:00
- 중복 체크: 같은 주간의 세션이 있으면 400 에러
- VoteSession 생성 (isActive: true, isCompleted: false)
- 응답: { message, voteSession }
- 에러 처리: 401 (인증 필요), 403 (관리자만), 400 (중복), 500 (서버 오류)
```

---

### 명령어 8-2: 투표 제출 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

POST /api/auth/votes
- authenticateToken 미들웨어 사용 (로그인 필요)
- 요청 본문: { voteSessionId: 1, selectedDays: ["월", "화"] 또는 ["불참"] }
- 기존 투표 확인 (같은 세션, 같은 사용자)
- 기존 투표가 있으면 삭제
- selectedDays를 JSON.stringify()로 저장
- 새 Vote 생성
- 응답: { message, vote }
- 에러 처리: 401 (인증 필요), 400 (입력 오류), 404 (세션 없음), 500 (서버 오류)
```

---

### 명령어 8-3: 통합 투표 데이터 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

GET /api/auth/votes/unified
- 인증 불필요 (비로그인도 접근 가능)
- 활성 세션 조회 (isActive: true 또는 최신 세션)
- 지난 주 완료된 세션 조회 (isCompleted: true, 최신)
- 모든 회원 정보 조회
- 각 회원의 투표 여부 확인
- 투표 결과 집계:
  - 각 요일별 투표 수 (월~금)
  - 각 요일별 참여자 목록
  - 불참자 목록
- 응답: {
    activeSession: { id, weekStartDate, isActive, isCompleted, votes, results, participants },
    lastWeekResults: { sessionId, weekRange, results, participants, totalParticipants },
    allMembers: [{ id, name, email, role }]
  }
- 에러 처리: 500 (서버 오류)
```

---

### 명령어 8-4: 투표 결과 조회 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

GET /api/auth/votes/results?sessionId=1
- 인증 불필요
- sessionId로 VoteSession 조회
- 해당 세션의 모든 투표 조회
- 각 요일별 투표 수 집계
- 각 요일별 참여자 목록 생성
- 응답: {
    sessionId,
    weekRange,
    isActive,
    isCompleted,
    results: { "월": { count, participants }, ... },
    participants: [{ userId, userName, selectedDays, votedAt }],
    totalParticipants,
    totalVotes
  }
- 에러 처리: 404 (세션 없음), 500 (서버 오류)
```

---

### 명령어 8-5: 투표 세션 마감 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

POST /api/auth/votes/sessions/:id/complete
- authenticateToken 미들웨어 사용 (관리자만)
- 세션 ID로 VoteSession 조회
- isCompleted: true로 변경
- 투표 결과 집계
- 자동생성된 경기 삭제 (autoGenerated: true인 Game 삭제)
- 투표 결과에 따라 새로운 경기 자동 생성:
  - 가장 많이 선택된 요일들 찾기
  - 각 요일마다 Game 생성 (autoGenerated: true)
- 응답: { message, completedSession, generatedGames }
- 에러 처리: 401 (인증 필요), 403 (관리자만), 404 (세션 없음), 500 (서버 오류)
```

---

### 명령어 8-6: 일정 페이지 기본 구조 생성

```
frontend/src/pages/SchedulePageV2.tsx 파일을 만들어줘:

1. 기본 구조:
   - Chakra UI 컴포넌트 사용
   - useAuthStore에서 user 가져오기
   - useState로 상태 관리 (selectedDays, voteResults, unifiedVoteData)

2. 데이터 로딩:
   - useEffect에서 /api/auth/votes/unified 호출
   - unifiedVoteData 상태에 저장

3. 기본 레이아웃:
   - Box 컨테이너
   - 제목: "일정 관리"
   - "다음주 경기 투표하기" 카드 (나중에 구현)

일단 기본 구조만 만들어줘. 기능은 다음 단계에서 추가할 예정.
```

---

### 명령어 8-7: 투표 UI 구현

```
frontend/src/pages/SchedulePageV2.tsx에 투표 UI를 추가해줘:

1. "다음주 경기 투표하기" 카드:
   - 활성 세션이 있으면 투표 UI 표시
   - 요일 선택 버튼 (월, 화, 수, 목, 금, 불참)
   - 선택된 요일은 파란색으로 표시
   - "투표하기" 버튼 (로그인 필요, 비로그인 시 비활성화)
   - 투표 마감 시 "투표종료" 배지 표시

2. 투표 제출:
   - handleVoteSubmit 함수:
     - selectedDays 배열 생성
     - POST /api/auth/votes 호출
     - 성공 시 토스트 메시지
     - unifiedVoteData 다시 로드

3. 투표 결과 표시:
   - 투표 마감 시 각 요일별 투표 수 표시
   - 투표한 인원명 표시 (툴팁)

디자인은 깔끔하고 직관적으로 만들어줘.
```

---

### 명령어 8-8: 달력 뷰 구현

```
frontend/src/pages/SchedulePageV2.tsx에 달력 뷰를 추가해줘:

1. 월별 달력:
   - 현재 월 표시
   - 이전/다음 월 이동 버튼
   - 각 날짜 셀에 확정된 경기 표시

2. 경기 표시:
   - 해당 날짜에 경기가 있으면 배지 표시
   - 경기 정보 툴팁 (시간, 장소, 이벤트 타입)
   - 클릭 시 경기 상세 모달

3. 데이터 로딩:
   - GET /api/auth/members 호출 (경기 정보 포함)
   - 각 경기를 날짜별로 그룹화

Chakra UI의 SimpleGrid나 Flex를 사용해서 달력 레이아웃을 만들어줘.
```

---

### 명령어 8-9: 투표 현황 모달 구현

```
frontend/src/pages/SchedulePageV2.tsx에 투표 현황 모달을 추가해줘:

1. 모달 열기:
   - "투표 현황" 버튼 클릭 시 모달 열기
   - useDisclosure 사용

2. 모달 내용:
   - 각 요일별 투표 수 표시
   - 각 요일별 참여자 목록 (이름)
   - 참여자 이름에 마우스 오버 시 툴팁 (전체 정보)
   - 불참자 목록 표시

3. 데이터:
   - unifiedVoteData.activeSession.results 사용
   - 각 요일별 participants 배열 표시

Chakra UI의 Modal 컴포넌트를 사용해줘.
```

---

### 명령어 8-10: 일정 페이지 테스트

```
일정 페이지를 테스트해줘:

1. 브라우저에서 /schedule-v2 페이지 열기
2. 비로그인 상태에서도 페이지가 열리는지 확인
3. 투표하기 버튼이 비활성화되어 있는지 확인
4. 로그인 후 투표하기 버튼이 활성화되는지 확인
5. 요일 선택 후 투표 제출 테스트
6. 투표 결과가 제대로 표시되는지 확인

문제가 있으면 알려줘.
```

---

## ⚽ 9단계: 경기 관리 시스템

### 명령어 9-1: 경기 생성 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

POST /api/auth/games
- authenticateToken 미들웨어 사용 (로그인 필요)
- 요청 본문: {
    date: "2025-11-25",
    time: "19:00",
    location: "풋살장",
    eventType: "매치",
    gameType: "정식",
    selectedMembers: ["정성인", "김철수"], // JSON 배열 또는 문자열
    mercenaryCount: 0,
    memberNames: ["용병1", "용병2"] // JSON 배열 또는 문자열
  }
- 같은 날짜에 경기가 있으면 400 에러 (중복 체크)
- Game 생성 (autoGenerated: false, createdById: 현재 사용자 ID)
- 응답: { message, game }
- 에러 처리: 401 (인증 필요), 400 (입력 오류, 중복), 500 (서버 오류)
```

---

### 명령어 9-2: 경기 조회 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 수정/추가해줘:

GET /api/auth/members
- 인증 불필요 (비로그인도 접근 가능)
- 모든 회원 정보 조회
- 모든 경기 정보 조회 (Game)
- 각 경기의 createdBy 정보 포함
- 응답: {
    members: [{ id, name, email, role, ... }],
    games: [{ id, date, time, location, eventType, createdBy, ... }]
  }
- 에러 처리: 500 (서버 오류)
```

---

### 명령어 9-3: 경기 수정 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

PUT /api/auth/games/:id
- authenticateToken 미들웨어 사용
- 경기 ID로 Game 조회
- 작성자만 수정 가능 (createdById === 현재 사용자 ID 또는 관리자)
- 요청 본문: { date?, time?, location?, eventType?, gameType?, ... }
- Game 업데이트
- 응답: { message, game }
- 에러 처리: 401 (인증 필요), 403 (권한 없음), 404 (경기 없음), 500 (서버 오류)
```

---

### 명령어 9-4: 경기 삭제 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

DELETE /api/auth/games/:id
- authenticateToken 미들웨어 사용
- 경기 ID로 Game 조회
- 작성자 또는 관리자만 삭제 가능
- Game 삭제
- 응답: { message }
- 에러 처리: 401 (인증 필요), 403 (권한 없음), 404 (경기 없음), 500 (서버 오류)
```

---

### 명령어 9-5: 카카오맵 장소 검색 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

GET /api/auth/search-location?query=풋살장
- 인증 불필요
- query 파라미터로 검색어 받기
- 카카오맵 API 호출:
  - URL: https://dapi.kakao.com/v2/local/search/keyword.json
  - 헤더: Authorization: KakaoAK {KAKAO_API_KEY}
  - 파라미터: query, size: 10
- 응답: { documents: [{ place_name, address_name, x, y, ... }] }
- 에러 처리: 400 (검색어 없음), 500 (API 오류)
```

---

### 명령어 9-6: 경기 관리 컴포넌트 생성

```
frontend/src/components/GameManagement.tsx 파일을 만들어줘:

1. 기본 구조:
   - 경기 목록 테이블
   - "경기 추가" 버튼
   - 수정/삭제 버튼

2. Props:
   - games: Game[]
   - onGamesChange: () => void
   - userList: User[]
   - user: User | null

3. 상태 관리:
   - isModalOpen: 모달 열림/닫힘
   - editingGame: 수정 중인 경기
   - formData: 폼 데이터

일단 기본 구조만 만들어줘.
```

---

### 명령어 9-7: 경기 추가 모달 구현

```
frontend/src/components/GameManagement.tsx에 경기 추가 모달을 구현해줘:

1. 모달 열기:
   - "경기 추가" 버튼 클릭 시 모달 열기

2. 입력 필드:
   - 날짜 선택 (Input type="date")
   - 시간 선택 (Input type="time")
   - 이벤트 타입 선택 (Select: 매치, 자체, 회식, 기타)
   - 장소 검색:
     - 검색어 입력 필드
     - "검색" 버튼
     - 검색 결과 목록 표시 (카카오맵 API)
     - 장소 선택 시 자동 입력
   - 회원 선택:
     - 체크박스로 회원 선택
     - 선택된 회원 목록 표시
   - 용병 인원 입력 (Input type="number")
   - 수기 입력:
     - "팀원 추가" 버튼
     - 동적으로 팀원 이름 입력 필드 추가

3. 제출:
   - handleSubmit 함수
   - POST /api/auth/games 호출
   - 성공 시 모달 닫기 및 목록 새로고침

Chakra UI의 Modal 컴포넌트를 사용해줘.
```

---

### 명령어 9-8: 경기 목록 테이블 구현

```
frontend/src/components/GameManagement.tsx에 경기 목록 테이블을 구현해줘:

1. 테이블 컬럼:
   - 날짜
   - 시간
   - 장소
   - 이벤트 타입
   - 인원 (회원 수 + 용병 수 + 수기 입력 수)
   - 생성자
   - 작업 (수정, 삭제 버튼)

2. 데이터 표시:
   - games 배열을 map으로 순회
   - 각 경기 정보 표시
   - 날짜는 한국어 형식으로 포맷팅

3. 수정/삭제:
   - 수정 버튼 클릭 시 모달 열기 (기존 데이터로 채우기)
   - 삭제 버튼 클릭 시 확인 모달 → 삭제 API 호출

Chakra UI의 Table 컴포넌트를 사용해줘.
```

---

### 명령어 9-9: 경기 관리 테스트

```
경기 관리 기능을 테스트해줘:

1. 관리자 페이지에서 경기 관리 섹션 열기
2. "경기 추가" 버튼 클릭
3. 모든 필드 입력 후 제출
4. 경기 목록에 추가되었는지 확인
5. 수정 기능 테스트
6. 삭제 기능 테스트
7. 장소 검색 기능 테스트

문제가 있으면 알려줘.
```

---

## 📸 10단계: 사진 갤러리 시스템

### 명령어 10-1: 갤러리 조회 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

GET /api/auth/gallery
- 인증 불필요 (비로그인도 접근 가능)
- 쿼리 파라미터:
  - page: 페이지 번호 (기본값: 1)
  - limit: 페이지당 항목 수 (기본값: 20)
  - eventType: 이벤트 타입 필터 (매치, 자체, 회식, 기타, all)
  - sortBy: 정렬 기준 (latest, oldest, likes, comments)
- 인증 토큰이 있으면 좋아요 상태 포함
- Gallery 조회 (페이지네이션, 정렬, 필터링)
- 각 갤러리 항목의 좋아요 수, 댓글 수 포함
- 응답: {
    data: {
      items: [{ id, title, imageUrl, uploader, likesCount, commentsCount, isLiked, ... }],
      total: 총 개수,
      page: 현재 페이지,
      limit: 페이지당 개수
    }
  }
- 에러 처리: 500 (서버 오류)
```

---

### 명령어 10-2: 사진 업로드 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

POST /api/auth/gallery/upload
- authenticateToken 미들웨어 사용 (로그인 필요)
- multipart/form-data로 이미지 파일 받기
- 파일 검증:
  - 확장자: .jpg, .jpeg, .png, .webp만 허용
  - 크기: 최대 15MB
- Cloudinary에 이미지 업로드
- Gallery 레코드 생성:
  - title, imageUrl, uploaderId, eventDate, eventType, tags
- 응답: { success: true, data: [galleryItem] }
- 에러 처리: 401 (인증 필요), 400 (파일 오류), 500 (서버 오류)
```

---

### 명령어 10-3: 갤러리 좋아요/댓글 API

```
backend/src/routes/auth.ts에 다음 엔드포인트들을 추가해줘:

POST /api/auth/gallery/:id/like
- authenticateToken 미들웨어 사용
- 좋아요 토글 (있으면 삭제, 없으면 생성)
- 응답: { isLiked: boolean, likesCount: number }

POST /api/auth/gallery/:id/comments
- authenticateToken 미들웨어 사용
- 요청 본문: { content: "댓글 내용" }
- GalleryComment 생성
- 응답: { comment: { id, content, user, createdAt } }

PUT /api/auth/gallery/:id/comments/:commentId
- authenticateToken 미들웨어 사용
- 댓글 작성자만 수정 가능
- 요청 본문: { content: "수정된 댓글" }
- 응답: { comment }

DELETE /api/auth/gallery/:id/comments/:commentId
- authenticateToken 미들웨어 사용
- 댓글 작성자만 삭제 가능
- 응답: { message }

각 엔드포인트에 에러 처리 포함 (401, 403, 404, 500)
```

---

### 명령어 10-4: 갤러리 클릭 수 API

```
backend/src/routes/auth.ts에 다음 엔드포인트를 추가해줘:

POST /api/auth/gallery/:id/view
- 인증 불필요
- Gallery ID로 조회
- clickCount 1 증가
- 응답: { clickCount: number }
- 에러 처리: 404 (갤러리 없음), 500 (서버 오류)
```

---

### 명령어 10-5: 사진 갤러리 페이지 기본 구조

```
frontend/src/pages/PhotoGalleryPage.tsx 파일을 만들어줘:

1. 기본 구조:
   - Instagram 스타일 그리드 레이아웃
   - 정렬 옵션 (업로드순, 행사날짜순, 좋아요순, 댓글순)
   - 필터링 (이벤트 타입)

2. 데이터 로딩:
   - useEffect에서 GET /api/auth/gallery 호출
   - 페이지네이션 처리

3. 상태 관리:
   - posts: InstagramPost[]
   - sortBy: 정렬 기준
   - eventType: 필터 타입
   - selectedPost: 선택된 포스트 (상세 모달용)

일단 기본 구조만 만들어줘.
```

---

### 명령어 10-6: 사진 그리드 레이아웃 구현

```
frontend/src/pages/PhotoGalleryPage.tsx에 사진 그리드 레이아웃을 구현해줘:

1. 그리드:
   - SimpleGrid 사용 (columns: { base: 2, md: 3, lg: 4 })
   - 각 포스트를 카드로 표시

2. 썸네일:
   - 이미지 표시 (aspectRatio: 1)
   - 마우스 오버 시 좋아요 아이콘 표시
   - 하단에 좋아요, 댓글, 클릭 수 표시 (툴팁)

3. 클릭:
   - 썸네일 클릭 시 상세 모달 열기
   - POST /api/auth/gallery/:id/view 호출 (클릭 수 증가)

4. 정렬/필터:
   - 상단에 Select 컴포넌트로 정렬 옵션
   - 이벤트 타입 필터

디자인은 Instagram과 유사하게 만들어줘.
```

---

### 명령어 10-7: 사진 상세 모달 구현

```
frontend/src/pages/PhotoGalleryPage.tsx에 사진 상세 모달을 구현해줘:

1. 모달:
   - 이미지 확대 표시
   - 좋아요, 댓글, 클릭 수 표시
   - 댓글 목록
   - 댓글 입력 필드 (로그인 필요)

2. 좋아요:
   - 하트 아이콘 클릭 시 POST /api/auth/gallery/:id/like 호출
   - 좋아요 상태 토글

3. 댓글:
   - 댓글 목록 표시
   - 댓글 추가 (POST /api/auth/gallery/:id/comments)
   - 댓글 수정/삭제 (작성자만)

4. 수정/삭제:
   - 작성자만 수정/삭제 버튼 표시
   - 수정 모달
   - 삭제 확인 후 삭제

Chakra UI의 Modal 컴포넌트를 사용해줘.
```

---

### 명령어 10-8: 사진 업로드 기능 구현

```
frontend/src/pages/PhotoGalleryPage.tsx에 사진 업로드 기능을 구현해줘:

1. 업로드 버튼:
   - 로그인한 사용자만 표시
   - 클릭 시 업로드 모달 열기

2. 업로드 모달:
   - 파일 선택 (Input type="file", multiple, accept="image/*")
   - 최대 10장까지 선택 가능
   - 이미지 미리보기
   - 캡션 입력 (Textarea)
   - 행사 날짜 선택 (Input type="date")
   - 이벤트 타입 선택 (Select)
   - 태그 입력 (Input, 쉼표로 구분)

3. 업로드 처리:
   - FormData로 파일 전송
   - POST /api/auth/gallery/upload 호출
   - 이미지 압축 (선택사항)
   - 업로드 중 로딩 상태 표시
   - 성공 시 목록 새로고침

비로그인 사용자는 업로드 버튼이 보이지 않도록 해줘.
```

---

### 명령어 10-9: 사진 갤러리 테스트

```
사진 갤러리 기능을 테스트해줘:

1. 비로그인 상태에서 갤러리 페이지 열기
2. 사진 목록이 표시되는지 확인
3. 사진 클릭 시 상세 모달이 열리는지 확인
4. 로그인 후 업로드 기능 테스트
5. 좋아요 기능 테스트
6. 댓글 추가/수정/삭제 테스트
7. 정렬/필터 기능 테스트

문제가 있으면 알려줘.
```

---

## 🎬 11단계: 동영상 갤러리 시스템

### 명령어 11-1: 동영상 조회 수 API

```
backend/src/routes/auth.ts에 다음 엔드포인트들을 추가해줘:

GET /api/auth/videos/view-stats?ids=video1,video2,video3
- 인증 불필요
- ids 파라미터로 동영상 키 목록 받기 (쉼표로 구분)
- VideoViewStat에서 조회 수 조회
- 응답: { data: { "video1": 10, "video2": 5, ... } }

POST /api/auth/videos/:videoKey/view
- 인증 불필요
- videoKey로 VideoViewStat 조회 또는 생성
- viewCount 1 증가
- lastViewedAt 업데이트
- 응답: { data: { viewCount: number } }

에러 처리 포함
```

---

### 명령어 11-2: 동영상 갤러리 페이지 기본 구조

```
frontend/src/pages/VideoGalleryPage.tsx 파일을 만들어줘:

1. 기본 구조:
   - YouTube 재생목록 자동 동기화
   - 그리드 레이아웃
   - 정렬 옵션

2. YouTube API 연동:
   - YouTube Data API v3 사용
   - 재생목록 ID로 동영상 목록 가져오기
   - localStorage에 저장

3. 상태 관리:
   - items: VideoItem[]
   - selectedItem: 선택된 동영상
   - sortBy: 정렬 기준

일단 기본 구조만 만들어줘.
```

---

### 명령어 11-3: 동영상 그리드 및 상세 모달 구현

```
frontend/src/pages/VideoGalleryPage.tsx에 다음을 구현해줘:

1. 그리드 레이아웃:
   - 사진 갤러리와 유사한 스타일
   - 썸네일 표시
   - 하단에 좋아요, 댓글, 클릭 수 표시 (툴팁)

2. 상세 모달:
   - YouTube 영상 재생 (react-youtube 사용)
   - 좋아요, 댓글, 클릭 수 표시
   - 댓글 목록 및 추가

3. 클릭 수 추적:
   - 동영상 클릭 시 POST /api/auth/videos/:videoKey/view 호출
   - 조회 수 업데이트

사진 갤러리와 일관성 있는 디자인으로 만들어줘.
```

---

## 👑 12단계: 관리자 페이지

### 명령어 12-1: 회원 관리 API

```
backend/src/routes/auth.ts에 다음 엔드포인트들을 추가해줘:

GET /api/auth/members/stats
- authenticateToken 미들웨어 사용 (관리자만)
- 통계 정보 반환:
  - totalMembers: 총 회원 수
  - thisWeekGames: 이번 주 경기 수
  - nextWeekVotes: 다음 주 투표 수
- 응답: { totalMembers, thisWeekGames, nextWeekVotes }

PUT /api/auth/members/:id
- authenticateToken 미들웨어 사용 (관리자만)
- 회원 정보 수정 (name, email, phone, role)
- 응답: { message, member }

PUT /api/auth/members/:id/status
- authenticateToken 미들웨어 사용 (관리자만)
- 회원 상태 변경 (ACTIVE, INACTIVE, SUSPENDED, DELETED)
- 응답: { message }

DELETE /api/auth/members/:id
- authenticateToken 미들웨어 사용 (슈퍼관리자만)
- 회원 삭제
- 응답: { message }

각 엔드포인트에 권한 체크 및 에러 처리 포함
```

---

### 명령어 12-2: 관리자 페이지 기본 구조

```
frontend/src/pages/AdminPageNew.tsx 파일을 만들어줘:

1. 기본 구조:
   - 사이드바 네비게이션
   - 메인 콘텐츠 영역
   - 모바일 반응형 (Drawer 사용)

2. 사이드바 메뉴:
   - 대시보드
   - 회원 관리
   - 투표 결과
   - 투표 세션 관리
   - 경기 관리
   - 알림 관리
   - 활동 분석

3. 라우팅:
   - 쿼리 파라미터로 메뉴 전환 (?menu=members)
   - 각 메뉴별 컴포넌트 렌더링

일단 기본 구조만 만들어줘.
```

---

### 명령어 12-3: 회원 관리 컴포넌트 구현

```
frontend/src/components/MemberManagement.tsx 파일을 만들어줘:

1. 회원 목록 테이블:
   - 이름, 이메일, 전화번호, 역할, 상태
   - 모바일에서 가로 스크롤 가능 (TableContainer, overflowX="auto")

2. 회원 추가/수정:
   - 모달로 회원 정보 입력
   - 역할 선택 (SUPER_ADMIN, ADMIN, MEMBER)
   - 상태 선택 (ACTIVE, INACTIVE, SUSPENDED)

3. 회원 삭제:
   - 삭제 확인 모달
   - 슈퍼관리자만 삭제 가능

4. 권한별 기능 제한:
   - 관리자는 SUPER_ADMIN 등급 변경 불가
   - 관리자는 회원 삭제 불가

Chakra UI의 Table 컴포넌트를 사용해줘.
```

---

### 명령어 12-4: 관리자 대시보드 구현

```
frontend/src/pages/AdminPageNew.tsx에 대시보드 섹션을 구현해줘:

1. 통계 카드:
   - 총 회원 수
   - 이번 주 경기 수
   - 다음 주 투표 수
   - GET /api/auth/members/stats 호출

2. 활동 분석 차트:
   - Recharts 사용
   - 월별 활동 통계
   - 투표 참여율 차트

3. 최근 활동 로그:
   - 최근 경기 생성
   - 최근 투표
   - 최근 회원 가입

디자인은 깔끔하고 정보가 한눈에 들어오도록 만들어줘.
```

---

## 🤖 13단계: 자동화 시스템

### 명령어 13-1: 주간 투표 세션 자동 생성 스케줄러

```
backend/src/app.ts에 node-cron 스케줄러를 추가해줘:

1. 매주 월요일 00:01 실행:
   - cron.schedule('1 0 * * 1', ...)
   - 타임존: 'Asia/Seoul'

2. 다음 주 월요일 계산:
   - 이번 주 월요일 + 7일

3. 투표 세션 생성:
   - weekStartDate: 다음 주 월요일
   - startTime: 다음 주 월요일 00:01
   - endTime: 다음 주 목요일 17:00
   - 중복 체크 (같은 주간의 세션이 있으면 생성하지 않음)

4. 로그 기록:
   - 성공/실패 로그
   - 생성된 세션 ID

스케줄러가 제대로 작동하는지 확인해줘.
```

---

### 명령어 13-2: 투표 마감 자동 처리 스케줄러

```
backend/src/app.ts에 투표 마감 스케줄러를 추가해줘:

1. 매주 목요일 17:00 실행:
   - cron.schedule('0 17 * * 4', ...)

2. 활성 세션 조회:
   - isActive: true인 세션

3. 세션 마감:
   - isCompleted: true로 변경
   - 투표 결과 집계

4. 자동 경기 생성:
   - 기존 autoGenerated 경기 삭제
   - 투표 결과에 따라 새로운 경기 생성

5. 로그 기록

스케줄러가 제대로 작동하는지 확인해줘.
```

---

### 명령어 13-3: 알림 시스템 구현

```
backend/src/utils/notifications.ts 파일을 만들어줘:

1. 경기 당일 알림:
   - 매일 10:00 실행
   - 오늘 날짜의 경기 조회
   - 참여자에게 이메일 알림 발송

2. 미투표자 알림:
   - 매주 목요일 10:00 실행
   - 활성 세션이 있으면
   - 투표하지 않은 회원에게 이메일 알림 발송

3. 이메일 발송:
   - nodemailer 사용
   - Gmail SMTP 설정
   - HTML 이메일 템플릿

각 알림 함수를 export해줘.
```

---

### 명령어 13-4: 알림 스케줄러 등록

```
backend/src/app.ts에 알림 스케줄러를 등록해줘:

1. 경기 당일 알림:
   - cron.schedule('0 10 * * *', ...) // 매일 10시
   - sendGameReminder 함수 호출

2. 미투표자 알림:
   - cron.schedule('0 10 * * 4', ...) // 매주 목요일 10시
   - sendNonVoterReminder 함수 호출

스케줄러가 제대로 작동하는지 확인해줘.
```

---

## 🚀 14단계: 배포 및 최적화

### 명령어 14-1: 환경 변수 설정 가이드

```
프로젝트 루트에 DEPLOYMENT_ENV.md 파일을 만들어줘:

1. Render (백엔드) 환경 변수:
   - DATABASE_URL
   - JWT_SECRET
   - KAKAO_API_KEY
   - CLOUDINARY_URL
   - GMAIL_USER, GMAIL_PASS
   - 각 환경변수에 대한 설명

2. Vercel (프론트엔드) 환경 변수:
   - VITE_API_BASE_URL
   - 각 환경변수에 대한 설명

3. 설정 방법:
   - Render: Dashboard → Environment
   - Vercel: Settings → Environment Variables

각 환경변수를 어떻게 설정하는지 단계별로 설명해줘.
```

---

### 명령어 14-2: 데이터베이스 백업 설정

```
backend/scripts/backup-database.js 파일을 만들어줘:

1. Prisma를 사용한 데이터베이스 덤프
2. 백업 파일 생성 (날짜별)
3. GitHub Actions로 매일 자동 백업
4. .github/workflows/database-backup.yml 생성

백업 스크립트가 제대로 작동하는지 확인해줘.
```

---

### 명령어 14-3: PWA 기능 구현

```
frontend/public/manifest.json 파일을 만들어줘:

1. 앱 정보:
   - name, short_name
   - description
   - start_url
   - display: "standalone"
   - theme_color, background_color

2. 아이콘:
   - 144x144, 192x192, 512x512

3. Service Worker:
   - 오프라인 지원
   - 캐싱 전략

PWA가 제대로 설치되는지 확인해줘.
```

---

## ✅ 최종 체크리스트

모든 기능이 완성되었는지 확인해줘:

- [ ] 인증 시스템 (회원가입, 로그인, JWT)
- [ ] 일정 관리 (투표 시스템, 달력, 경기 관리)
- [ ] 갤러리 (사진/동영상, 좋아요, 댓글, 클릭 수)
- [ ] 관리자 페이지 (회원 관리, 통계, 투표 결과)
- [ ] 자동화 (주간 투표 세션, 알림)
- [ ] 권한 시스템 (비로그인 접근, 로그인 필요 기능)
- [ ] PWA 기능
- [ ] 카카오맵 API 연동
- [ ] 배포 설정 (Render, Vercel)

---

**모든 단계를 완료하면 FC CHAL-GGYEO와 동일한 기능의 홈페이지가 완성됩니다!** 🎉

