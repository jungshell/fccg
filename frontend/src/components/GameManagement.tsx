import React, { useState } from 'react';
import {
  Box,
  Button,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  Badge,
  IconButton,
  HStack,
  VStack,
  Text,
  Alert,
  AlertIcon,
  useDisclosure,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  FormControl,
  FormLabel,
  Input,
  Select,
  useToast,
  Tooltip
} from '@chakra-ui/react';
import { AddIcon, EditIcon, DeleteIcon, CalendarIcon } from '@chakra-ui/icons';
import { getValidToken } from '../api/auth';
import { emitGameConfirmed, emitDataRefreshNeeded, emitAlert } from '../utils/eventBus';
import { showGameConfirmationNotification } from '../utils/pushNotifications';

interface Game {
  id: number;
  date: string;
  time?: string;
  location: string;
  eventType?: '매치' | '회식' | '자체';
  mercenaryCount: number;
  memberNames: string[];
  selectedMembers?: string[];
  createdById: number;
  createdAt: string;
  updatedAt: string;
  createdBy?: {
    id: number;
    name: string;
  };
  attendances?: any[];
  autoGenerated?: boolean; // 자동 생성된 경기임을 표시하는 필드
}

interface GameManagementProps {
  games: Game[];
  onGamesChange: (games: Game[]) => void;
  userList: any[]; // 회원 목록 추가
  onGameDataChanged?: () => void; // 경기 데이터 변경 시 호출할 콜백
}

export default function GameManagement({ games, onGamesChange, userList, onGameDataChanged }: GameManagementProps) {
  console.log('=== GameManagement 컴포넌트 렌더링 ===');
  console.log('GameManagement - 받은 games prop:', games);
  console.log('GameManagement - games 길이:', games?.length);
  console.log('GameManagement - games 타입:', typeof games);
  console.log('GameManagement - games가 배열인가:', Array.isArray(games));
  console.log('GameManagement - games 내용:', JSON.stringify(games, null, 2));

  // 중복 제거: 같은 날짜에 확정일정이 있으면 자동생성일정 제거
  const filteredGames = React.useMemo(() => {
    if (!games || !Array.isArray(games)) return [];
    
    console.log('🔍 GameManagement 필터링 시작:', {
      totalGames: games.length,
      games: games.map(game => ({
        id: game.id,
        date: game.date,
        autoGenerated: game.autoGenerated,
        confirmed: game.confirmed
      }))
    });
    
    const confirmedGames = games.filter(game => !game.autoGenerated);
    const autoGeneratedGames = games.filter(game => game.autoGenerated);
    
    console.log('🔍 게임 분류:', {
      confirmed: confirmedGames.length,
      autoGenerated: autoGeneratedGames.length,
      confirmedGames: confirmedGames.map(g => ({ id: g.id, date: g.date })),
      autoGeneratedGames: autoGeneratedGames.map(g => ({ id: g.id, date: g.date }))
    });
    
    // 확정일정이 있는 날짜들 추출
    const confirmedDates = new Set(
      confirmedGames.map(game => {
        if (!game.date || typeof game.date !== 'string') return null;
        const dateMatch = game.date.match(/(\d{4})\.(\d{2})\.(\d{2})/);
        return dateMatch ? `${dateMatch[1]}.${dateMatch[2]}.${dateMatch[3]}` : null;
      }).filter(Boolean)
    );
    
    console.log('🔍 확정일정 날짜들:', Array.from(confirmedDates));
    
    // 자동생성일정 필터링 임시 비활성화 (디버깅용)
    const filteredAutoGenerated = autoGeneratedGames;
    
    console.log('⚠️ 자동생성일정 필터링 비활성화됨 - 모든 자동생성일정 표시');
    
    /*
    // 자동생성일정 중에서 확정일정이 있는 날짜는 제외
    const filteredAutoGenerated = autoGeneratedGames.filter(game => {
      if (!game.date || typeof game.date !== 'string') return false;
      const dateMatch = game.date.match(/(\d{4})\.(\d{2})\.(\d{2})/);
      const gameDate = dateMatch ? `${dateMatch[1]}.${dateMatch[2]}.${dateMatch[3]}` : null;
      const shouldInclude = gameDate && !confirmedDates.has(gameDate);
      
      console.log('🔍 자동생성일정 필터링:', {
        gameId: game.id,
        gameDate: game.date,
        extractedDate: gameDate,
        shouldInclude,
        reason: shouldInclude ? '포함' : '제외 (확정일정과 중복)'
      });
      
      return shouldInclude;
    });
    */
    
    const result = [...confirmedGames, ...filteredAutoGenerated];
    console.log('🔍 최종 필터링 결과:', {
      original: games.length,
      confirmed: confirmedGames.length,
      autoGenerated: autoGeneratedGames.length,
      filteredAutoGenerated: filteredAutoGenerated.length,
      final: result.length,
      finalGames: result.map(g => ({ id: g.id, date: g.date, autoGenerated: g.autoGenerated }))
    });
    
    return result;
  }, [games]);
  const { isOpen, onOpen, onClose } = useDisclosure();
  const [editingGame, setEditingGame] = useState<Game | null>(null);
  const [formData, setFormData] = useState({
    date: '',
    time: '',
    location: '',
    eventType: '자체' as '매치' | '회식' | '자체',
    mercenaryCount: 0,
    memberNames: ['']
  });
  
  // 선택된 회원들을 별도로 관리
  const [selectedMembers, setSelectedMembers] = useState<string[]>([]);
  
  // 컴포넌트 마운트 시 경기 목록 불러오기 (AdminPageNew에서 이미 로드됨)
  // React.useEffect(() => {
  //   fetchGames();
  // }, []);

  // 투표재개 시 자동생성 일정 제거
  React.useEffect(() => {
    const handleVoteSessionResumed = () => {
      console.log('🔄 투표재개 이벤트 수신 - 자동생성 일정 제거');
      const updatedGames = games.filter(game => !game.autoGenerated);
      onGamesChange(updatedGames);
      console.log('✅ 자동생성 일정 제거 완료:', updatedGames.length, '개 남음');
    };

    // 이벤트 리스너 등록
    window.addEventListener('voteSessionResumed', handleVoteSessionResumed);
    
    // 컴포넌트 마운트 시에도 자동생성 일정 체크
    const autoGeneratedGames = games.filter(game => game.autoGenerated);
    if (autoGeneratedGames.length > 0) {
      console.log('🔍 컴포넌트 마운트 시 자동생성 일정 발견:', autoGeneratedGames.length, '개');
      // 투표 세션이 활성화되어 있다면 자동생성 일정 제거
      const hasActiveVoteSession = window.location.href.includes('vote-results') || 
                                   document.querySelector('[data-vote-active="true"]');
      if (hasActiveVoteSession) {
        console.log('🔄 활성 투표 세션 감지 - 자동생성 일정 제거');
        const updatedGames = games.filter(game => !game.autoGenerated);
        onGamesChange(updatedGames);
      }
    }
    
    return () => {
      window.removeEventListener('voteSessionResumed', handleVoteSessionResumed);
    };
  }, [games, onGamesChange]);
  
  // 경기 목록 불러오기
  const fetchGames = async () => {
    try {
      const token = await getValidToken();
      const response = await fetch('http://localhost:4000/api/auth/members', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      if (response.ok) {
        const unifiedData = await response.json();
        const gamesData = unifiedData.games || [];
        
        // 실제 데이터베이스의 경기 데이터 사용
        if (gamesData && gamesData.length > 0) {
          console.log('🔄 실제 경기 데이터 로드 완료:', gamesData.length, '개');
          
          // 자동 생성된 경기인지 확인 (백엔드에서 받은 autoGenerated 값 사용)
          const processedGames = gamesData.map((game: any) => ({
            ...game,
            autoGenerated: game.autoGenerated === true, // 백엔드에서 받은 autoGenerated 값을 명시적으로 boolean으로 변환
            time: game.time || '', // 시간이 없으면 빈 문자열
            location: game.location || '장소 미정', // 장소가 없으면 기본값
            eventType: game.eventType || '자체' // 이벤트 유형이 없으면 기본값
          }));
          
          onGamesChange(processedGames);
          console.log('✅ 경기 데이터 처리 완료');
        } else {
          console.log('📝 등록된 경기가 없습니다');
          onGamesChange([]);
        }
      }
    } catch (error) {
      console.error('경기 목록 불러오기 오류:', error);
      onGamesChange([]);
    }
  };

  // 실제 회원 기준으로 회원 수 계산 (중복 제거 및 유효성 검사)
  const getUniqueMemberCount = React.useCallback(() => {
    const actualMemberNames = (userList || []).map((m: any) => m.name);
    const filtered = (selectedMembers || []).filter((name: string) => actualMemberNames.includes(name));
    const unique = Array.from(new Set(filtered));
    return unique.length;
  }, [selectedMembers, userList]);
  
  // 카카오맵 검색 관련 상태
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [showSearchResults, setShowSearchResults] = useState(false);
  
  const toast = useToast();

  const handleAddGame = () => {
    setEditingGame(null);
    setSelectedMembers([]); // 선택된 회원 초기화
    setFormData({
      date: '',
      time: '',
      location: '',
      eventType: '자체',
      mercenaryCount: 0,
      memberNames: ['']
    });
    onOpen();
  };

  const handleEditGame = (game: Game) => {
    console.log('🎯 handleEditGame 호출 (v2):', game);
    console.log('🎯 game.autoGenerated:', game.autoGenerated);
    
    // autoGenerated 속성을 명시적으로 설정
    const gameWithAutoGenerated = {
      ...game,
      autoGenerated: game.autoGenerated === true // 명시적으로 boolean으로 변환
    };
    
    setEditingGame(gameWithAutoGenerated);
    console.log('🎯 setEditingGame 완료 (v2):', gameWithAutoGenerated);
    console.log('🎯 autoGenerated 확인:', gameWithAutoGenerated.autoGenerated);
    
    // 날짜를 YYYY-MM-DD 형식으로 변환
    const gameDate = new Date(game.date);
    const formattedDate = gameDate.toISOString().split('T')[0];
    
    // 기존 selectedMembers와 memberNames를 분리하여 로드
    const existingSelectedMembers = parseMemberNames(game.selectedMembers || []);
    const allMemberNames = parseMemberNames(game.memberNames);
    
    // selectedMembers에 없는 것들만 수기입력으로 분리
    const existingManualMembers = allMemberNames.filter(name => 
      !existingSelectedMembers.includes(name) && 
      !name.startsWith('용병') // 용병도 제외
    );
    
    setSelectedMembers(existingSelectedMembers);
    
    setFormData({
      date: formattedDate,
      time: (game.autoGenerated && game.time === '미정') ? '' : (game.time || ''), // 자동생성된 게임의 "미정" 시간은 빈 문자열로 처리
      location: (game.autoGenerated && game.location === '미정') ? '' : game.location, // 자동생성된 게임의 "미정" 장소는 빈 문자열로 처리
      eventType: (game.autoGenerated && (game as any).eventType === '미정') ? '자체' : (game.eventType || '자체'), // 타입 가드
      mercenaryCount: game.mercenaryCount || 0,
      memberNames: existingManualMembers.length > 0 ? existingManualMembers : ['']
    });
    onOpen();
  };

  const handleDeleteGame = async (id: number | string) => {
    try {
      // 통일 유틸로 토큰 확보
      const token = await getValidToken();

      // ID 형식 정리 - 최종 강력한 파싱
      let gameId: number;
      
      console.log('🔍 삭제 원본 ID 분석:', { 
        originalId: id, 
        type: typeof id,
        stringValue: id.toString()
      });
      
      if (typeof id === 'number') {
        gameId = id;
      } else {
        // 문자열인 경우 :1, :0 등 모든 접미사 제거 후 숫자만 추출
        let cleanIdStr = id.toString();
        
        // :1, :0 등 콜론 접미사 제거
        if (cleanIdStr.includes(':')) {
          cleanIdStr = cleanIdStr.split(':')[0];
        }
        
        // 모든 비숫자 문자 제거
        cleanIdStr = cleanIdStr.replace(/[^0-9]/g, '');
        
        gameId = parseInt(cleanIdStr);
        
        console.log('🔧 삭제 ID 파싱 과정:', {
          original: id,
          afterColonRemoval: cleanIdStr,
          finalGameId: gameId
        });
      }
      
      // 유효한 ID인지 확인 (1-99999999 범위로 확장)
      if (isNaN(gameId) || gameId <= 0 || gameId > 99999999) {
        console.error('❌ 유효하지 않은 게임 ID:', { 
          originalId: id, 
          type: typeof id,
          gameId 
        });
        throw new Error(`유효하지 않은 게임 ID: ${id}`);
      }
      
      console.log('✅ 최종 파싱된 삭제 게임 ID:', { originalId: id, gameId });
      
      // 실제 게임 객체에서 ID 재확인
      const actualGame = games.find(g => {
        // 원본 ID와 비교
        if (g.id === id) return true;
        // 파싱된 ID와 비교
        if (typeof g.id === 'number' && g.id === gameId) return true;
        // 문자열 ID인 경우 파싱해서 비교
        if (typeof g.id === 'string') {
          const parsedGameId = parseInt(g.id.replace(/[^0-9]/g, ''));
          if (parsedGameId === gameId) return true;
        }
        return false;
      });
      
      if (actualGame) {
        console.log('🔍 실제 게임 객체 ID:', actualGame.id);
        // 실제 게임 객체의 ID가 숫자이고 다르면 그것을 사용
        if (typeof actualGame.id === 'number' && actualGame.id !== gameId) {
          console.log('⚠️ ID 불일치 감지, 실제 게임 ID 사용:', actualGame.id);
          gameId = actualGame.id;
        } else if (typeof actualGame.id === 'string') {
          // 문자열 ID인 경우 파싱해서 사용
          const parsedId = parseInt(actualGame.id.replace(/[^0-9]/g, ''));
          if (!isNaN(parsedId) && parsedId !== gameId) {
            console.log('⚠️ 문자열 ID 파싱, 실제 게임 ID 사용:', parsedId);
            gameId = parsedId;
          }
        }
      }
      
      console.log('🔍 경기 삭제 시도:', { 
        originalId: id, 
        gameId, 
        tokenLength: token.length 
      });

      // 자동생성 게임인지 확인
      const gameToDelete = games.find(g => {
        if (g.id === id) return true;
        if (typeof g.id === 'number' && g.id === gameId) return true;
        if (typeof g.id === 'string') {
          const parsedGameId = parseInt(g.id.replace(/[^0-9]/g, ''));
          if (parsedGameId === gameId) return true;
        }
        return false;
      });

      // 모든 게임은 백엔드에서 삭제 (자동생성 게임도 포함)
      console.log('🗑️ 게임 백엔드에서 삭제:', { gameId, isAutoGenerated: gameToDelete?.autoGenerated });
      
      const response = await fetch(`http://localhost:4000/api/auth/games/${gameId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`경기 삭제 실패: ${response.status} - ${errorData.error || response.statusText}`);
      }
      
      await fetchGames();
      // 헤더 등 전역 갱신 유도
      window.dispatchEvent(new CustomEvent('gamesChanged'));
      
      // SchedulePageV2에 경기 데이터 변경 알림
      if (onGameDataChanged) {
        onGameDataChanged();
      }
      
      toast({
        title: '경기 삭제 완료',
        description: '경기가 삭제되었습니다.',
        status: 'success',
        duration: 2000,
        isClosable: true,
      });
    } catch (error) {
      console.error('경기 삭제 오류:', error);
      toast({
        title: '경기 삭제 실패',
        description: '경기 삭제 중 오류가 발생했습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };


  // 인원명 추가
  const addMemberName = () => {
    setFormData(prev => ({
      ...prev,
      memberNames: [...prev.memberNames, '']
    }));
  };

  // 인원명 제거
  const removeMemberName = (index: number) => {
    if (formData.memberNames.length > 1) {
      setFormData(prev => ({
        ...prev,
        memberNames: prev.memberNames.filter((_, i) => i !== index)
      }));
    }
  };

  // 인원명 변경
  const updateMemberName = (index: number, value: string) => {
    setFormData(prev => ({
      ...prev,
      memberNames: prev.memberNames.map((name, i) => i === index ? value : name)
    }));
  };

  // memberNames를 배열로 변환하는 함수
  const parseMemberNames = (memberNames: any): string[] => {
    // null, undefined 체크
    if (memberNames == null) {
      return [];
    }
    
    // 이미 배열인 경우
    if (Array.isArray(memberNames)) {
      return memberNames.filter(name => name && typeof name === 'string' && name.trim() !== '');
    }
    
    // 문자열인 경우 JSON 파싱 시도
    if (typeof memberNames === 'string') {
      try {
        const parsed = JSON.parse(memberNames);
        if (Array.isArray(parsed)) {
          return parsed.filter(name => name && typeof name === 'string' && name.trim() !== '');
        }
      } catch (error) {
        console.warn('parseMemberNames JSON 파싱 실패:', error);
      }
    }
    
    // 기본값으로 빈 배열 반환
    return [];
  };
  
  // 전체 인원 계산 - 선택된 회원, 용병, 수기입력 모두 계산
  const getTotalCount = () => {
    // 선택된 회원들 (실제 회원 목록과 매칭하여 중복 제거)
    const selectedCount = getUniqueMemberCount();
    
    // 용병 수
    const mercenaryCount = formData.mercenaryCount;
    
    // 수기입력된 회원들 (빈 문자열 제외)
    const manualCount = formData.memberNames.filter(name => 
      name.trim() !== ''
    ).length;
    
    return mercenaryCount + selectedCount + manualCount;
  };

  
  // formData 변경 시 실시간으로 인원수 업데이트
  React.useEffect(() => {
    // 인원수 변경 감지 (의존성 배열에 formData 추가)
  }, [formData.mercenaryCount, formData.memberNames]);

  // 카카오맵 장소 검색
  const searchLocation = async (query: string) => {
    if (!query.trim()) return;
    
    setIsSearching(true);
    try {
      const response = await fetch(`http://localhost:4000/api/auth/search-location?query=${encodeURIComponent(query)}`);
      if (response.ok) {
        const data = await response.json();
        setSearchResults(data.documents || []);
        setShowSearchResults(true);
      } else {
        toast({
          title: '검색 실패',
          description: '장소 검색에 실패했습니다.',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('장소 검색 오류:', error);
      toast({
        title: '검색 오류',
        description: '장소 검색 중 오류가 발생했습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    } finally {
      setIsSearching(false);
    }
  };

  // 장소 선택
  const selectLocation = (place: any) => {
    setFormData(prev => ({
      ...prev,
      location: place.place_name
    }));
    setSearchQuery(place.place_name);
    setShowSearchResults(false);
  };

  const handleSubmit = async () => {
    if (!formData.date || !formData.location) {
      toast({
        title: '입력 오류',
        description: '날짜와 장소를 모두 입력해주세요.',
        status: 'error',
        duration: 2000,
        isClosable: true,
      });
      return;
    }

    // 중복 일정 체크 (자동생성된 경기는 제외)
    const selectedDate = new Date(formData.date);
    const existingGameOnDate = games.find(game => {
      const gameDate = new Date(game.date);
      return gameDate.toDateString() === selectedDate.toDateString() && 
             (!editingGame || game.id !== editingGame.id) &&
             !game.autoGenerated; // 자동생성된 경기는 중복 체크에서 제외
    });

    if (existingGameOnDate) {
      toast({
        title: '중복 일정',
        description: '해당 날짜에 이미 경기가 있습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    try {
      if (editingGame) {
        // 자동생성된 경기를 수정하는 경우 - 일정확정 기능 수행
        if (editingGame.autoGenerated === true) {
          console.log('🎯 자동생성 경기 수정 - 일정확정 기능 수행');
          
          // 통일 유틸로 토큰 확보
          const token = await getValidToken();

          // 필수 정보 확인
          if (!formData.time || !formData.location || !formData.eventType) {
            toast({
              title: '정보 부족',
              description: '시간, 장소, 이벤트 유형을 모두 입력해주세요.',
              status: 'warning',
              duration: 3000,
              isClosable: true,
            });
            return;
          }

          console.log('🎯 자동생성 경기 일정확정 시도:', { 
            gameId: editingGame.id, 
            hasToken: !!token
          });

          // 자동생성 게임을 백엔드에 새로 생성 (일정확정)
          const newGameData = {
            date: selectedDate.toISOString(),
            time: formData.time,
            location: formData.location,
            eventType: formData.eventType || '자체',
            gameType: (formData.eventType === '매치') ? 'MATCH' : 'SELF',
            memberNames: formData.memberNames.filter(name => name.trim() !== ''),
            selectedMembers: selectedMembers,
            mercenaryCount: formData.mercenaryCount || 0,
          };

          console.log('🎯 자동생성 경기 일정확정 데이터:', {
            gameId: editingGame.id,
            formData: newGameData
          });

          // ID 형식 정리 - 최종 강력한 파싱
          let gameId: number;
          
          console.log('🔍 원본 ID 분석:', { 
            originalId: editingGame.id, 
            type: typeof editingGame.id,
            stringValue: editingGame.id.toString()
          });
          
          if (typeof editingGame.id === 'number') {
            gameId = editingGame.id;
          } else {
            // 문자열인 경우 :1, :0 등 모든 접미사 제거 후 숫자만 추출
            let cleanIdStr = editingGame.id.toString();
            
            // :1, :0 등 콜론 접미사 제거
            if (cleanIdStr.includes(':')) {
              cleanIdStr = cleanIdStr.split(':')[0];
            }
            
            // 모든 비숫자 문자 제거
            cleanIdStr = cleanIdStr.replace(/[^0-9]/g, '');
            
            gameId = parseInt(cleanIdStr);
            
            console.log('🔧 ID 파싱 과정:', {
              original: editingGame.id,
              afterColonRemoval: cleanIdStr,
              finalGameId: gameId
            });
          }
          
          // 유효한 ID인지 확인 (1-99999999 범위로 확장)
          if (isNaN(gameId) || gameId <= 0 || gameId > 99999999) {
            console.error('❌ 유효하지 않은 게임 ID:', { 
              originalId: editingGame.id, 
              type: typeof editingGame.id,
              gameId 
            });
            throw new Error(`유효하지 않은 게임 ID: ${editingGame.id}`);
          }
          
          console.log('✅ 최종 파싱된 게임 ID:', { originalId: editingGame.id, gameId });
          
          // 실제 게임 객체에서 ID 재확인
          const actualGame = games.find(g => g.id === editingGame.id);
          if (actualGame) {
            console.log('🔍 실제 게임 객체 ID:', actualGame.id);
            // 실제 게임 객체의 ID가 다르면 그것을 사용
            if (typeof actualGame.id === 'number' && actualGame.id !== gameId) {
              console.log('⚠️ ID 불일치 감지, 실제 게임 ID 사용:', actualGame.id);
              gameId = actualGame.id;
            }
          }
          
          console.log('🚀 자동생성 게임 백엔드 생성 API 호출');
          const response = await fetch('http://localhost:4000/api/auth/games', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(newGameData)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('자동생성 경기 일정확정 실패 응답:', {
              status: response.status,
              statusText: response.statusText,
              errorData
            });
            throw new Error(`일정확정 실패: ${response.status} - ${errorData.details || response.statusText}`);
          }

                const result = await response.json();
                console.log('자동생성 경기 일정확정 성공:', result);
                
                // 같은 주의 다른 자동생성 게임들 삭제는 아래에서 처리
                
                // 🔄 이벤트 시스템으로 다른 페이지에 동기화 알림
                emitGameConfirmed({
                  gameId: gameId,
                  gameData: result,
                  confirmedBy: '관리자'
                });
                emitDataRefreshNeeded('games');
                emitAlert(`경기 일정이 확정되었습니다! 회원들에게 알림이 발송되었습니다.`, 'success');
                
                // 📱 푸시 알림 표시
                try {
                  await showGameConfirmationNotification({
                    gameDate: result.date || formData.date,
                    gameTime: result.time || formData.time || '미정',
                    gameLocation: result.location || formData.location || '미정',
                    gameType: result.gameType || formData.gameType || '미정'
                  });
                } catch (notificationError) {
                  console.warn('푸시 알림 표시 실패:', notificationError);
                }
                
                // 자동생성 일정 확정 후 즉시 UI 업데이트
                console.log('🎯 자동생성 일정 확정 완료 - 백엔드에서 최신 데이터 가져오기');
                
                // 백엔드에서 최신 데이터를 가져와서 UI 업데이트
                await fetchGames();
                console.log('✅ 백엔드에서 최신 데이터 가져오기 완료');
                window.dispatchEvent(new CustomEvent('gamesChanged'));
          
          // SchedulePageV2에 경기 데이터 변경 알림
          if (onGameDataChanged) {
            onGameDataChanged();
          }
          
          // 모달 닫기
          onClose();
          
          // 성공 메시지
          toast({
            title: '🎯 경기 일정 확정 완료!',
            description: '회원들에게 알림이 발송되었습니다.',
            status: 'success',
            duration: 5000,
            isClosable: true,
          });
          
          return; // 자동생성 경기 처리 완료
        }
        
        // 일반 경기 수정
        // 경기 수정 - 백엔드 API 호출
        const updatedFormData = {
          ...formData,
          // eventType이 null이거나 빈 값이면 기본값 설정
          eventType: formData.eventType || '자체',
          // selectedMembers는 별도로 저장하고, memberNames는 수기 입력만 포함
          memberNames: formData.memberNames.filter(name => name.trim() !== ''),
          selectedMembers: selectedMembers, // 선택된 회원을 별도 필드로 저장
          mercenaryCount: formData.mercenaryCount || 0,
          // 백엔드가 기대하는 gameType 보정
          gameType: (formData.eventType === '매치') ? 'MATCH' : 'SELF'
        };
        
        // 통일 유틸로 토큰 확보
        const token = await getValidToken();

        if (!token) {
          toast({
            title: '인증 오류',
            description: '로그인이 필요합니다.',
            status: 'error',
            duration: 3000,
            isClosable: true,
          });
          return;
        }

        console.log('🔍 경기 수정 시도:', { 
          gameId: editingGame.id, 
          tokenLength: token.length,
          hasToken: !!token
        });

        // ID 형식 정리 - 최종 강력한 파싱
        let gameId: number;
        
        console.log('🔍 수정 원본 ID 분석:', { 
          originalId: editingGame.id, 
          type: typeof editingGame.id,
          stringValue: editingGame.id.toString()
        });
        
        if (typeof editingGame.id === 'number') {
          gameId = editingGame.id;
        } else {
          // 문자열인 경우 :1, :0 등 모든 접미사 제거 후 숫자만 추출
          let cleanIdStr = editingGame.id.toString();
          
          // :1, :0 등 콜론 접미사 제거
          if (cleanIdStr.includes(':')) {
            cleanIdStr = cleanIdStr.split(':')[0];
          }
          
          // 모든 비숫자 문자 제거
          cleanIdStr = cleanIdStr.replace(/[^0-9]/g, '');
          
          gameId = parseInt(cleanIdStr);
          
          console.log('🔧 수정 ID 파싱 과정:', {
            original: editingGame.id,
            afterColonRemoval: cleanIdStr,
            finalGameId: gameId
          });
        }
        
        // 유효한 ID인지 확인 (1-99999999 범위로 확장)
        if (isNaN(gameId) || gameId <= 0 || gameId > 99999999) {
          console.error('❌ 유효하지 않은 게임 ID:', { 
            originalId: editingGame.id, 
            type: typeof editingGame.id,
            gameId 
          });
          throw new Error(`유효하지 않은 게임 ID: ${editingGame.id}`);
        }
        
        console.log('✅ 최종 파싱된 수정 게임 ID:', { originalId: editingGame.id, gameId });
        
        // 실제 게임 객체에서 ID 재확인
        const actualGame = games.find(g => g.id === editingGame.id);
        if (actualGame) {
          console.log('🔍 실제 게임 객체 ID:', actualGame.id);
          // 실제 게임 객체의 ID가 다르면 그것을 사용
          if (typeof actualGame.id === 'number' && actualGame.id !== gameId) {
            console.log('⚠️ ID 불일치 감지, 실제 게임 ID 사용:', actualGame.id);
            gameId = actualGame.id;
          }
        }
        
        // DB에 존재하지 않는 임시 id면 생성(POST), 정수형 id면 수정(PUT)
        const gameIdStr = gameId.toString();
        const isPersistedId = typeof gameId === 'number' 
          && Number.isSafeInteger(gameId)
          && gameId > 0 
          && gameId < 1000000000 // 비정상적으로 큰 임시 ID(타임스탬프형) 방지
          && !gameIdStr.includes('.') // 소수점이 포함된 타임스탬프 ID 제외
          && gameIdStr.length < 10; // 타임스탬프는 보통 13자리 이상
        const requestUrl = isPersistedId
          ? `http://localhost:4000/api/auth/games/${gameId}`
          : `http://localhost:4000/api/auth/games`;
        const requestMethod = isPersistedId ? 'PUT' : 'POST';

        console.log('🔍 API 요청 정보:', {
          url: requestUrl,
          method: requestMethod,
          tokenLength: token.length,
          hasToken: !!token
        });

        const response = await fetch(requestUrl, {
          method: requestMethod,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            ...updatedFormData
          })
        });

        console.log('🔍 API 응답 상태:', response.status, response.statusText);

        if (!response.ok) {
          throw new Error('경기 수정 실패');
        }

        const result = await response.json();
        console.log('경기 수정 성공:', result);
        
        // 자동생성 일정이 삭제되었는지 확인
        if (result.autoGeneratedGamesDeleted) {
          console.log('🎯 자동생성 일정이 삭제됨 - UI 새로고침 필요');
          // 페이지 전체 새로고침을 통해 모든 데이터 동기화
          setTimeout(() => {
            window.location.reload();
          }, 1000);
        } else {
          // 일반적인 경우에는 fetchGames 호출
          await fetchGames();
        }
        window.dispatchEvent(new CustomEvent('gamesChanged'));
        
        // SchedulePageV2에 경기 데이터 변경 알림
        if (onGameDataChanged) {
          onGameDataChanged();
        }
        
        // 자동생성된 게임이 확정된 경우 특별한 메시지 표시
        const isAutoGeneratedConfirmed = editingGame.autoGenerated && 
          formData.time && formData.location && formData.eventType &&
          formData.time !== '미정' && formData.location !== '미정';
        
        if (isAutoGeneratedConfirmed) {
          toast({
            title: '🎯 경기 일정 확정 완료!',
            description: '회원들에게 알림이 발송되었습니다. 같은 주의 다른 자동생성된 일정들은 삭제되었습니다.',
            status: 'success',
            duration: 5000,
            isClosable: true,
          });
        } else {
          toast({
            title: '경기 수정 완료',
            description: '경기 정보가 수정되었습니다.',
            status: 'success',
            duration: 2000,
            isClosable: true,
          });
        }
      } else {
        // 새 경기 추가 - 백엔드 API 호출
        const newFormData = {
          ...formData,
          // eventType이 null이거나 빈 값이면 기본값 설정
          eventType: formData.eventType || '자체',
          // selectedMembers는 별도로 저장하고, memberNames는 수기 입력만 포함
          memberNames: formData.memberNames.filter(name => name.trim() !== ''),
          selectedMembers: selectedMembers, // 선택된 회원을 별도 필드로 저장
          createdById: 1,
          gameType: (formData.eventType === '매치') ? 'MATCH' : 'SELF'
        };
        
        // 토큰 가져오기 (여러 위치에서 시도)
        const token = await getValidToken();
        
        if (!token) {
          toast({
            title: '인증 오류',
            description: '로그인이 필요합니다.',
            status: 'error',
            duration: 3000,
            isClosable: true,
          });
          return;
        }

        console.log('🔍 경기 추가 시도:', { tokenLength: token.length });

        const response = await fetch('http://localhost:4000/api/auth/games', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(newFormData)
        });

        if (!response.ok) {
          throw new Error('경기 추가 실패');
        }
        
        const result = await response.json();
        console.log('경기 추가 성공:', result);
        
        // 자동생성 일정이 삭제되었는지 확인
        if (result.autoGeneratedGamesDeleted) {
          console.log('🎯 자동생성 일정이 삭제됨 - UI 새로고침 필요');
          // 페이지 전체 새로고침을 통해 모든 데이터 동기화
          setTimeout(() => {
            window.location.reload();
          }, 1000);
        }
        
        await fetchGames();
        window.dispatchEvent(new CustomEvent('gamesChanged'));
        
        // SchedulePageV2에 경기 데이터 변경 알림
        if (onGameDataChanged) {
          onGameDataChanged();
        }
        
        toast({
          title: '경기 추가 완료',
          description: '새 경기가 추가되었습니다.',
          status: 'success',
          duration: 2000,
          isClosable: true,
        });
      }

      onClose();
    } catch (error) {
      console.error('경기 저장 오류:', error);
      const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다.';
      toast({
        title: '저장 실패',
        description: `경기 정보 저장 중 오류가 발생했습니다: ${errorMessage}`,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  };

  const getEventTypeName = (type: string) => {
    switch (type) {
      case '자체': return '자체';
      case '매치': return '매치';
      case '회식': return '회식';
      default: return '자체';
    }
  };

  return (
    <>
      <VStack spacing={6} align="stretch">
        <HStack justify="space-between">
          <VStack align="start" spacing={2}>
            <HStack spacing={3}>
          <Text fontSize="2xl">⚽</Text>
          <Text fontSize="2xl" fontWeight="bold">경기 관리</Text>
        </HStack>
            <Text>경기 일정을 관리할 수 있습니다.</Text>
          </VStack>
          <Button 
            colorScheme="blue" 
            bg="#004ea8"
            _hover={{ bg: "#003d7a" }}
            leftIcon={<AddIcon />}
            onClick={handleAddGame}
            size="sm"
          >
            추가
          </Button>
        </HStack>
        
        <Box
          bg="white"
          border="1px"
          borderColor="gray.200"
          borderRadius="lg"
          overflow="hidden"
        >
                    {(() => {
            console.log('=== GameManagement - 렌더링 조건 체크 ===');
            console.log('games:', games);
            console.log('games?.length:', games?.length);
            console.log('games?.length === 0:', games?.length === 0);
            return games?.length === 0 ? (
              <Box p={6} textAlign="center">
                <Alert status="info">
                  <AlertIcon />
                  등록된 경기가 없습니다.
                </Alert>
              </Box>
            ) : (
              <Table variant="simple">
                <Thead bg="gray.50">
                  <Tr>
                    <Th textAlign="center">날짜</Th>
                    <Th textAlign="center">장소</Th>
                    <Th textAlign="center">이벤트 유형</Th>
                    <Th textAlign="center">전체 인원</Th>
                    <Th textAlign="center">생성자</Th>
                    <Th textAlign="center">작업</Th>
                  </Tr>
                </Thead>
                <Tbody>
                  {filteredGames.map((game) => (
                    <Tr key={game.id} bg={game.autoGenerated ? "blue.50" : "white"}>
                      <Td textAlign="center">
                        <VStack spacing={1} align="center">
                          <Text fontWeight="medium">
                            {(() => {
                              const date = new Date(game.date);
                              const year = date.getFullYear();
                              const month = String(date.getMonth() + 1).padStart(2, '0');
                              const day = String(date.getDate()).padStart(2, '0');
                              const weekdays = ['일', '월', '화', '수', '목', '금', '토'];
                              const weekday = weekdays[date.getDay()];
                              
                              // 자동생성된 게임은 시간을 "미정"으로 표시
                              if (game.autoGenerated) {
                                return `${year}.${month}.${day}.(${weekday}) 미정`;
                              } else if (game.time) {
                                return `${year}.${month}.${day}.(${weekday}) ${game.time}`;
                              } else {
                                return `${year}.${month}.${day}.(${weekday})`;
                              }
                            })()}
                          </Text>
                          {game.autoGenerated && (
                            <Badge colorScheme="blue" variant="outline" size="sm">
                              자동생성
                            </Badge>
                          )}
                        </VStack>
                      </Td>
                      <Td textAlign="center">
                        <Text fontSize="sm" color="gray.600">
                          {game.autoGenerated ? '미정' : game.location}
                        </Text>
                      </Td>
                      <Td textAlign="center">
                        <Badge 
                          colorScheme={
                            game.autoGenerated ? 'gray' :
                            game.eventType === '매치' ? 'blue' : 
                            game.eventType === '회식' ? 'orange' : 
                            'purple'
                          }
                          variant="subtle"
                        >
                          {game.autoGenerated ? '미정' : getEventTypeName(game.eventType || '자체')}
                        </Badge>
                      </Td>
                      <Td textAlign="center">
                        <Badge colorScheme="blackAlpha" variant="subtle">
                          {game.totalParticipantCount || 0}명
                        </Badge>
                      </Td>
                      <Td textAlign="center">
                        <Text fontSize="sm" color="gray.600">
                          {game.createdBy?.name 
                            || (userList.find((u: any) => u.id === game.createdById)?.name) 
                            || '알 수 없음'}
                        </Text>
                      </Td>
                      <Td textAlign="center">
                        <HStack spacing={2} justify="center">
                          <Tooltip 
                            label={game.autoGenerated ? "일정확정" : "경기 수정"} 
                            placement="top" 
                            hasArrow
                            bg={game.autoGenerated ? "green.600" : "blue.600"}
                            color="white"
                            fontSize="sm"
                          >
                            <IconButton
                              aria-label={game.autoGenerated ? "일정확정" : "경기 수정"}
                              icon={<EditIcon />}
                              size="sm"
                              variant="ghost"
                              colorScheme={game.autoGenerated ? "green" : "blue"}
                              onClick={() => handleEditGame(game)}
                            />
                          </Tooltip>
                          <Tooltip 
                            label="경기 삭제" 
                            placement="top" 
                            hasArrow
                            bg="red.600"
                            color="white"
                            fontSize="sm"
                          >
                            <IconButton
                              aria-label="경기 삭제"
                              icon={<DeleteIcon />}
                              size="sm"
                              variant="ghost"
                              colorScheme="red"
                              onClick={() => handleDeleteGame(game.id)}
                            />
                          </Tooltip>
                        </HStack>
                      </Td>
                    </Tr>
                  ))}
                </Tbody>
              </Table>
            );
          })()}
        </Box>
      </VStack>

      {/* 경기 추가/수정 모달 */}
      <Modal isOpen={isOpen} onClose={onClose}>
        <ModalOverlay />
        <ModalContent maxW="500px">
          <ModalHeader py={4}>
            {editingGame ? (editingGame.autoGenerated ? '⚽ 일정확정' : '⚽ 경기 수정') : '⚽ 경기 추가'}
          </ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={4}>
            <VStack spacing={3}>
              {/* 날짜와 이벤트 유형을 같은 행에 배치하되 y축 위치는 장소, 인원관리와 맞춤 */}
              <FormControl>
                                        <FormLabel>📅 일시 & 이벤트</FormLabel>
                                  <HStack spacing={4} align="start">
                    <Input
                      type="date"
                      value={formData.date}
                      onChange={(e) => setFormData({ ...formData, date: e.target.value })}
                      size="md"
                      h="40px"
                      flex={1}
                    />
                    <Select
                      value={formData.time || ''}
                      onChange={(e) => setFormData({ ...formData, time: e.target.value })}
                      placeholder="시간 선택"
                      size="md"
                      h="40px"
                      flex={1}
                    >
                      <option value="18:00">오후 6:00</option>
                      <option value="18:30">오후 6:30</option>
                      <option value="19:00">오후 7:00</option>
                      <option value="19:30">오후 7:30</option>
                      <option value="20:00">오후 8:00</option>
                      <option value="20:30">오후 8:30</option>
                    </Select>
                    <Select
                      value={formData.eventType}
                      onChange={(e) => setFormData({ ...formData, eventType: e.target.value as '매치' | '회식' | '자체' })}
                      size="md"
                      h="40px"
                      flex={1}
                    >
                      <option value="자체">자체</option>
                      <option value="매치">매치</option>
                      <option value="회식">회식</option>
                    </Select>
                  </HStack>
              </FormControl>
              
              <FormControl>
                <FormLabel>📍 장소</FormLabel>
                <VStack spacing={2} align="stretch">
                  <HStack>
                    <Input
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      placeholder="장소명을 검색하세요"
                      onKeyPress={(e) => e.key === 'Enter' && searchLocation(searchQuery)}
                    />
                    <Button
                      onClick={() => searchLocation(searchQuery)}
                      isLoading={isSearching}
                      colorScheme="blue"
                      size="sm"
                    >
                      검색
                    </Button>
                  </HStack>
                  
                  {/* 검색 결과 */}
                  {showSearchResults && searchResults.length > 0 && (
                    <Box
                      border="1px solid"
                      borderColor="gray.200"
                      borderRadius="md"
                      maxH="200px"
                      overflowY="auto"
                      bg="white"
                      zIndex={10}
                    >
                      {searchResults.map((place, index) => (
                        <Box
                          key={index}
                          p={3}
                          borderBottom="1px solid"
                          borderColor="gray.100"
                          cursor="pointer"
                          _hover={{ bg: "gray.50" }}
                          onClick={() => selectLocation(place)}
                        >
                          <Text fontWeight="bold">{place.place_name}</Text>
                          <Text fontSize="sm" color="gray.600">{place.address_name}</Text>
                        </Box>
                      ))}
                    </Box>
                  )}
                  
                  <Input
                    value={formData.location}
                    onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                    placeholder="선택된 장소 또는 직접 입력"
                  />
                </VStack>
              </FormControl>
              

              

              
                            {/* 인원 관리 - 좌우 병기 */}
              <FormControl>
                <HStack justify="space-between" align="center" mb={2}>
                  <FormLabel mb={0}>👥 인원 관리</FormLabel>
                  <Box ml={4}>
                    <Text fontSize="sm" fontWeight="bold" color="blue.600">
                      전체 인원: {getTotalCount()}명 (회원 {getUniqueMemberCount()}명 + 용병 {formData.mercenaryCount}명 + 수기입력 {formData.memberNames.filter(name => name.trim() !== '').length}명)
                    </Text>
                  </Box>
                </HStack>
                <HStack spacing={4} align="start">
                  {/* 왼쪽: 회원 선택 */}
                  <Box flex={1}>
                    <Text fontSize="sm" color="gray.600" mb={2} fontWeight="bold">회원 선택</Text>
                    <Box>
                      {userList.map((user, index) => (
                        <Button
                          key={user.id}
                          size="sm"
                          variant={selectedMembers.includes(user.name) ? "solid" : "outline"}
                          colorScheme={selectedMembers.includes(user.name) ? "blue" : "gray"}
                          onClick={() => {
                            if (selectedMembers.includes(user.name)) {
                              // 이미 선택된 경우 제거
                              setSelectedMembers(prev => prev.filter(name => name !== user.name));
                            } else {
                              // 선택되지 않은 경우 추가 (수기입력칸에는 추가하지 않음)
                              setSelectedMembers(prev => [...prev, user.name]);
                            }
                          }}
                          mr={2}
                          mb={index % 4 === 3 ? 2 : 0}
                        >
                          {user.name}
                        </Button>
                      ))}
                    </Box>

                  </Box>
                  
                  {/* 오른쪽: 용병 및 수기 입력을 1행 2열로 재분할 */}
                  <Box flex={1}>
                    <Text fontSize="sm" color="gray.600" mb={2} fontWeight="bold">용병 & 수기 입력</Text>
                    <HStack spacing={4} align="start">
                      {/* 용병 입력 부분 */}
                      <Box flex={1}>
                        <Text fontSize="xs" color="gray.500" mb={1}>용병 인원</Text>
                        <Input
                          type="number"
                          value={formData.mercenaryCount}
                          onChange={(e) => setFormData({ ...formData, mercenaryCount: parseInt(e.target.value) || 0 })}
                          placeholder="0"
                          min="0"
                          size="sm"
                        />
                      </Box>
                      
                      {/* 수기 입력 부분 */}
                      <Box flex={1}>
                        <Text fontSize="xs" color="gray.500" mb={1}>수기 입력</Text>
                        {formData.memberNames.map((name, index) => (
                          <HStack key={index} mb={1}>
                            <Input
                              value={name}
                              onChange={(e) => updateMemberName(index, e.target.value)}
                              placeholder={`팀원 ${index + 1} 이름`}
                              size="sm"
                            />
                            {formData.memberNames.length > 1 && (
                              <Button
                                size="sm"
                                colorScheme="red"
                                variant="ghost"
                                onClick={() => removeMemberName(index)}
                              >
                                삭제
                              </Button>
                            )}
                          </HStack>
                        ))}
                        <Button
                          size="sm"
                          colorScheme="blue"
                          variant="outline"
                          onClick={addMemberName}
                          leftIcon={<AddIcon />}
                          w="100%"
                        >
                          팀원 추가
                        </Button>
                      </Box>
                    </HStack>
                  </Box>
                </HStack>
              </FormControl>
              

              
              {/* 자동생성된 경기가 아닌 경우에만 수정/추가 버튼 표시 */}
              {!(editingGame && editingGame.autoGenerated === true) && (
                <HStack spacing={3} w="100%">
                  <Button 
                    colorScheme="blue" 
                    onClick={handleSubmit} 
                    flex={1}
                  >
                    {editingGame ? '수정' : '추가'}
                  </Button>
                  <Button onClick={onClose} flex={1}>
                    취소
                  </Button>
                </HStack>
              )}

              {/* 자동생성된 경기일 때만 표시되는 일정확정 섹션 */}
              {editingGame && editingGame.autoGenerated === true && (
                <Box 
                  mt={4} 
                  p={4} 
                  bg="green.50" 
                  borderRadius="md" 
                  border="1px" 
                  borderColor="green.200"
                >
                  <Text fontSize="md" fontWeight="bold" color="green.700" mb={2}>
                    이 게임을 최종 확정하시겠습니까?
                  </Text>
                  <Text fontSize="sm" color="green.600" mb={3}>
                    확정 시 회원들에게 알림이 발송되고, 같은 주의 다른 자동생성된 일정들은 삭제됩니다.
                  </Text>
                  <HStack spacing={3} w="100%">
                    <Button 
                      colorScheme="green" 
                      size="lg" 
                      flex={1}
                      leftIcon={<CalendarIcon />}
                      onClick={handleSubmit}
                    >
                      일정확정
                    </Button>
                    <Button onClick={onClose} flex={1}>
                      취소
                    </Button>
                  </HStack>
                </Box>
              )}
            </VStack>
          </ModalBody>
        </ModalContent>
      </Modal>
    </>
  );
}
