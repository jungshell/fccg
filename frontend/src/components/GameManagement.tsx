import React, { useState } from 'react';
import {
  Box,
  Button,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  Badge,
  IconButton,
  HStack,
  VStack,
  Text,
  Alert,
  AlertIcon,
  useDisclosure,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  FormControl,
  FormLabel,
  Input,
  Select,
  useToast,
  Tooltip
} from '@chakra-ui/react';
import { AddIcon, EditIcon, DeleteIcon, CalendarIcon } from '@chakra-ui/icons';
import { getValidToken } from '../api/auth';
import { emitGameConfirmed, emitDataRefreshNeeded, emitAlert } from '../utils/eventBus';
import { showGameConfirmationNotification } from '../utils/pushNotifications';

interface Game {
  id: number;
  date: string;
  time?: string;
  location: string;
  eventType?: 'ë§¤ì¹˜' | 'íšŒì‹' | 'ìì²´';
  mercenaryCount: number;
  memberNames: string[];
  selectedMembers?: string[];
  createdById: number;
  createdAt: string;
  updatedAt: string;
  createdBy?: {
    id: number;
    name: string;
  };
  attendances?: any[];
  autoGenerated?: boolean; // ìë™ ìƒì„±ëœ ê²½ê¸°ì„ì„ í‘œì‹œí•˜ëŠ” í•„ë“œ
}

interface GameManagementProps {
  games: Game[];
  onGamesChange: (games: Game[]) => void;
  userList: any[]; // íšŒì› ëª©ë¡ ì¶”ê°€
  onGameDataChanged?: () => void; // ê²½ê¸° ë°ì´í„° ë³€ê²½ ì‹œ í˜¸ì¶œí•  ì½œë°±
}

export default function GameManagement({ games, onGamesChange, userList, onGameDataChanged }: GameManagementProps) {
  console.log('=== GameManagement ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ ===');
  console.log('GameManagement - ë°›ì€ games prop:', games);
  console.log('GameManagement - games ê¸¸ì´:', games?.length);
  console.log('GameManagement - games íƒ€ì…:', typeof games);
  console.log('GameManagement - gamesê°€ ë°°ì—´ì¸ê°€:', Array.isArray(games));
  console.log('GameManagement - games ë‚´ìš©:', JSON.stringify(games, null, 2));

  // ì¤‘ë³µ ì œê±°: ê°™ì€ ë‚ ì§œì— í™•ì •ì¼ì •ì´ ìˆìœ¼ë©´ ìë™ìƒì„±ì¼ì • ì œê±°
  const filteredGames = React.useMemo(() => {
    if (!games || !Array.isArray(games)) return [];
    
    console.log('ğŸ” GameManagement í•„í„°ë§ ì‹œì‘:', {
      totalGames: games.length,
      games: games.map(game => ({
        id: game.id,
        date: game.date,
        autoGenerated: game.autoGenerated,
        confirmed: game.confirmed
      }))
    });
    
    const confirmedGames = games.filter(game => !game.autoGenerated);
    const autoGeneratedGames = games.filter(game => game.autoGenerated);
    
    console.log('ğŸ” ê²Œì„ ë¶„ë¥˜:', {
      confirmed: confirmedGames.length,
      autoGenerated: autoGeneratedGames.length,
      confirmedGames: confirmedGames.map(g => ({ id: g.id, date: g.date })),
      autoGeneratedGames: autoGeneratedGames.map(g => ({ id: g.id, date: g.date }))
    });
    
    // í™•ì •ì¼ì •ì´ ìˆëŠ” ë‚ ì§œë“¤ ì¶”ì¶œ
    const confirmedDates = new Set(
      confirmedGames.map(game => {
        if (!game.date || typeof game.date !== 'string') return null;
        const dateMatch = game.date.match(/(\d{4})\.(\d{2})\.(\d{2})/);
        return dateMatch ? `${dateMatch[1]}.${dateMatch[2]}.${dateMatch[3]}` : null;
      }).filter(Boolean)
    );
    
    console.log('ğŸ” í™•ì •ì¼ì • ë‚ ì§œë“¤:', Array.from(confirmedDates));
    
    // ìë™ìƒì„±ì¼ì • í•„í„°ë§ ì„ì‹œ ë¹„í™œì„±í™” (ë””ë²„ê¹…ìš©)
    const filteredAutoGenerated = autoGeneratedGames;
    
    console.log('âš ï¸ ìë™ìƒì„±ì¼ì • í•„í„°ë§ ë¹„í™œì„±í™”ë¨ - ëª¨ë“  ìë™ìƒì„±ì¼ì • í‘œì‹œ');
    
    /*
    // ìë™ìƒì„±ì¼ì • ì¤‘ì—ì„œ í™•ì •ì¼ì •ì´ ìˆëŠ” ë‚ ì§œëŠ” ì œì™¸
    const filteredAutoGenerated = autoGeneratedGames.filter(game => {
      if (!game.date || typeof game.date !== 'string') return false;
      const dateMatch = game.date.match(/(\d{4})\.(\d{2})\.(\d{2})/);
      const gameDate = dateMatch ? `${dateMatch[1]}.${dateMatch[2]}.${dateMatch[3]}` : null;
      const shouldInclude = gameDate && !confirmedDates.has(gameDate);
      
      console.log('ğŸ” ìë™ìƒì„±ì¼ì • í•„í„°ë§:', {
        gameId: game.id,
        gameDate: game.date,
        extractedDate: gameDate,
        shouldInclude,
        reason: shouldInclude ? 'í¬í•¨' : 'ì œì™¸ (í™•ì •ì¼ì •ê³¼ ì¤‘ë³µ)'
      });
      
      return shouldInclude;
    });
    */
    
    const result = [...confirmedGames, ...filteredAutoGenerated];
    console.log('ğŸ” ìµœì¢… í•„í„°ë§ ê²°ê³¼:', {
      original: games.length,
      confirmed: confirmedGames.length,
      autoGenerated: autoGeneratedGames.length,
      filteredAutoGenerated: filteredAutoGenerated.length,
      final: result.length,
      finalGames: result.map(g => ({ id: g.id, date: g.date, autoGenerated: g.autoGenerated }))
    });
    
    return result;
  }, [games]);
  const { isOpen, onOpen, onClose } = useDisclosure();
  const [editingGame, setEditingGame] = useState<Game | null>(null);
  const [formData, setFormData] = useState({
    date: '',
    time: '',
    location: '',
    eventType: 'ìì²´' as 'ë§¤ì¹˜' | 'íšŒì‹' | 'ìì²´',
    mercenaryCount: 0,
    memberNames: ['']
  });
  
  // ì„ íƒëœ íšŒì›ë“¤ì„ ë³„ë„ë¡œ ê´€ë¦¬
  const [selectedMembers, setSelectedMembers] = useState<string[]>([]);
  
  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ê²½ê¸° ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (AdminPageNewì—ì„œ ì´ë¯¸ ë¡œë“œë¨)
  // React.useEffect(() => {
  //   fetchGames();
  // }, []);

  // íˆ¬í‘œì¬ê°œ ì‹œ ìë™ìƒì„± ì¼ì • ì œê±°
  React.useEffect(() => {
    const handleVoteSessionResumed = () => {
      console.log('ğŸ”„ íˆ¬í‘œì¬ê°œ ì´ë²¤íŠ¸ ìˆ˜ì‹  - ìë™ìƒì„± ì¼ì • ì œê±°');
      const updatedGames = games.filter(game => !game.autoGenerated);
      onGamesChange(updatedGames);
      console.log('âœ… ìë™ìƒì„± ì¼ì • ì œê±° ì™„ë£Œ:', updatedGames.length, 'ê°œ ë‚¨ìŒ');
    };

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    window.addEventListener('voteSessionResumed', handleVoteSessionResumed);
    
    // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œì—ë„ ìë™ìƒì„± ì¼ì • ì²´í¬
    const autoGeneratedGames = games.filter(game => game.autoGenerated);
    if (autoGeneratedGames.length > 0) {
      console.log('ğŸ” ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ìë™ìƒì„± ì¼ì • ë°œê²¬:', autoGeneratedGames.length, 'ê°œ');
      // íˆ¬í‘œ ì„¸ì…˜ì´ í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´ ìë™ìƒì„± ì¼ì • ì œê±°
      const hasActiveVoteSession = window.location.href.includes('vote-results') || 
                                   document.querySelector('[data-vote-active="true"]');
      if (hasActiveVoteSession) {
        console.log('ğŸ”„ í™œì„± íˆ¬í‘œ ì„¸ì…˜ ê°ì§€ - ìë™ìƒì„± ì¼ì • ì œê±°');
        const updatedGames = games.filter(game => !game.autoGenerated);
        onGamesChange(updatedGames);
      }
    }
    
    return () => {
      window.removeEventListener('voteSessionResumed', handleVoteSessionResumed);
    };
  }, [games, onGamesChange]);
  
  // ê²½ê¸° ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
  const fetchGames = async () => {
    try {
      const token = await getValidToken();
      const response = await fetch('http://localhost:4000/api/auth/members', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      if (response.ok) {
        const unifiedData = await response.json();
        const gamesData = unifiedData.games || [];
        
        // ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ì˜ ê²½ê¸° ë°ì´í„° ì‚¬ìš©
        if (gamesData && gamesData.length > 0) {
          console.log('ğŸ”„ ì‹¤ì œ ê²½ê¸° ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', gamesData.length, 'ê°œ');
          
          // ìë™ ìƒì„±ëœ ê²½ê¸°ì¸ì§€ í™•ì¸ (ë°±ì—”ë“œì—ì„œ ë°›ì€ autoGenerated ê°’ ì‚¬ìš©)
          const processedGames = gamesData.map((game: any) => ({
            ...game,
            autoGenerated: game.autoGenerated === true, // ë°±ì—”ë“œì—ì„œ ë°›ì€ autoGenerated ê°’ì„ ëª…ì‹œì ìœ¼ë¡œ booleanìœ¼ë¡œ ë³€í™˜
            time: game.time || '', // ì‹œê°„ì´ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´
            location: game.location || 'ì¥ì†Œ ë¯¸ì •', // ì¥ì†Œê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’
            eventType: game.eventType || 'ìì²´' // ì´ë²¤íŠ¸ ìœ í˜•ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’
          }));
          
          onGamesChange(processedGames);
          console.log('âœ… ê²½ê¸° ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ');
        } else {
          console.log('ğŸ“ ë“±ë¡ëœ ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤');
          onGamesChange([]);
        }
      }
    } catch (error) {
      console.error('ê²½ê¸° ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
      onGamesChange([]);
    }
  };

  // ì‹¤ì œ íšŒì› ê¸°ì¤€ìœ¼ë¡œ íšŒì› ìˆ˜ ê³„ì‚° (ì¤‘ë³µ ì œê±° ë° ìœ íš¨ì„± ê²€ì‚¬)
  const getUniqueMemberCount = React.useCallback(() => {
    const actualMemberNames = (userList || []).map((m: any) => m.name);
    const filtered = (selectedMembers || []).filter((name: string) => actualMemberNames.includes(name));
    const unique = Array.from(new Set(filtered));
    return unique.length;
  }, [selectedMembers, userList]);
  
  // ì¹´ì¹´ì˜¤ë§µ ê²€ìƒ‰ ê´€ë ¨ ìƒíƒœ
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [showSearchResults, setShowSearchResults] = useState(false);
  
  const toast = useToast();

  const handleAddGame = () => {
    setEditingGame(null);
    setSelectedMembers([]); // ì„ íƒëœ íšŒì› ì´ˆê¸°í™”
    setFormData({
      date: '',
      time: '',
      location: '',
      eventType: 'ìì²´',
      mercenaryCount: 0,
      memberNames: ['']
    });
    onOpen();
  };

  const handleEditGame = (game: Game) => {
    console.log('ğŸ¯ handleEditGame í˜¸ì¶œ (v2):', game);
    console.log('ğŸ¯ game.autoGenerated:', game.autoGenerated);
    
    // autoGenerated ì†ì„±ì„ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •
    const gameWithAutoGenerated = {
      ...game,
      autoGenerated: game.autoGenerated === true // ëª…ì‹œì ìœ¼ë¡œ booleanìœ¼ë¡œ ë³€í™˜
    };
    
    setEditingGame(gameWithAutoGenerated);
    console.log('ğŸ¯ setEditingGame ì™„ë£Œ (v2):', gameWithAutoGenerated);
    console.log('ğŸ¯ autoGenerated í™•ì¸:', gameWithAutoGenerated.autoGenerated);
    
    // ë‚ ì§œë¥¼ YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ ë³€í™˜
    const gameDate = new Date(game.date);
    const formattedDate = gameDate.toISOString().split('T')[0];
    
    // ê¸°ì¡´ selectedMembersì™€ memberNamesë¥¼ ë¶„ë¦¬í•˜ì—¬ ë¡œë“œ
    const existingSelectedMembers = parseMemberNames(game.selectedMembers || []);
    const allMemberNames = parseMemberNames(game.memberNames);
    
    // selectedMembersì— ì—†ëŠ” ê²ƒë“¤ë§Œ ìˆ˜ê¸°ì…ë ¥ìœ¼ë¡œ ë¶„ë¦¬
    const existingManualMembers = allMemberNames.filter(name => 
      !existingSelectedMembers.includes(name) && 
      !name.startsWith('ìš©ë³‘') // ìš©ë³‘ë„ ì œì™¸
    );
    
    setSelectedMembers(existingSelectedMembers);
    
    setFormData({
      date: formattedDate,
      time: (game.autoGenerated && game.time === 'ë¯¸ì •') ? '' : (game.time || ''), // ìë™ìƒì„±ëœ ê²Œì„ì˜ "ë¯¸ì •" ì‹œê°„ì€ ë¹ˆ ë¬¸ìì—´ë¡œ ì²˜ë¦¬
      location: (game.autoGenerated && game.location === 'ë¯¸ì •') ? '' : game.location, // ìë™ìƒì„±ëœ ê²Œì„ì˜ "ë¯¸ì •" ì¥ì†ŒëŠ” ë¹ˆ ë¬¸ìì—´ë¡œ ì²˜ë¦¬
      eventType: (game.autoGenerated && (game as any).eventType === 'ë¯¸ì •') ? 'ìì²´' : (game.eventType || 'ìì²´'), // íƒ€ì… ê°€ë“œ
      mercenaryCount: game.mercenaryCount || 0,
      memberNames: existingManualMembers.length > 0 ? existingManualMembers : ['']
    });
    onOpen();
  };

  const handleDeleteGame = async (id: number | string) => {
    try {
      // í†µì¼ ìœ í‹¸ë¡œ í† í° í™•ë³´
      const token = await getValidToken();

      // ID í˜•ì‹ ì •ë¦¬ - ìµœì¢… ê°•ë ¥í•œ íŒŒì‹±
      let gameId: number;
      
      console.log('ğŸ” ì‚­ì œ ì›ë³¸ ID ë¶„ì„:', { 
        originalId: id, 
        type: typeof id,
        stringValue: id.toString()
      });
      
      if (typeof id === 'number') {
        gameId = id;
      } else {
        // ë¬¸ìì—´ì¸ ê²½ìš° :1, :0 ë“± ëª¨ë“  ì ‘ë¯¸ì‚¬ ì œê±° í›„ ìˆ«ìë§Œ ì¶”ì¶œ
        let cleanIdStr = id.toString();
        
        // :1, :0 ë“± ì½œë¡  ì ‘ë¯¸ì‚¬ ì œê±°
        if (cleanIdStr.includes(':')) {
          cleanIdStr = cleanIdStr.split(':')[0];
        }
        
        // ëª¨ë“  ë¹„ìˆ«ì ë¬¸ì ì œê±°
        cleanIdStr = cleanIdStr.replace(/[^0-9]/g, '');
        
        gameId = parseInt(cleanIdStr);
        
        console.log('ğŸ”§ ì‚­ì œ ID íŒŒì‹± ê³¼ì •:', {
          original: id,
          afterColonRemoval: cleanIdStr,
          finalGameId: gameId
        });
      }
      
      // ìœ íš¨í•œ IDì¸ì§€ í™•ì¸ (1-99999999 ë²”ìœ„ë¡œ í™•ì¥)
      if (isNaN(gameId) || gameId <= 0 || gameId > 99999999) {
        console.error('âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ê²Œì„ ID:', { 
          originalId: id, 
          type: typeof id,
          gameId 
        });
        throw new Error(`ìœ íš¨í•˜ì§€ ì•Šì€ ê²Œì„ ID: ${id}`);
      }
      
      console.log('âœ… ìµœì¢… íŒŒì‹±ëœ ì‚­ì œ ê²Œì„ ID:', { originalId: id, gameId });
      
      // ì‹¤ì œ ê²Œì„ ê°ì²´ì—ì„œ ID ì¬í™•ì¸
      const actualGame = games.find(g => {
        // ì›ë³¸ IDì™€ ë¹„êµ
        if (g.id === id) return true;
        // íŒŒì‹±ëœ IDì™€ ë¹„êµ
        if (typeof g.id === 'number' && g.id === gameId) return true;
        // ë¬¸ìì—´ IDì¸ ê²½ìš° íŒŒì‹±í•´ì„œ ë¹„êµ
        if (typeof g.id === 'string') {
          const parsedGameId = parseInt(g.id.replace(/[^0-9]/g, ''));
          if (parsedGameId === gameId) return true;
        }
        return false;
      });
      
      if (actualGame) {
        console.log('ğŸ” ì‹¤ì œ ê²Œì„ ê°ì²´ ID:', actualGame.id);
        // ì‹¤ì œ ê²Œì„ ê°ì²´ì˜ IDê°€ ìˆ«ìì´ê³  ë‹¤ë¥´ë©´ ê·¸ê²ƒì„ ì‚¬ìš©
        if (typeof actualGame.id === 'number' && actualGame.id !== gameId) {
          console.log('âš ï¸ ID ë¶ˆì¼ì¹˜ ê°ì§€, ì‹¤ì œ ê²Œì„ ID ì‚¬ìš©:', actualGame.id);
          gameId = actualGame.id;
        } else if (typeof actualGame.id === 'string') {
          // ë¬¸ìì—´ IDì¸ ê²½ìš° íŒŒì‹±í•´ì„œ ì‚¬ìš©
          const parsedId = parseInt(actualGame.id.replace(/[^0-9]/g, ''));
          if (!isNaN(parsedId) && parsedId !== gameId) {
            console.log('âš ï¸ ë¬¸ìì—´ ID íŒŒì‹±, ì‹¤ì œ ê²Œì„ ID ì‚¬ìš©:', parsedId);
            gameId = parsedId;
          }
        }
      }
      
      console.log('ğŸ” ê²½ê¸° ì‚­ì œ ì‹œë„:', { 
        originalId: id, 
        gameId, 
        tokenLength: token.length 
      });

      // ìë™ìƒì„± ê²Œì„ì¸ì§€ í™•ì¸
      const gameToDelete = games.find(g => {
        if (g.id === id) return true;
        if (typeof g.id === 'number' && g.id === gameId) return true;
        if (typeof g.id === 'string') {
          const parsedGameId = parseInt(g.id.replace(/[^0-9]/g, ''));
          if (parsedGameId === gameId) return true;
        }
        return false;
      });

      // ëª¨ë“  ê²Œì„ì€ ë°±ì—”ë“œì—ì„œ ì‚­ì œ (ìë™ìƒì„± ê²Œì„ë„ í¬í•¨)
      console.log('ğŸ—‘ï¸ ê²Œì„ ë°±ì—”ë“œì—ì„œ ì‚­ì œ:', { gameId, isAutoGenerated: gameToDelete?.autoGenerated });
      
      const response = await fetch(`http://localhost:4000/api/auth/games/${gameId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`ê²½ê¸° ì‚­ì œ ì‹¤íŒ¨: ${response.status} - ${errorData.error || response.statusText}`);
      }
      
      await fetchGames();
      // í—¤ë” ë“± ì „ì—­ ê°±ì‹  ìœ ë„
      window.dispatchEvent(new CustomEvent('gamesChanged'));
      
      // SchedulePageV2ì— ê²½ê¸° ë°ì´í„° ë³€ê²½ ì•Œë¦¼
      if (onGameDataChanged) {
        onGameDataChanged();
      }
      
      toast({
        title: 'ê²½ê¸° ì‚­ì œ ì™„ë£Œ',
        description: 'ê²½ê¸°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.',
        status: 'success',
        duration: 2000,
        isClosable: true,
      });
    } catch (error) {
      console.error('ê²½ê¸° ì‚­ì œ ì˜¤ë¥˜:', error);
      toast({
        title: 'ê²½ê¸° ì‚­ì œ ì‹¤íŒ¨',
        description: 'ê²½ê¸° ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };


  // ì¸ì›ëª… ì¶”ê°€
  const addMemberName = () => {
    setFormData(prev => ({
      ...prev,
      memberNames: [...prev.memberNames, '']
    }));
  };

  // ì¸ì›ëª… ì œê±°
  const removeMemberName = (index: number) => {
    if (formData.memberNames.length > 1) {
      setFormData(prev => ({
        ...prev,
        memberNames: prev.memberNames.filter((_, i) => i !== index)
      }));
    }
  };

  // ì¸ì›ëª… ë³€ê²½
  const updateMemberName = (index: number, value: string) => {
    setFormData(prev => ({
      ...prev,
      memberNames: prev.memberNames.map((name, i) => i === index ? value : name)
    }));
  };

  // memberNamesë¥¼ ë°°ì—´ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
  const parseMemberNames = (memberNames: any): string[] => {
    // null, undefined ì²´í¬
    if (memberNames == null) {
      return [];
    }
    
    // ì´ë¯¸ ë°°ì—´ì¸ ê²½ìš°
    if (Array.isArray(memberNames)) {
      return memberNames.filter(name => name && typeof name === 'string' && name.trim() !== '');
    }
    
    // ë¬¸ìì—´ì¸ ê²½ìš° JSON íŒŒì‹± ì‹œë„
    if (typeof memberNames === 'string') {
      try {
        const parsed = JSON.parse(memberNames);
        if (Array.isArray(parsed)) {
          return parsed.filter(name => name && typeof name === 'string' && name.trim() !== '');
        }
      } catch (error) {
        console.warn('parseMemberNames JSON íŒŒì‹± ì‹¤íŒ¨:', error);
      }
    }
    
    // ê¸°ë³¸ê°’ìœ¼ë¡œ ë¹ˆ ë°°ì—´ ë°˜í™˜
    return [];
  };
  
  // ì „ì²´ ì¸ì› ê³„ì‚° - ì„ íƒëœ íšŒì›, ìš©ë³‘, ìˆ˜ê¸°ì…ë ¥ ëª¨ë‘ ê³„ì‚°
  const getTotalCount = () => {
    // ì„ íƒëœ íšŒì›ë“¤ (ì‹¤ì œ íšŒì› ëª©ë¡ê³¼ ë§¤ì¹­í•˜ì—¬ ì¤‘ë³µ ì œê±°)
    const selectedCount = getUniqueMemberCount();
    
    // ìš©ë³‘ ìˆ˜
    const mercenaryCount = formData.mercenaryCount;
    
    // ìˆ˜ê¸°ì…ë ¥ëœ íšŒì›ë“¤ (ë¹ˆ ë¬¸ìì—´ ì œì™¸)
    const manualCount = formData.memberNames.filter(name => 
      name.trim() !== ''
    ).length;
    
    return mercenaryCount + selectedCount + manualCount;
  };

  
  // formData ë³€ê²½ ì‹œ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¸ì›ìˆ˜ ì—…ë°ì´íŠ¸
  React.useEffect(() => {
    // ì¸ì›ìˆ˜ ë³€ê²½ ê°ì§€ (ì˜ì¡´ì„± ë°°ì—´ì— formData ì¶”ê°€)
  }, [formData.mercenaryCount, formData.memberNames]);

  // ì¹´ì¹´ì˜¤ë§µ ì¥ì†Œ ê²€ìƒ‰
  const searchLocation = async (query: string) => {
    if (!query.trim()) return;
    
    setIsSearching(true);
    try {
      const response = await fetch(`http://localhost:4000/api/auth/search-location?query=${encodeURIComponent(query)}`);
      if (response.ok) {
        const data = await response.json();
        setSearchResults(data.documents || []);
        setShowSearchResults(true);
      } else {
        toast({
          title: 'ê²€ìƒ‰ ì‹¤íŒ¨',
          description: 'ì¥ì†Œ ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('ì¥ì†Œ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
      toast({
        title: 'ê²€ìƒ‰ ì˜¤ë¥˜',
        description: 'ì¥ì†Œ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    } finally {
      setIsSearching(false);
    }
  };

  // ì¥ì†Œ ì„ íƒ
  const selectLocation = (place: any) => {
    setFormData(prev => ({
      ...prev,
      location: place.place_name
    }));
    setSearchQuery(place.place_name);
    setShowSearchResults(false);
  };

  const handleSubmit = async () => {
    if (!formData.date || !formData.location) {
      toast({
        title: 'ì…ë ¥ ì˜¤ë¥˜',
        description: 'ë‚ ì§œì™€ ì¥ì†Œë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.',
        status: 'error',
        duration: 2000,
        isClosable: true,
      });
      return;
    }

    // ì¤‘ë³µ ì¼ì • ì²´í¬ (ìë™ìƒì„±ëœ ê²½ê¸°ëŠ” ì œì™¸)
    const selectedDate = new Date(formData.date);
    const existingGameOnDate = games.find(game => {
      const gameDate = new Date(game.date);
      return gameDate.toDateString() === selectedDate.toDateString() && 
             (!editingGame || game.id !== editingGame.id) &&
             !game.autoGenerated; // ìë™ìƒì„±ëœ ê²½ê¸°ëŠ” ì¤‘ë³µ ì²´í¬ì—ì„œ ì œì™¸
    });

    if (existingGameOnDate) {
      toast({
        title: 'ì¤‘ë³µ ì¼ì •',
        description: 'í•´ë‹¹ ë‚ ì§œì— ì´ë¯¸ ê²½ê¸°ê°€ ìˆìŠµë‹ˆë‹¤.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    try {
      if (editingGame) {
        // ìë™ìƒì„±ëœ ê²½ê¸°ë¥¼ ìˆ˜ì •í•˜ëŠ” ê²½ìš° - ì¼ì •í™•ì • ê¸°ëŠ¥ ìˆ˜í–‰
        if (editingGame.autoGenerated === true) {
          console.log('ğŸ¯ ìë™ìƒì„± ê²½ê¸° ìˆ˜ì • - ì¼ì •í™•ì • ê¸°ëŠ¥ ìˆ˜í–‰');
          
          // í†µì¼ ìœ í‹¸ë¡œ í† í° í™•ë³´
          const token = await getValidToken();

          // í•„ìˆ˜ ì •ë³´ í™•ì¸
          if (!formData.time || !formData.location || !formData.eventType) {
            toast({
              title: 'ì •ë³´ ë¶€ì¡±',
              description: 'ì‹œê°„, ì¥ì†Œ, ì´ë²¤íŠ¸ ìœ í˜•ì„ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.',
              status: 'warning',
              duration: 3000,
              isClosable: true,
            });
            return;
          }

          console.log('ğŸ¯ ìë™ìƒì„± ê²½ê¸° ì¼ì •í™•ì • ì‹œë„:', { 
            gameId: editingGame.id, 
            hasToken: !!token
          });

          // ìë™ìƒì„± ê²Œì„ì„ ë°±ì—”ë“œì— ìƒˆë¡œ ìƒì„± (ì¼ì •í™•ì •)
          const newGameData = {
            date: selectedDate.toISOString(),
            time: formData.time,
            location: formData.location,
            eventType: formData.eventType || 'ìì²´',
            gameType: (formData.eventType === 'ë§¤ì¹˜') ? 'MATCH' : 'SELF',
            memberNames: formData.memberNames.filter(name => name.trim() !== ''),
            selectedMembers: selectedMembers,
            mercenaryCount: formData.mercenaryCount || 0,
          };

          console.log('ğŸ¯ ìë™ìƒì„± ê²½ê¸° ì¼ì •í™•ì • ë°ì´í„°:', {
            gameId: editingGame.id,
            formData: newGameData
          });

          // ID í˜•ì‹ ì •ë¦¬ - ìµœì¢… ê°•ë ¥í•œ íŒŒì‹±
          let gameId: number;
          
          console.log('ğŸ” ì›ë³¸ ID ë¶„ì„:', { 
            originalId: editingGame.id, 
            type: typeof editingGame.id,
            stringValue: editingGame.id.toString()
          });
          
          if (typeof editingGame.id === 'number') {
            gameId = editingGame.id;
          } else {
            // ë¬¸ìì—´ì¸ ê²½ìš° :1, :0 ë“± ëª¨ë“  ì ‘ë¯¸ì‚¬ ì œê±° í›„ ìˆ«ìë§Œ ì¶”ì¶œ
            let cleanIdStr = editingGame.id.toString();
            
            // :1, :0 ë“± ì½œë¡  ì ‘ë¯¸ì‚¬ ì œê±°
            if (cleanIdStr.includes(':')) {
              cleanIdStr = cleanIdStr.split(':')[0];
            }
            
            // ëª¨ë“  ë¹„ìˆ«ì ë¬¸ì ì œê±°
            cleanIdStr = cleanIdStr.replace(/[^0-9]/g, '');
            
            gameId = parseInt(cleanIdStr);
            
            console.log('ğŸ”§ ID íŒŒì‹± ê³¼ì •:', {
              original: editingGame.id,
              afterColonRemoval: cleanIdStr,
              finalGameId: gameId
            });
          }
          
          // ìœ íš¨í•œ IDì¸ì§€ í™•ì¸ (1-99999999 ë²”ìœ„ë¡œ í™•ì¥)
          if (isNaN(gameId) || gameId <= 0 || gameId > 99999999) {
            console.error('âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ê²Œì„ ID:', { 
              originalId: editingGame.id, 
              type: typeof editingGame.id,
              gameId 
            });
            throw new Error(`ìœ íš¨í•˜ì§€ ì•Šì€ ê²Œì„ ID: ${editingGame.id}`);
          }
          
          console.log('âœ… ìµœì¢… íŒŒì‹±ëœ ê²Œì„ ID:', { originalId: editingGame.id, gameId });
          
          // ì‹¤ì œ ê²Œì„ ê°ì²´ì—ì„œ ID ì¬í™•ì¸
          const actualGame = games.find(g => g.id === editingGame.id);
          if (actualGame) {
            console.log('ğŸ” ì‹¤ì œ ê²Œì„ ê°ì²´ ID:', actualGame.id);
            // ì‹¤ì œ ê²Œì„ ê°ì²´ì˜ IDê°€ ë‹¤ë¥´ë©´ ê·¸ê²ƒì„ ì‚¬ìš©
            if (typeof actualGame.id === 'number' && actualGame.id !== gameId) {
              console.log('âš ï¸ ID ë¶ˆì¼ì¹˜ ê°ì§€, ì‹¤ì œ ê²Œì„ ID ì‚¬ìš©:', actualGame.id);
              gameId = actualGame.id;
            }
          }
          
          console.log('ğŸš€ ìë™ìƒì„± ê²Œì„ ë°±ì—”ë“œ ìƒì„± API í˜¸ì¶œ');
          const response = await fetch('http://localhost:4000/api/auth/games', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(newGameData)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('ìë™ìƒì„± ê²½ê¸° ì¼ì •í™•ì • ì‹¤íŒ¨ ì‘ë‹µ:', {
              status: response.status,
              statusText: response.statusText,
              errorData
            });
            throw new Error(`ì¼ì •í™•ì • ì‹¤íŒ¨: ${response.status} - ${errorData.details || response.statusText}`);
          }

                const result = await response.json();
                console.log('ìë™ìƒì„± ê²½ê¸° ì¼ì •í™•ì • ì„±ê³µ:', result);
                
                // ê°™ì€ ì£¼ì˜ ë‹¤ë¥¸ ìë™ìƒì„± ê²Œì„ë“¤ ì‚­ì œëŠ” ì•„ë˜ì—ì„œ ì²˜ë¦¬
                
                // ğŸ”„ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œìœ¼ë¡œ ë‹¤ë¥¸ í˜ì´ì§€ì— ë™ê¸°í™” ì•Œë¦¼
                emitGameConfirmed({
                  gameId: gameId,
                  gameData: result,
                  confirmedBy: 'ê´€ë¦¬ì'
                });
                emitDataRefreshNeeded('games');
                emitAlert(`ê²½ê¸° ì¼ì •ì´ í™•ì •ë˜ì—ˆìŠµë‹ˆë‹¤! íšŒì›ë“¤ì—ê²Œ ì•Œë¦¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
                
                // ğŸ“± í‘¸ì‹œ ì•Œë¦¼ í‘œì‹œ
                try {
                  await showGameConfirmationNotification({
                    gameDate: result.date || formData.date,
                    gameTime: result.time || formData.time || 'ë¯¸ì •',
                    gameLocation: result.location || formData.location || 'ë¯¸ì •',
                    gameType: result.gameType || formData.gameType || 'ë¯¸ì •'
                  });
                } catch (notificationError) {
                  console.warn('í‘¸ì‹œ ì•Œë¦¼ í‘œì‹œ ì‹¤íŒ¨:', notificationError);
                }
                
                // ìë™ìƒì„± ì¼ì • í™•ì • í›„ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸
                console.log('ğŸ¯ ìë™ìƒì„± ì¼ì • í™•ì • ì™„ë£Œ - ë°±ì—”ë“œì—ì„œ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°');
                
                // ë°±ì—”ë“œì—ì„œ ìµœì‹  ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ì„œ UI ì—…ë°ì´íŠ¸
                await fetchGames();
                console.log('âœ… ë°±ì—”ë“œì—ì„œ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ');
                window.dispatchEvent(new CustomEvent('gamesChanged'));
          
          // SchedulePageV2ì— ê²½ê¸° ë°ì´í„° ë³€ê²½ ì•Œë¦¼
          if (onGameDataChanged) {
            onGameDataChanged();
          }
          
          // ëª¨ë‹¬ ë‹«ê¸°
          onClose();
          
          // ì„±ê³µ ë©”ì‹œì§€
          toast({
            title: 'ğŸ¯ ê²½ê¸° ì¼ì • í™•ì • ì™„ë£Œ!',
            description: 'íšŒì›ë“¤ì—ê²Œ ì•Œë¦¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.',
            status: 'success',
            duration: 5000,
            isClosable: true,
          });
          
          return; // ìë™ìƒì„± ê²½ê¸° ì²˜ë¦¬ ì™„ë£Œ
        }
        
        // ì¼ë°˜ ê²½ê¸° ìˆ˜ì •
        // ê²½ê¸° ìˆ˜ì • - ë°±ì—”ë“œ API í˜¸ì¶œ
        const updatedFormData = {
          ...formData,
          // eventTypeì´ nullì´ê±°ë‚˜ ë¹ˆ ê°’ì´ë©´ ê¸°ë³¸ê°’ ì„¤ì •
          eventType: formData.eventType || 'ìì²´',
          // selectedMembersëŠ” ë³„ë„ë¡œ ì €ì¥í•˜ê³ , memberNamesëŠ” ìˆ˜ê¸° ì…ë ¥ë§Œ í¬í•¨
          memberNames: formData.memberNames.filter(name => name.trim() !== ''),
          selectedMembers: selectedMembers, // ì„ íƒëœ íšŒì›ì„ ë³„ë„ í•„ë“œë¡œ ì €ì¥
          mercenaryCount: formData.mercenaryCount || 0,
          // ë°±ì—”ë“œê°€ ê¸°ëŒ€í•˜ëŠ” gameType ë³´ì •
          gameType: (formData.eventType === 'ë§¤ì¹˜') ? 'MATCH' : 'SELF'
        };
        
        // í†µì¼ ìœ í‹¸ë¡œ í† í° í™•ë³´
        const token = await getValidToken();

        if (!token) {
          toast({
            title: 'ì¸ì¦ ì˜¤ë¥˜',
            description: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.',
            status: 'error',
            duration: 3000,
            isClosable: true,
          });
          return;
        }

        console.log('ğŸ” ê²½ê¸° ìˆ˜ì • ì‹œë„:', { 
          gameId: editingGame.id, 
          tokenLength: token.length,
          hasToken: !!token
        });

        // ID í˜•ì‹ ì •ë¦¬ - ìµœì¢… ê°•ë ¥í•œ íŒŒì‹±
        let gameId: number;
        
        console.log('ğŸ” ìˆ˜ì • ì›ë³¸ ID ë¶„ì„:', { 
          originalId: editingGame.id, 
          type: typeof editingGame.id,
          stringValue: editingGame.id.toString()
        });
        
        if (typeof editingGame.id === 'number') {
          gameId = editingGame.id;
        } else {
          // ë¬¸ìì—´ì¸ ê²½ìš° :1, :0 ë“± ëª¨ë“  ì ‘ë¯¸ì‚¬ ì œê±° í›„ ìˆ«ìë§Œ ì¶”ì¶œ
          let cleanIdStr = editingGame.id.toString();
          
          // :1, :0 ë“± ì½œë¡  ì ‘ë¯¸ì‚¬ ì œê±°
          if (cleanIdStr.includes(':')) {
            cleanIdStr = cleanIdStr.split(':')[0];
          }
          
          // ëª¨ë“  ë¹„ìˆ«ì ë¬¸ì ì œê±°
          cleanIdStr = cleanIdStr.replace(/[^0-9]/g, '');
          
          gameId = parseInt(cleanIdStr);
          
          console.log('ğŸ”§ ìˆ˜ì • ID íŒŒì‹± ê³¼ì •:', {
            original: editingGame.id,
            afterColonRemoval: cleanIdStr,
            finalGameId: gameId
          });
        }
        
        // ìœ íš¨í•œ IDì¸ì§€ í™•ì¸ (1-99999999 ë²”ìœ„ë¡œ í™•ì¥)
        if (isNaN(gameId) || gameId <= 0 || gameId > 99999999) {
          console.error('âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ê²Œì„ ID:', { 
            originalId: editingGame.id, 
            type: typeof editingGame.id,
            gameId 
          });
          throw new Error(`ìœ íš¨í•˜ì§€ ì•Šì€ ê²Œì„ ID: ${editingGame.id}`);
        }
        
        console.log('âœ… ìµœì¢… íŒŒì‹±ëœ ìˆ˜ì • ê²Œì„ ID:', { originalId: editingGame.id, gameId });
        
        // ì‹¤ì œ ê²Œì„ ê°ì²´ì—ì„œ ID ì¬í™•ì¸
        const actualGame = games.find(g => g.id === editingGame.id);
        if (actualGame) {
          console.log('ğŸ” ì‹¤ì œ ê²Œì„ ê°ì²´ ID:', actualGame.id);
          // ì‹¤ì œ ê²Œì„ ê°ì²´ì˜ IDê°€ ë‹¤ë¥´ë©´ ê·¸ê²ƒì„ ì‚¬ìš©
          if (typeof actualGame.id === 'number' && actualGame.id !== gameId) {
            console.log('âš ï¸ ID ë¶ˆì¼ì¹˜ ê°ì§€, ì‹¤ì œ ê²Œì„ ID ì‚¬ìš©:', actualGame.id);
            gameId = actualGame.id;
          }
        }
        
        // DBì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì„ì‹œ idë©´ ìƒì„±(POST), ì •ìˆ˜í˜• idë©´ ìˆ˜ì •(PUT)
        const gameIdStr = gameId.toString();
        const isPersistedId = typeof gameId === 'number' 
          && Number.isSafeInteger(gameId)
          && gameId > 0 
          && gameId < 1000000000 // ë¹„ì •ìƒì ìœ¼ë¡œ í° ì„ì‹œ ID(íƒ€ì„ìŠ¤íƒ¬í”„í˜•) ë°©ì§€
          && !gameIdStr.includes('.') // ì†Œìˆ˜ì ì´ í¬í•¨ëœ íƒ€ì„ìŠ¤íƒ¬í”„ ID ì œì™¸
          && gameIdStr.length < 10; // íƒ€ì„ìŠ¤íƒ¬í”„ëŠ” ë³´í†µ 13ìë¦¬ ì´ìƒ
        const requestUrl = isPersistedId
          ? `http://localhost:4000/api/auth/games/${gameId}`
          : `http://localhost:4000/api/auth/games`;
        const requestMethod = isPersistedId ? 'PUT' : 'POST';

        console.log('ğŸ” API ìš”ì²­ ì •ë³´:', {
          url: requestUrl,
          method: requestMethod,
          tokenLength: token.length,
          hasToken: !!token
        });

        const response = await fetch(requestUrl, {
          method: requestMethod,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            ...updatedFormData
          })
        });

        console.log('ğŸ” API ì‘ë‹µ ìƒíƒœ:', response.status, response.statusText);

        if (!response.ok) {
          throw new Error('ê²½ê¸° ìˆ˜ì • ì‹¤íŒ¨');
        }

        const result = await response.json();
        console.log('ê²½ê¸° ìˆ˜ì • ì„±ê³µ:', result);
        
        // ìë™ìƒì„± ì¼ì •ì´ ì‚­ì œë˜ì—ˆëŠ”ì§€ í™•ì¸
        if (result.autoGeneratedGamesDeleted) {
          console.log('ğŸ¯ ìë™ìƒì„± ì¼ì •ì´ ì‚­ì œë¨ - UI ìƒˆë¡œê³ ì¹¨ í•„ìš”');
          // í˜ì´ì§€ ì „ì²´ ìƒˆë¡œê³ ì¹¨ì„ í†µí•´ ëª¨ë“  ë°ì´í„° ë™ê¸°í™”
          setTimeout(() => {
            window.location.reload();
          }, 1000);
        } else {
          // ì¼ë°˜ì ì¸ ê²½ìš°ì—ëŠ” fetchGames í˜¸ì¶œ
          await fetchGames();
        }
        window.dispatchEvent(new CustomEvent('gamesChanged'));
        
        // SchedulePageV2ì— ê²½ê¸° ë°ì´í„° ë³€ê²½ ì•Œë¦¼
        if (onGameDataChanged) {
          onGameDataChanged();
        }
        
        // ìë™ìƒì„±ëœ ê²Œì„ì´ í™•ì •ëœ ê²½ìš° íŠ¹ë³„í•œ ë©”ì‹œì§€ í‘œì‹œ
        const isAutoGeneratedConfirmed = editingGame.autoGenerated && 
          formData.time && formData.location && formData.eventType &&
          formData.time !== 'ë¯¸ì •' && formData.location !== 'ë¯¸ì •';
        
        if (isAutoGeneratedConfirmed) {
          toast({
            title: 'ğŸ¯ ê²½ê¸° ì¼ì • í™•ì • ì™„ë£Œ!',
            description: 'íšŒì›ë“¤ì—ê²Œ ì•Œë¦¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤. ê°™ì€ ì£¼ì˜ ë‹¤ë¥¸ ìë™ìƒì„±ëœ ì¼ì •ë“¤ì€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.',
            status: 'success',
            duration: 5000,
            isClosable: true,
          });
        } else {
          toast({
            title: 'ê²½ê¸° ìˆ˜ì • ì™„ë£Œ',
            description: 'ê²½ê¸° ì •ë³´ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.',
            status: 'success',
            duration: 2000,
            isClosable: true,
          });
        }
      } else {
        // ìƒˆ ê²½ê¸° ì¶”ê°€ - ë°±ì—”ë“œ API í˜¸ì¶œ
        const newFormData = {
          ...formData,
          // eventTypeì´ nullì´ê±°ë‚˜ ë¹ˆ ê°’ì´ë©´ ê¸°ë³¸ê°’ ì„¤ì •
          eventType: formData.eventType || 'ìì²´',
          // selectedMembersëŠ” ë³„ë„ë¡œ ì €ì¥í•˜ê³ , memberNamesëŠ” ìˆ˜ê¸° ì…ë ¥ë§Œ í¬í•¨
          memberNames: formData.memberNames.filter(name => name.trim() !== ''),
          selectedMembers: selectedMembers, // ì„ íƒëœ íšŒì›ì„ ë³„ë„ í•„ë“œë¡œ ì €ì¥
          createdById: 1,
          gameType: (formData.eventType === 'ë§¤ì¹˜') ? 'MATCH' : 'SELF'
        };
        
        // í† í° ê°€ì ¸ì˜¤ê¸° (ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ ì‹œë„)
        const token = await getValidToken();
        
        if (!token) {
          toast({
            title: 'ì¸ì¦ ì˜¤ë¥˜',
            description: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.',
            status: 'error',
            duration: 3000,
            isClosable: true,
          });
          return;
        }

        console.log('ğŸ” ê²½ê¸° ì¶”ê°€ ì‹œë„:', { tokenLength: token.length });

        const response = await fetch('http://localhost:4000/api/auth/games', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(newFormData)
        });

        if (!response.ok) {
          throw new Error('ê²½ê¸° ì¶”ê°€ ì‹¤íŒ¨');
        }
        
        const result = await response.json();
        console.log('ê²½ê¸° ì¶”ê°€ ì„±ê³µ:', result);
        
        // ìë™ìƒì„± ì¼ì •ì´ ì‚­ì œë˜ì—ˆëŠ”ì§€ í™•ì¸
        if (result.autoGeneratedGamesDeleted) {
          console.log('ğŸ¯ ìë™ìƒì„± ì¼ì •ì´ ì‚­ì œë¨ - UI ìƒˆë¡œê³ ì¹¨ í•„ìš”');
          // í˜ì´ì§€ ì „ì²´ ìƒˆë¡œê³ ì¹¨ì„ í†µí•´ ëª¨ë“  ë°ì´í„° ë™ê¸°í™”
          setTimeout(() => {
            window.location.reload();
          }, 1000);
        }
        
        await fetchGames();
        window.dispatchEvent(new CustomEvent('gamesChanged'));
        
        // SchedulePageV2ì— ê²½ê¸° ë°ì´í„° ë³€ê²½ ì•Œë¦¼
        if (onGameDataChanged) {
          onGameDataChanged();
        }
        
        toast({
          title: 'ê²½ê¸° ì¶”ê°€ ì™„ë£Œ',
          description: 'ìƒˆ ê²½ê¸°ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.',
          status: 'success',
          duration: 2000,
          isClosable: true,
        });
      }

      onClose();
    } catch (error) {
      console.error('ê²½ê¸° ì €ì¥ ì˜¤ë¥˜:', error);
      const errorMessage = error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
      toast({
        title: 'ì €ì¥ ì‹¤íŒ¨',
        description: `ê²½ê¸° ì •ë³´ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${errorMessage}`,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  };

  const getEventTypeName = (type: string) => {
    switch (type) {
      case 'ìì²´': return 'ìì²´';
      case 'ë§¤ì¹˜': return 'ë§¤ì¹˜';
      case 'íšŒì‹': return 'íšŒì‹';
      default: return 'ìì²´';
    }
  };

  return (
    <>
      <VStack spacing={6} align="stretch">
        <HStack justify="space-between">
          <VStack align="start" spacing={2}>
            <HStack spacing={3}>
          <Text fontSize="2xl">âš½</Text>
          <Text fontSize="2xl" fontWeight="bold">ê²½ê¸° ê´€ë¦¬</Text>
        </HStack>
            <Text>ê²½ê¸° ì¼ì •ì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</Text>
          </VStack>
          <Button 
            colorScheme="blue" 
            bg="#004ea8"
            _hover={{ bg: "#003d7a" }}
            leftIcon={<AddIcon />}
            onClick={handleAddGame}
            size="sm"
          >
            ì¶”ê°€
          </Button>
        </HStack>
        
        <Box
          bg="white"
          border="1px"
          borderColor="gray.200"
          borderRadius="lg"
          overflow="hidden"
        >
                    {(() => {
            console.log('=== GameManagement - ë Œë”ë§ ì¡°ê±´ ì²´í¬ ===');
            console.log('games:', games);
            console.log('games?.length:', games?.length);
            console.log('games?.length === 0:', games?.length === 0);
            return games?.length === 0 ? (
              <Box p={6} textAlign="center">
                <Alert status="info">
                  <AlertIcon />
                  ë“±ë¡ëœ ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.
                </Alert>
              </Box>
            ) : (
              <Table variant="simple">
                <Thead bg="gray.50">
                  <Tr>
                    <Th textAlign="center">ë‚ ì§œ</Th>
                    <Th textAlign="center">ì¥ì†Œ</Th>
                    <Th textAlign="center">ì´ë²¤íŠ¸ ìœ í˜•</Th>
                    <Th textAlign="center">ì „ì²´ ì¸ì›</Th>
                    <Th textAlign="center">ìƒì„±ì</Th>
                    <Th textAlign="center">ì‘ì—…</Th>
                  </Tr>
                </Thead>
                <Tbody>
                  {filteredGames.map((game) => (
                    <Tr key={game.id} bg={game.autoGenerated ? "blue.50" : "white"}>
                      <Td textAlign="center">
                        <VStack spacing={1} align="center">
                          <Text fontWeight="medium">
                            {(() => {
                              const date = new Date(game.date);
                              const year = date.getFullYear();
                              const month = String(date.getMonth() + 1).padStart(2, '0');
                              const day = String(date.getDate()).padStart(2, '0');
                              const weekdays = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '];
                              const weekday = weekdays[date.getDay()];
                              
                              // ìë™ìƒì„±ëœ ê²Œì„ì€ ì‹œê°„ì„ "ë¯¸ì •"ìœ¼ë¡œ í‘œì‹œ
                              if (game.autoGenerated) {
                                return `${year}.${month}.${day}.(${weekday}) ë¯¸ì •`;
                              } else if (game.time) {
                                return `${year}.${month}.${day}.(${weekday}) ${game.time}`;
                              } else {
                                return `${year}.${month}.${day}.(${weekday})`;
                              }
                            })()}
                          </Text>
                          {game.autoGenerated && (
                            <Badge colorScheme="blue" variant="outline" size="sm">
                              ìë™ìƒì„±
                            </Badge>
                          )}
                        </VStack>
                      </Td>
                      <Td textAlign="center">
                        <Text fontSize="sm" color="gray.600">
                          {game.autoGenerated ? 'ë¯¸ì •' : game.location}
                        </Text>
                      </Td>
                      <Td textAlign="center">
                        <Badge 
                          colorScheme={
                            game.autoGenerated ? 'gray' :
                            game.eventType === 'ë§¤ì¹˜' ? 'blue' : 
                            game.eventType === 'íšŒì‹' ? 'orange' : 
                            'purple'
                          }
                          variant="subtle"
                        >
                          {game.autoGenerated ? 'ë¯¸ì •' : getEventTypeName(game.eventType || 'ìì²´')}
                        </Badge>
                      </Td>
                      <Td textAlign="center">
                        <Badge colorScheme="blackAlpha" variant="subtle">
                          {game.totalParticipantCount || 0}ëª…
                        </Badge>
                      </Td>
                      <Td textAlign="center">
                        <Text fontSize="sm" color="gray.600">
                          {game.createdBy?.name 
                            || (userList.find((u: any) => u.id === game.createdById)?.name) 
                            || 'ì•Œ ìˆ˜ ì—†ìŒ'}
                        </Text>
                      </Td>
                      <Td textAlign="center">
                        <HStack spacing={2} justify="center">
                          <Tooltip 
                            label={game.autoGenerated ? "ì¼ì •í™•ì •" : "ê²½ê¸° ìˆ˜ì •"} 
                            placement="top" 
                            hasArrow
                            bg={game.autoGenerated ? "green.600" : "blue.600"}
                            color="white"
                            fontSize="sm"
                          >
                            <IconButton
                              aria-label={game.autoGenerated ? "ì¼ì •í™•ì •" : "ê²½ê¸° ìˆ˜ì •"}
                              icon={<EditIcon />}
                              size="sm"
                              variant="ghost"
                              colorScheme={game.autoGenerated ? "green" : "blue"}
                              onClick={() => handleEditGame(game)}
                            />
                          </Tooltip>
                          <Tooltip 
                            label="ê²½ê¸° ì‚­ì œ" 
                            placement="top" 
                            hasArrow
                            bg="red.600"
                            color="white"
                            fontSize="sm"
                          >
                            <IconButton
                              aria-label="ê²½ê¸° ì‚­ì œ"
                              icon={<DeleteIcon />}
                              size="sm"
                              variant="ghost"
                              colorScheme="red"
                              onClick={() => handleDeleteGame(game.id)}
                            />
                          </Tooltip>
                        </HStack>
                      </Td>
                    </Tr>
                  ))}
                </Tbody>
              </Table>
            );
          })()}
        </Box>
      </VStack>

      {/* ê²½ê¸° ì¶”ê°€/ìˆ˜ì • ëª¨ë‹¬ */}
      <Modal isOpen={isOpen} onClose={onClose}>
        <ModalOverlay />
        <ModalContent maxW="500px">
          <ModalHeader py={4}>
            {editingGame ? (editingGame.autoGenerated ? 'âš½ ì¼ì •í™•ì •' : 'âš½ ê²½ê¸° ìˆ˜ì •') : 'âš½ ê²½ê¸° ì¶”ê°€'}
          </ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={4}>
            <VStack spacing={3}>
              {/* ë‚ ì§œì™€ ì´ë²¤íŠ¸ ìœ í˜•ì„ ê°™ì€ í–‰ì— ë°°ì¹˜í•˜ë˜ yì¶• ìœ„ì¹˜ëŠ” ì¥ì†Œ, ì¸ì›ê´€ë¦¬ì™€ ë§ì¶¤ */}
              <FormControl>
                                        <FormLabel>ğŸ“… ì¼ì‹œ & ì´ë²¤íŠ¸</FormLabel>
                                  <HStack spacing={4} align="start">
                    <Input
                      type="date"
                      value={formData.date}
                      onChange={(e) => setFormData({ ...formData, date: e.target.value })}
                      size="md"
                      h="40px"
                      flex={1}
                    />
                    <Select
                      value={formData.time || ''}
                      onChange={(e) => setFormData({ ...formData, time: e.target.value })}
                      placeholder="ì‹œê°„ ì„ íƒ"
                      size="md"
                      h="40px"
                      flex={1}
                    >
                      <option value="18:00">ì˜¤í›„ 6:00</option>
                      <option value="18:30">ì˜¤í›„ 6:30</option>
                      <option value="19:00">ì˜¤í›„ 7:00</option>
                      <option value="19:30">ì˜¤í›„ 7:30</option>
                      <option value="20:00">ì˜¤í›„ 8:00</option>
                      <option value="20:30">ì˜¤í›„ 8:30</option>
                    </Select>
                    <Select
                      value={formData.eventType}
                      onChange={(e) => setFormData({ ...formData, eventType: e.target.value as 'ë§¤ì¹˜' | 'íšŒì‹' | 'ìì²´' })}
                      size="md"
                      h="40px"
                      flex={1}
                    >
                      <option value="ìì²´">ìì²´</option>
                      <option value="ë§¤ì¹˜">ë§¤ì¹˜</option>
                      <option value="íšŒì‹">íšŒì‹</option>
                    </Select>
                  </HStack>
              </FormControl>
              
              <FormControl>
                <FormLabel>ğŸ“ ì¥ì†Œ</FormLabel>
                <VStack spacing={2} align="stretch">
                  <HStack>
                    <Input
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      placeholder="ì¥ì†Œëª…ì„ ê²€ìƒ‰í•˜ì„¸ìš”"
                      onKeyPress={(e) => e.key === 'Enter' && searchLocation(searchQuery)}
                    />
                    <Button
                      onClick={() => searchLocation(searchQuery)}
                      isLoading={isSearching}
                      colorScheme="blue"
                      size="sm"
                    >
                      ê²€ìƒ‰
                    </Button>
                  </HStack>
                  
                  {/* ê²€ìƒ‰ ê²°ê³¼ */}
                  {showSearchResults && searchResults.length > 0 && (
                    <Box
                      border="1px solid"
                      borderColor="gray.200"
                      borderRadius="md"
                      maxH="200px"
                      overflowY="auto"
                      bg="white"
                      zIndex={10}
                    >
                      {searchResults.map((place, index) => (
                        <Box
                          key={index}
                          p={3}
                          borderBottom="1px solid"
                          borderColor="gray.100"
                          cursor="pointer"
                          _hover={{ bg: "gray.50" }}
                          onClick={() => selectLocation(place)}
                        >
                          <Text fontWeight="bold">{place.place_name}</Text>
                          <Text fontSize="sm" color="gray.600">{place.address_name}</Text>
                        </Box>
                      ))}
                    </Box>
                  )}
                  
                  <Input
                    value={formData.location}
                    onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                    placeholder="ì„ íƒëœ ì¥ì†Œ ë˜ëŠ” ì§ì ‘ ì…ë ¥"
                  />
                </VStack>
              </FormControl>
              

              

              
                            {/* ì¸ì› ê´€ë¦¬ - ì¢Œìš° ë³‘ê¸° */}
              <FormControl>
                <HStack justify="space-between" align="center" mb={2}>
                  <FormLabel mb={0}>ğŸ‘¥ ì¸ì› ê´€ë¦¬</FormLabel>
                  <Box ml={4}>
                    <Text fontSize="sm" fontWeight="bold" color="blue.600">
                      ì „ì²´ ì¸ì›: {getTotalCount()}ëª… (íšŒì› {getUniqueMemberCount()}ëª… + ìš©ë³‘ {formData.mercenaryCount}ëª… + ìˆ˜ê¸°ì…ë ¥ {formData.memberNames.filter(name => name.trim() !== '').length}ëª…)
                    </Text>
                  </Box>
                </HStack>
                <HStack spacing={4} align="start">
                  {/* ì™¼ìª½: íšŒì› ì„ íƒ */}
                  <Box flex={1}>
                    <Text fontSize="sm" color="gray.600" mb={2} fontWeight="bold">íšŒì› ì„ íƒ</Text>
                    <Box>
                      {userList.map((user, index) => (
                        <Button
                          key={user.id}
                          size="sm"
                          variant={selectedMembers.includes(user.name) ? "solid" : "outline"}
                          colorScheme={selectedMembers.includes(user.name) ? "blue" : "gray"}
                          onClick={() => {
                            if (selectedMembers.includes(user.name)) {
                              // ì´ë¯¸ ì„ íƒëœ ê²½ìš° ì œê±°
                              setSelectedMembers(prev => prev.filter(name => name !== user.name));
                            } else {
                              // ì„ íƒë˜ì§€ ì•Šì€ ê²½ìš° ì¶”ê°€ (ìˆ˜ê¸°ì…ë ¥ì¹¸ì—ëŠ” ì¶”ê°€í•˜ì§€ ì•ŠìŒ)
                              setSelectedMembers(prev => [...prev, user.name]);
                            }
                          }}
                          mr={2}
                          mb={index % 4 === 3 ? 2 : 0}
                        >
                          {user.name}
                        </Button>
                      ))}
                    </Box>

                  </Box>
                  
                  {/* ì˜¤ë¥¸ìª½: ìš©ë³‘ ë° ìˆ˜ê¸° ì…ë ¥ì„ 1í–‰ 2ì—´ë¡œ ì¬ë¶„í•  */}
                  <Box flex={1}>
                    <Text fontSize="sm" color="gray.600" mb={2} fontWeight="bold">ìš©ë³‘ & ìˆ˜ê¸° ì…ë ¥</Text>
                    <HStack spacing={4} align="start">
                      {/* ìš©ë³‘ ì…ë ¥ ë¶€ë¶„ */}
                      <Box flex={1}>
                        <Text fontSize="xs" color="gray.500" mb={1}>ìš©ë³‘ ì¸ì›</Text>
                        <Input
                          type="number"
                          value={formData.mercenaryCount}
                          onChange={(e) => setFormData({ ...formData, mercenaryCount: parseInt(e.target.value) || 0 })}
                          placeholder="0"
                          min="0"
                          size="sm"
                        />
                      </Box>
                      
                      {/* ìˆ˜ê¸° ì…ë ¥ ë¶€ë¶„ */}
                      <Box flex={1}>
                        <Text fontSize="xs" color="gray.500" mb={1}>ìˆ˜ê¸° ì…ë ¥</Text>
                        {formData.memberNames.map((name, index) => (
                          <HStack key={index} mb={1}>
                            <Input
                              value={name}
                              onChange={(e) => updateMemberName(index, e.target.value)}
                              placeholder={`íŒ€ì› ${index + 1} ì´ë¦„`}
                              size="sm"
                            />
                            {formData.memberNames.length > 1 && (
                              <Button
                                size="sm"
                                colorScheme="red"
                                variant="ghost"
                                onClick={() => removeMemberName(index)}
                              >
                                ì‚­ì œ
                              </Button>
                            )}
                          </HStack>
                        ))}
                        <Button
                          size="sm"
                          colorScheme="blue"
                          variant="outline"
                          onClick={addMemberName}
                          leftIcon={<AddIcon />}
                          w="100%"
                        >
                          íŒ€ì› ì¶”ê°€
                        </Button>
                      </Box>
                    </HStack>
                  </Box>
                </HStack>
              </FormControl>
              

              
              {/* ìë™ìƒì„±ëœ ê²½ê¸°ê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ìˆ˜ì •/ì¶”ê°€ ë²„íŠ¼ í‘œì‹œ */}
              {!(editingGame && editingGame.autoGenerated === true) && (
                <HStack spacing={3} w="100%">
                  <Button 
                    colorScheme="blue" 
                    onClick={handleSubmit} 
                    flex={1}
                  >
                    {editingGame ? 'ìˆ˜ì •' : 'ì¶”ê°€'}
                  </Button>
                  <Button onClick={onClose} flex={1}>
                    ì·¨ì†Œ
                  </Button>
                </HStack>
              )}

              {/* ìë™ìƒì„±ëœ ê²½ê¸°ì¼ ë•Œë§Œ í‘œì‹œë˜ëŠ” ì¼ì •í™•ì • ì„¹ì…˜ */}
              {editingGame && editingGame.autoGenerated === true && (
                <Box 
                  mt={4} 
                  p={4} 
                  bg="green.50" 
                  borderRadius="md" 
                  border="1px" 
                  borderColor="green.200"
                >
                  <Text fontSize="md" fontWeight="bold" color="green.700" mb={2}>
                    ì´ ê²Œì„ì„ ìµœì¢… í™•ì •í•˜ì‹œê² ìŠµë‹ˆê¹Œ?
                  </Text>
                  <Text fontSize="sm" color="green.600" mb={3}>
                    í™•ì • ì‹œ íšŒì›ë“¤ì—ê²Œ ì•Œë¦¼ì´ ë°œì†¡ë˜ê³ , ê°™ì€ ì£¼ì˜ ë‹¤ë¥¸ ìë™ìƒì„±ëœ ì¼ì •ë“¤ì€ ì‚­ì œë©ë‹ˆë‹¤.
                  </Text>
                  <HStack spacing={3} w="100%">
                    <Button 
                      colorScheme="green" 
                      size="lg" 
                      flex={1}
                      leftIcon={<CalendarIcon />}
                      onClick={handleSubmit}
                    >
                      ì¼ì •í™•ì •
                    </Button>
                    <Button onClick={onClose} flex={1}>
                      ì·¨ì†Œ
                    </Button>
                  </HStack>
                </Box>
              )}
            </VStack>
          </ModalBody>
        </ModalContent>
      </Modal>
    </>
  );
}
