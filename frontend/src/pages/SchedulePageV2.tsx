import { useState, useEffect, useCallback, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  VStack,
  HStack,
  Text,
  Button,
  useToast,
  Flex,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  Badge,
  Tooltip,
  Input,
  IconButton,
  Skeleton,
  Spinner,
  Icon,
  FormControl,
  FormLabel,
  Textarea,
} from '@chakra-ui/react';
import NewCalendarV2 from '../components/NewCalendarV2';
import { ArrowUpIcon } from '@chakra-ui/icons';
import { useAuthStore } from '../store/auth';
import { WarningIcon } from '@chakra-ui/icons';
import { getUnifiedVoteDataNew } from '../api/auth';
import { eventBus, EVENT_TYPES } from '../utils/eventBus';
import { API_ENDPOINTS } from '../constants';
import { EditIcon, DeleteIcon } from '@chakra-ui/icons';
import { CalendarSkeleton, VoteSectionSkeleton } from '../components/common/SkeletonLoader';

// 타입 정의
interface VoteData {
  date: string;
  count: number;
  max: boolean;
  dayName: string;
  voteDate: Date;
}

interface VoteResults {
  voteSession: {
    id: number;
    weekStartDate: string;
    startTime: string;
    endTime: string;
    isActive: boolean;
    isCompleted: boolean;
    createdAt: string;
    updatedAt: string;
    votes: Array<{
      id: number;
      userId: number;
      selectedDays: string[];
      createdAt: string;
    }>;
  };
  voteResults: Record<string, number>;
}

interface GameData {
  id: string;
  eventType: string;
  count: number;
  time: string;
  location: string;
  confirmed: boolean;
  date?: string;
  memberNames?: string[] | string;
  selectedMembers?: string[] | string;
  mercenaryCount?: number;
  autoGenerated?: boolean;
}





export default function SchedulePageV2() {
  const navigate = useNavigate();
  const toast = useToast();
  
  // 중앙화된 데이터 상태 관리 (내부적으로만 사용)
  const [appData, setAppData] = useState({
    // 게임 데이터
    games: [] as GameData[],
    gameDataForCalendar: {} as Record<string, GameData>,
    
    // 투표 데이터
    voteResults: null as VoteResults | null,
    nextWeekVoteData: [] as VoteData[],
    
    // 회원 데이터
    allMembers: [] as Array<{id: number, name: string}>,
    
    // UI 상태
    isLoading: false,
    error: null as string | null,
    lastUpdated: null as Date | null
  });
  
  // 인증 상태
  const { user, refreshUserData, setUser, reloadTokenFromStorage } = useAuthStore();
  
  // 기존 상태 변수들 (호환성을 위해 유지)
  const [gameDataForCalendar, setGameDataForCalendar] = useState<Record<string, GameData>>({});
  const [allDates] = useState<VoteData[]>([]);
  const [voteResults, setVoteResults] = useState<VoteResults | null>({
    voteResults: {},
    voteSession: {
      id: 0,
      weekStartDate: '',
      startTime: '',
      endTime: '',
      isActive: false,
      isCompleted: false,
      createdAt: '',
      updatedAt: '',
      votes: []
    }
  });
  const [nextWeekVoteData, setNextWeekVoteData] = useState<VoteData[]>([]);
  
  // 통합 API 데이터 상태
  const [unifiedVoteData, setUnifiedVoteData] = useState<{
    activeSession: any;
    allMembers: Array<{id: number, name: string}>;
    lastWeekResults: any;
  } | null>(null);
  const [allMembers, setAllMembers] = useState<Array<{id: number, name: string}>>([]);
  const [games, setGames] = useState<GameData[]>([]);
  
  // UI 상태 (데이터와 분리)
  const [selectedDays, setSelectedDays] = useState<string[]>([]);
  const [showVoteStatus, setShowVoteStatus] = useState(false);
  const [commentText, setCommentText] = useState('');
  const [comments, setComments] = useState<{ text: string; user: string; date: string }[]>([]);
  const [showSuspensionRequestModal, setShowSuspensionRequestModal] = useState(false);
  const [suspensionRequestReason, setSuspensionRequestReason] = useState('');
  const [editingCommentIndex, setEditingCommentIndex] = useState<number | null>(null);
  const [editCommentText, setEditCommentText] = useState('');
  const [isLoading] = useState(false);
  const [error] = useState<string | null>(null);
  
  // 공휴일 체크 함수
  const isHolidayDate = useCallback((dateString: string): boolean => {
    // 현재는 하드코딩된 공휴일 체크 (나중에 API 연동으로 변경)
    const holidays = [
      '9월 29일', '9월 30일', '10월 3일', '10월 9일' // 추석, 개천절, 한글날
    ];
    
    return holidays.some(holiday => dateString.includes(holiday));
  }, []);

  // 투표 마감 안내 문구: 규칙 설명용 고정 문구 (자동 마감 아님)
  // 항상 "이번주 목요일 17시까지"로 표기하되, 컬러 표시는 이번주 목요일 17:00까지 남은 시간으로 계산
  const getVoteDeadline = useCallback(() => {
    const now = new Date();
    // 이번주 월요일 00:00 계산
    const currentDay = now.getDay(); // 0: 일, 1: 월, ..., 6: 토
    const daysToMonday = currentDay === 0 ? -6 : 1 - currentDay;
    const thisWeekMonday = new Date(now);
    thisWeekMonday.setDate(now.getDate() + daysToMonday);
    thisWeekMonday.setHours(0, 0, 0, 0);
    // 이번주 목요일 17:00 계산
    const thisWeekThursday1700 = new Date(thisWeekMonday);
    thisWeekThursday1700.setDate(thisWeekMonday.getDate() + 3); // 목요일
    thisWeekThursday1700.setHours(17, 0, 0, 0);
    const remainingHours = Math.max(0, (thisWeekThursday1700.getTime() - now.getTime()) / (1000 * 60 * 60));
    const month = thisWeekThursday1700.getMonth() + 1;
    const date = thisWeekThursday1700.getDate();
    const dayName = ['일', '월', '화', '수', '목', '금', '토'][thisWeekThursday1700.getDay()];
    const text = `${month}월 ${date}일(${dayName}) 17:00까지`;
    return { text, deadline: thisWeekThursday1700, remainingHours };
  }, []);

  // 투표 마감일 색상 계산 - 메모이제이션 적용
  const getVoteDeadlineColor = useCallback((remainingHours: number) => {
    if (remainingHours <= 0) return 'red.500';
    if (remainingHours <= 24) return 'red.500';
    if (remainingHours <= 48) return 'orange.500';
    return 'black';
  }, []);

  // 투표 마감일 정보 - 메모이제이션 적용
  const voteDeadlineInfo = useMemo(() => getVoteDeadline(), [getVoteDeadline]);
  
  // 투표 마감 여부 확인 (통합된 로직 사용)


  // 현재 날짜 기준으로 이번주와 다음주 일정 데이터 생성
  const getScheduleData = useMemo(() => {
    const now = new Date();
    const currentDay = now.getDay(); // 0: 일요일, 1: 월요일, ..., 6: 토요일
    
    // 이번주 월요일 계산
    let daysUntilMonday;
    if (currentDay === 0) { // 일요일
      daysUntilMonday = -6; // 지난 월요일
    } else if (currentDay === 1) { // 월요일
      daysUntilMonday = 0; // 오늘
    } else {
      daysUntilMonday = 1 - currentDay; // 이번주 월요일
    }
    
    const thisWeekMonday = new Date(now);
    thisWeekMonday.setDate(now.getDate() + daysUntilMonday);
    
    // 다음주 월요일 계산
    const nextWeekMonday = new Date(thisWeekMonday);
    nextWeekMonday.setDate(thisWeekMonday.getDate() + 7);
    
    // 이번주 일정 데이터 (월-금) - 기본값으로 초기화
    const thisWeekScheduleData = [];
    for (let i = 0; i < 5; i++) {
      const date = new Date(thisWeekMonday);
      date.setDate(thisWeekMonday.getDate() + i);
      
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const dayNames = ['월', '화', '수', '목', '금'];
      const dayName = dayNames[i];
      
      thisWeekScheduleData.push({
        date: `${month}월 ${day}일(${dayName})`,
        count: 0,
        confirmed: false
      });
    }
    
    // 다음주 일정투표 데이터 (월-금)
    const nextWeekVoteData = [];
    for (let i = 0; i < 5; i++) {
      const date = new Date(nextWeekMonday);
      date.setDate(nextWeekMonday.getDate() + i);
      
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const dayNames = ['월', '화', '수', '목', '금'];
      const dayName = dayNames[i];
      
      nextWeekVoteData.push({
        date: `${month}월 ${day}일(${dayName})`,
        count: 0
      });
    }
    
    return { thisWeekScheduleData, nextWeekVoteData };
  }, []);

  // 이번주 일정 데이터를 투표 결과(지난주 마감 세션)로만 표시
  const updateThisWeekScheduleWithGames = useMemo(() => {
    console.log('🔍 updateThisWeekScheduleWithGames 실행:', {
      games: games ? games.length : 0,
      unifiedVoteData: unifiedVoteData ? '있음' : '없음',
      thisWeekScheduleData: getScheduleData.thisWeekScheduleData
    });
    
    const updatedData = getScheduleData.thisWeekScheduleData.map(schedule => {
      // 날짜에서 일자 추출 (예: "9월 24일(수)" -> 24)
      const dayMatch = schedule.date.match(/(\d+)월 (\d+)일/);
      if (!dayMatch) return schedule;
      
      const month = parseInt(dayMatch[1]);
      const day = parseInt(dayMatch[2]);
      
      // 투표 결과만 사용 (지난주 완료 세션 요약)
      let totalCount = 0;
      let isConfirmed = false;
      if (unifiedVoteData && unifiedVoteData.lastWeekResults) {
        const lastWeekResults = unifiedVoteData.lastWeekResults;
        const results = lastWeekResults.results || {};
        
        // 요일 매핑 (월=0, 화=1, 수=2, 목=3, 금=4)
        const dayMapping = {
          'MON': 0, 'TUE': 1, 'WED': 2, 'THU': 3, 'FRI': 4
        };
        
        // 해당 날짜가 지난주 세션의 어느 요일에 해당하는지 확인
        const weekStartDate = new Date(lastWeekResults.weekStartDate);
        const dayIndex = Object.entries(dayMapping).find(([, index]) => {
          const currentDate = new Date(weekStartDate.getTime() + index * 24 * 60 * 60 * 1000);
          return currentDate.getMonth() === month - 1 && currentDate.getDate() === day;
        });
        
        console.log('🔍 날짜 매핑 확인:', {
          targetDate: `${month}-${day}`,
          weekStartDate: weekStartDate.toISOString().split('T')[0],
          dayMapping,
          foundDayIndex: dayIndex
        });
        
        if (dayIndex) {
          const [dayKey] = dayIndex;
          const voteCount = results[dayKey]?.count || 0;
          
          if (voteCount > 0) {
            totalCount = voteCount;
            isConfirmed = true; // 섹션은 투표결과만 반영
            
            console.log('🔍 투표 데이터에서 참석자 계산:', {
              date: schedule.date,
              dayKey,
              voteCount,
              participants: results[dayKey]?.participants || []
            });
          }
        }
      }
      
      // 게임 데이터는 본 섹션에서 사용하지 않음 (투표 결과 고정 표시)
      
      // 3. 디버깅을 위한 로그 추가
      console.log('🔍 이번주 일정 계산 결과:', {
        date: schedule.date,
        month,
        day,
        totalCount,
        isConfirmed,
        hasGameData: games && games.length > 0,
        hasVoteData: unifiedVoteData && unifiedVoteData.lastWeekResults
      });
      
      // 3. 게임 데이터가 없고 투표 데이터도 없으면 기본값 유지
      if (totalCount === 0 && !isConfirmed) {
        // 기본값은 0으로 유지
        console.log('🔍 기본값 유지:', {
          date: schedule.date,
          totalCount: 0,
          isConfirmed: false
        });
      }
      
      return {
        ...schedule,
        count: totalCount,
        confirmed: isConfirmed
      };
    });
    
    console.log('✅ 업데이트된 이번주 일정 데이터:', updatedData);
    return updatedData;
  }, [getScheduleData.thisWeekScheduleData, games, unifiedVoteData]);

  // 중앙화된 데이터 로딩 함수 - 통합 API 사용
  const loadAllData = useCallback(async () => {
    console.log('🔄 통합 API로 데이터 로딩 시작...');
    
    setAppData(prev => ({ ...prev, isLoading: true, error: null }));
    
    try {
      // 1. 통합 투표 데이터 로드 (모든 데이터 포함)
      console.log('🗳️ 통합 투표 데이터 로딩...');
      const unifiedData = await getUnifiedVoteDataNew();
      console.log('✅ 통합 투표 데이터 로드 완료:', unifiedData);
      console.log('🔍 통합 데이터 상세 분석:', {
        allMembers: unifiedData.allMembers,
        allMembersLength: unifiedData.allMembers?.length || 0,
        activeSession: unifiedData.activeSession,
        activeSessionExists: !!unifiedData.activeSession
      });
      
      // 통합 데이터에서 각각 추출
      const allMembers = unifiedData.allMembers || [];
      const activeSession = unifiedData.activeSession;
      
      // 2. 활성 세션이 있으면 투표 데이터 설정
      let voteResults = null;
      let localNextWeekVoteData: any[] = []; // 기본값을 빈 배열로 설정
      
      if (activeSession) {
        // 활성 세션이 있을 때만 다음주 투표 데이터 생성
        localNextWeekVoteData = getScheduleData.nextWeekVoteData.map(vote => ({
            ...vote,
            max: false,
            dayName: vote.date.split('(')[1]?.replace(')', '') || '',
            voteDate: new Date()
        }));
        // 활성 세션의 투표 데이터를 voteResults 형식으로 변환
          voteResults = {
            voteSession: {
            id: activeSession.sessionId,
            weekStartDate: activeSession.weekStartDate,
            startTime: activeSession.startTime,
            endTime: activeSession.endTime,
            isActive: activeSession.isActive,
            isCompleted: activeSession.isCompleted,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
            votes: activeSession.participants.map((participant: any) => ({
                id: Date.now() + Math.random(),
              userId: participant.userId,
              selectedDays: participant.selectedDays,
              createdAt: participant.votedAt
              }))
            },
          voteResults: activeSession.results
        };
        
        // 다음주 투표 데이터를 실제 데이터로 업데이트
        localNextWeekVoteData = Object.entries(activeSession.results).map(([day, data]: [string, any]) => {
          const dayNames = { MON: '월', TUE: '화', WED: '수', THU: '목', FRI: '금' };
          const dayName = dayNames[day as keyof typeof dayNames];
          
          // 기준 월요일에서 해당 요일 날짜 계산
          const baseMonday = new Date(activeSession.weekStartDate);
          const dayIndex = { MON: 0, TUE: 1, WED: 2, THU: 3, FRI: 4 }[day as keyof typeof dayNames];
          const targetDate = new Date(baseMonday.getTime() + dayIndex * 24 * 60 * 60 * 1000);
          
          const month = targetDate.getMonth() + 1;
          const dayNum = targetDate.getDate();
          
          return {
            date: `${month}월 ${dayNum}일(${dayName})`,
            count: data.count,
            max: false,
            dayName,
            voteDate: targetDate
          };
        });
        
        console.log('✅ 투표 데이터 설정 완료:', voteResults);
        console.log('✅ 다음주 투표 데이터 업데이트:', localNextWeekVoteData);
      } else {
        // 활성 세션이 없을 때는 빈 투표 데이터 설정
        console.log('⚠️ 활성 투표 세션이 없습니다. 빈 투표 데이터로 설정');
        voteResults = {
          voteResults: {},
          voteSession: {
            id: 0,
            weekStartDate: '',
            startTime: '',
            endTime: '',
            isActive: false,
            isCompleted: false,
            createdAt: '',
            updatedAt: '',
            votes: []
          }
        };
        localNextWeekVoteData = [];
      }
      
      // 3. 게임 데이터 로드
      console.log('⚽ 게임 데이터 로딩 시작...');
      const token = localStorage.getItem('token') || localStorage.getItem('auth_token_backup') || '';
      const gamesResponse = await fetch(`${API_ENDPOINTS.BASE_URL}/members`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      let games: any[] = [];
      let calendarGameData: Record<string, GameData> = {};
      if (gamesResponse.ok) {
        const unifiedData = await gamesResponse.json();
        games = unifiedData.games || [];
        console.log('🎮 게임 데이터 로드 성공 (통합 API):', games.length, '개');
        
        // 게임 데이터를 달력용으로 변환
        games.forEach((game: any) => {
          const gameDate = new Date(game.date);
          const dateString = gameDate.toISOString().split('T')[0]; // YYYY-MM-DD 형식
          
          // 자동생성일정은 일정확정 전까지 캘린더에 표시하지 않음
          if (game.autoGenerated) {
            console.log('⏭️ 자동생성일정 캘린더 표시 건너뜀:', dateString, game.eventType);
            return;
          }
          
          // 확정된 경기만 달력에 표시 (자동생성일정이 아닌 경우)
          if (!game.autoGenerated) {
            calendarGameData[dateString] = {
              id: String(game.id ?? dateString),
              confirmed: true, // 자동생성일정이 아니므로 모두 확정된 것으로 처리
              date: gameDate.toISOString(),
              time: game.time || '미정',
              location: game.location || '미정',
              eventType: game.eventType || '미정',
              // 백엔드에서 계산된 totalParticipantCount 사용
              count: game.totalParticipantCount || 0,
              // 모달 표시용 원자료 보존
              memberNames: game.memberNames ?? [],
              selectedMembers: game.selectedMembers ?? [],
              mercenaryCount: Number(game.mercenaryCount || 0),
              autoGenerated: false, // 캘린더에 표시되는 것은 확정된 게임만
              // 백엔드에서 계산된 참가자 정보 추가
              totalParticipantCount: game.totalParticipantCount,
              allParticipantNames: game.allParticipantNames
            };
            console.log('📅 달력용 게임 데이터 추가:', dateString, calendarGameData[dateString]);
          }
        });
        
        setGameDataForCalendar(calendarGameData);
        console.log('📅 달력용 게임 데이터 설정 완료:', Object.keys(calendarGameData).length, '개');
      } else {
        console.error('❌ 게임 데이터 로드 실패:', gamesResponse.status);
      }
      
      // 4. 이번주 일정 로드 (통합 API에서 가져옴)
      console.log('📅 이번주 일정 로딩...');
      // const thisWeekResponse = await getThisWeekSchedules();
      // const thisWeekSchedules = thisWeekResponse?.schedules || [];
      
      // 5. 통합 데이터 설정
      console.log('📊 통합 데이터 설정 중...');
      // 다음주 투표 데이터 상태 반영 (달력/우하단 섹션 표시용)
      setNextWeekVoteData(localNextWeekVoteData);
      setAppData({
        games,
        gameDataForCalendar: calendarGameData,
        voteResults,
        nextWeekVoteData: localNextWeekVoteData,
        allMembers,
        isLoading: false,
        error: null,
        lastUpdated: new Date()
      });
      
      // 6. 개별 상태도 설정 (기존 코드 호환성)
      setAllMembers(allMembers);
      setVoteResults(voteResults);
      setGames(games);
      setNextWeekVoteData(localNextWeekVoteData);
      
      // 7. 통합 데이터 설정
      setUnifiedVoteData({
        activeSession: unifiedData.activeSession,
        allMembers: unifiedData.allMembers, // allMembers 추가
        lastWeekResults: unifiedData.lastCompletedSessionSummary || null
      });
      
      console.log('🎉 모든 데이터 로드 완료!');
      console.log('📊 설정된 데이터:', {
        games: games.length,
        allMembers: allMembers.length,
        hasVoteResults: !!voteResults,
        hasActiveSession: !!activeSession,
        nextWeekVoteData: localNextWeekVoteData.length
      });
      
    } catch (error) {
      console.error('❌ 데이터 로드 실패:', error);
      
      // 오류 발생 시 기본 데이터로 설정하여 화면이 완전히 깨지지 않도록 함
      setAppData(prev => ({
        ...prev,
        isLoading: false,
        error: null, // 오류 메시지 제거
        lastUpdated: new Date()
      }));
      
      // 기본 데이터 설정
      setAllMembers([]);
      setVoteResults(null);
      setGames([]);
      setNextWeekVoteData([]);
      setUnifiedVoteData(null);
    }
  }, []);



  // 투표 결과를 localStorage에 저장 (사용하지 않음)
  // const saveVoteResultsToStorage = (results: VoteResults) => {
  //   localStorage.setItem('voteResults', JSON.stringify(results));
  // };

  // 투표 제출 처리 (1인 1회 복수날짜 투표)
  const handleVoteSubmit = async () => {
    // 인증 상태 확인
    let token = localStorage.getItem('token');
    const storedUser = localStorage.getItem('user');
    
    console.log('🔍 투표 제출 시 토큰 확인:', token ? '토큰 있음' : '토큰 없음');
    console.log('🔍 사용자 정보:', user);
    console.log('🔍 저장된 사용자:', storedUser ? '있음' : '없음');
    console.log('🔍 토큰 길이:', token ? token.length : 0);
    
    // 토큰이 없으면 강화된 토큰 복구 시도
    if (!token) {
      console.log('⚠️ 투표 시 강화된 토큰 복구 시도...');
      reloadTokenFromStorage();
      
      // 복구 후 다시 확인 (여러 소스에서)
      token = localStorage.getItem('token') || 
              localStorage.getItem('auth_token_backup') || 
              sessionStorage.getItem('token');
      
      if (!token) {
        console.log('❌ 토큰 복구 실패 - 로그인 페이지로 이동');
        toast({
          title: '투표 실패',
          description: '로그인이 필요합니다. 로그인 페이지로 이동합니다.',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
        navigate('/login');
        return;
      }
      console.log('✅ 토큰 복구 성공! 길이:', token.length);
      // 복구된 토큰을 다시 모든 저장소에 저장
      localStorage.setItem('token', token);
      localStorage.setItem('auth_token_backup', token);
      sessionStorage.setItem('token', token);
    }
    
    if (!token || !user) {
      console.log('❌ 인증 실패 - 토큰:', !!token, '사용자:', !!user);
      toast({
        title: '투표 실패',
        description: '로그인이 필요합니다. 로그인 페이지로 이동합니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      // 로그인 페이지로 리다이렉트
      navigate('/login');
      return;
    }

    // 투표 마감 확인
    if (isVoteClosed) {
      toast({
        title: '투표 마감',
        description: '투표 기간이 마감되었습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    // 선택된 날짜 확인
    if (selectedDays.length === 0) {
      toast({
        title: '투표 실패',
        description: '최소 하나의 날짜를 선택해주세요.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    console.log('✅ 인증 성공 - 투표 진행');

    // 인증 토큰 재확인 (중복 선언 제거)
    token = token || localStorage.getItem('token') || localStorage.getItem('auth_token_backup') || sessionStorage.getItem('token');
    if (!token) {
      toast({
        title: '투표 실패',
        description: '인증 토큰이 없습니다. 다시 로그인해주세요.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    // 토큰 유효성 검증
    try {
      const tokenPayload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Math.floor(Date.now() / 1000);
      if (tokenPayload.exp && tokenPayload.exp < currentTime) {
        toast({
          title: '투표 실패',
          description: '토큰이 만료되었습니다. 다시 로그인해주세요.',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
        return;
      }
    } catch (e) {
      toast({
        title: '투표 실패',
        description: '유효하지 않은 토큰입니다. 다시 로그인해주세요.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    // 활성 세션 ID 확보 - 없으면 기본 세션 생성
    let voteSessionId = voteResults?.voteSession?.id;
    if (!voteSessionId) {
      // 기본 투표 세션 생성
      const currentDate = new Date();
      const nextThursday = new Date(currentDate);
      nextThursday.setDate(currentDate.getDate() + (4 - currentDate.getDay() + 7) % 7); // 다음 목요일
      nextThursday.setHours(17, 0, 0, 0); // 17시
      
      const defaultVoteSession = {
        id: Date.now(),
        weekStartDate: (() => {
          const now = new Date();
          const currentDay = now.getDay();
          const daysToMonday = currentDay === 0 ? -6 : 1 - currentDay;
          const monday = new Date(now);
          monday.setDate(now.getDate() + daysToMonday);
          return monday.toISOString().split('T')[0];
        })(),
        startTime: new Date().toISOString(),
        endTime: nextThursday.toISOString(),
        isActive: true,
        isCompleted: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        votes: []
      };
      
      // voteResults 업데이트
      setVoteResults(prev => ({
        voteResults: prev?.voteResults || {},
        voteSession: defaultVoteSession
      }));
      
      voteSessionId = defaultVoteSession.id;
    }
    
    // 현재 사용자가 이미 투표했는지 확인
    const hasUserVoted = voteResults?.voteSession?.votes?.some((vote: any) => 
      vote.userId === user?.id
    );
    
    console.log('🔍 사용자 투표 여부 확인:', { hasUserVoted, userId: user?.id });
    
    try {
      // API에 투표 데이터 전송
      const response = await fetch(`${API_ENDPOINTS.BASE_URL}/votes`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          voteSessionId: voteSessionId,
          selectedDays: selectedDays,
          timestamp: new Date().toISOString()
        })
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('✅ 투표 API 성공:', result);
        
        // 성공 메시지
        toast({
          title: hasUserVoted ? '재투표 완료' : '투표 완료',
          description: hasUserVoted 
            ? `${selectedDays.length}개 날짜로 재투표가 완료되었습니다.`
            : `${selectedDays.length}개 날짜에 투표가 완료되었습니다.`,
          status: 'success',
          duration: 3000,
          isClosable: true,
        });
        
        // 투표 완료 후 선택된 날짜 초기화
        setSelectedDays([]);
        
        // 헤더의 투표율 업데이트를 위한 이벤트 발생
        window.dispatchEvent(new CustomEvent('voteSubmitted', {
          detail: { 
            userId: user?.id,
            sessionId: voteSessionId,
            selectedDays: selectedDays.length
          }
        }));
        
        // 로컬 상태 즉시 업데이트 (더 강력한 업데이트)
        const newVote = {
          id: Date.now(),
          userId: user?.id,
          selectedDays: selectedDays,
          createdAt: new Date().toISOString()
        };
        
        setVoteResults(prev => {
          if (!prev) {
            // voteResults가 null인 경우 기본 구조 생성
            return {
              voteResults: {},
              voteSession: {
                id: voteSessionId,
                weekStartDate: new Date().toISOString().split('T')[0],
                startTime: new Date().toISOString(),
                endTime: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                isActive: true,
                isCompleted: false,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                votes: [newVote]
              }
            };
          }
          
          if (!prev.voteSession) {
            // voteSession이 없는 경우 기본 구조 생성
            return {
              ...prev,
              voteSession: {
                id: voteSessionId,
                weekStartDate: new Date().toISOString().split('T')[0],
                startTime: new Date().toISOString(),
                endTime: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                isActive: true,
                isCompleted: false,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                votes: [newVote]
              }
            };
          }
          
          // 기존 투표가 있으면 제거하고 새 투표 추가
          const existingVotes = prev.voteSession.votes.filter((v: any) => v.userId !== user?.id);
          const updatedVotes = [...existingVotes, newVote];
          
          return {
            ...prev,
            voteSession: {
              ...prev.voteSession,
              votes: updatedVotes
            }
          };
        });
        
        // 강제 리렌더링을 위한 상태 업데이트
        setAppData(prev => ({
          ...prev,
          lastUpdated: new Date()
        }));
        
        // 데이터 새로고침 (백그라운드에서)
        setTimeout(async () => {
          try {
            await loadAllData();
            // 투표 데이터 변경 이벤트 발생
            window.dispatchEvent(new CustomEvent('voteDataChanged'));
            console.log('✅ 투표 데이터 변경 이벤트 발생');
          } catch (error) {
            console.error('❌ 데이터 새로고침 실패:', error);
          }
        }, 100);
        
      } else {
        const errorData = await response.json();
        console.error('❌ 투표 API 실패:', errorData);
        toast({
          title: '투표 실패',
          description: errorData.error || '투표 처리 중 오류가 발생했습니다.',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('❌ 투표 처리 오류:', error);
      toast({
        title: '투표 실패',
        description: '네트워크 오류가 발생했습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };

  // 재투표 처리 함수
  const handleRevote = async () => {
    try {
      // 현재 사용자의 투표 데이터 삭제
      const token = localStorage.getItem('token') || localStorage.getItem('auth_token_backup') || sessionStorage.getItem('token');
      
      console.log('🔍 재투표 토큰 확인:', { 
        token: token ? '있음' : '없음', 
        tokenLength: token?.length || 0,
        user: user ? '있음' : '없음',
        userId: user?.id,
        localStorage_token: localStorage.getItem('token') ? '있음' : '없음',
        localStorage_backup: localStorage.getItem('auth_token_backup') ? '있음' : '없음',
        sessionStorage_token: sessionStorage.getItem('token') ? '있음' : '없음'
      });
      
      if (!token || !user) {
        toast({
          title: '인증 오류',
          description: '로그인이 필요합니다.',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
        return;
      }

      // 현재 활성 세션 확인
      if (unifiedVoteData?.activeSession && unifiedVoteData.activeSession.isActive) {
        const { deleteVote } = await import('../api/auth');
        await deleteVote(user.id);
        
        // 로컬 상태 초기화
        setSelectedDays([]);
        
        // 헤더의 투표율 업데이트를 위한 이벤트 발생
        window.dispatchEvent(new CustomEvent('voteSubmitted', {
          detail: { 
            userId: user.id,
            sessionId: unifiedVoteData.activeSession.id,
            action: 'delete'
          }
        }));
        
        // 로컬 상태 즉시 업데이트 (투표 삭제)
        setVoteResults(prev => {
          if (!prev || !prev.voteSession) return prev;
          
          const updatedVotes = prev.voteSession.votes.filter((v: any) => v.userId !== user.id);
          
          return {
            ...prev,
            voteSession: {
              ...prev.voteSession,
              votes: updatedVotes
            }
          };
        });
        
        // 강제 리렌더링을 위한 상태 업데이트
        setAppData(prev => ({
          ...prev,
          lastUpdated: new Date()
        }));
        
        // 투표 결과 새로고침 (백그라운드에서)
        setTimeout(async () => {
          try {
            await loadAllData();
            // 투표 데이터 변경 이벤트 발생
            window.dispatchEvent(new CustomEvent('voteDataChanged'));
            console.log('✅ 투표 데이터 변경 이벤트 발생');
          } catch (error) {
            console.error('❌ 데이터 새로고침 실패:', error);
          }
        }, 100);
        
        toast({
          title: '투표가 초기화되었습니다',
          description: '다시 투표해주세요.',
          status: 'success',
          duration: 2000,
          isClosable: true,
        });
      } else {
        toast({
          title: '재투표 불가',
          description: '활성 투표 세션이 없습니다.',
          status: 'warning',
          duration: 3000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('재투표 초기화 오류:', error);
      toast({
        title: '재투표 초기화 실패',
        description: '다시 시도해주세요.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };


  // 사용자가 이미 투표했는지 확인하는 함수
  const hasUserVoted = () => {
    if (!voteResults?.voteSession?.votes || !user) return false;
    
    return voteResults.voteSession.votes.some((vote: any) => 
      vote.userId === user.id
    );
  };

  // 투표 마감 상태 확인 (세션 상태 또는 마감일 기준)
  const isVoteClosed = useMemo(() => {
    const session = unifiedVoteData?.activeSession;
    if (!session) return true; // 활성 세션 없으면 표시 비활성
    if (session.isCompleted === true) return true;
    if (session.isActive === false) return true;
    const now = new Date();
    const end = session.endTime ? new Date(session.endTime) : null;
    if (end && now > end) return true;
    return false;
  }, [unifiedVoteData?.activeSession]);

  // 투표 버튼 텍스트 결정
  const getVoteButtonText = () => {
    if (isVoteClosed) return '투표 마감';
    if (hasUserVoted()) return '재투표하기';
    return '투표하기';
  };

  // 투표 버튼 클릭 핸들러
  const handleVoteButtonClick = () => {
    if (isVoteClosed) {
      toast({
        title: '투표 마감',
        description: '투표 기간이 마감되었습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    if (hasUserVoted()) {
      handleRevote();
    } else {
      handleVoteSubmit();
    }
  };



  // 투표 현황 표시
  const handleShowVoteStatus = () => {
    setShowVoteStatus(true);
  };

  // 댓글 추가 핸들러
  const handleAddComment = () => {
    if (commentText.trim() && user) {
      const newComment = {
        text: commentText,
        user: user.name,
        date: `${new Date().getMonth() + 1}.${new Date().getDate()}.` // 8.19. 형식
      };
      setComments(prev => [...prev, newComment]);
      setCommentText('');
      toast({
        title: '댓글 추가',
        description: '댓글이 추가되었습니다.',
        status: 'success',
        duration: 3000,
        isClosable: true,
      });
    } else {
      toast({
        title: '댓글 실패',
        description: '댓글을 입력해주세요.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };

  // 댓글 수정 핸들러
  const handleEditComment = (index: number) => {
    setEditingCommentIndex(index);
    setEditCommentText(comments[index].text);
  };

  // 댓글 수정 저장 핸들러
  const handleSaveEditComment = (index: number) => {
    if (editCommentText.trim()) {
      const updatedComments = [...comments];
      updatedComments[index] = { ...updatedComments[index], text: editCommentText };
      setComments(updatedComments);
      setEditingCommentIndex(null);
      setEditCommentText('');
      toast({
        title: '댓글 수정',
        description: '댓글이 수정되었습니다.',
        status: 'success',
        duration: 3000,
        isClosable: true,
      });
    }
  };

  // 댓글 삭제 핸들러
  const handleDeleteComment = (index: number) => {
    const updatedComments = comments.filter((_, i) => i !== index);
    setComments(updatedComments);
    toast({
      title: '댓글 삭제',
      description: '댓글이 삭제되었습니다.',
      status: 'success',
      duration: 3000,
      isClosable: true,
    });
  };

  // 정지 해제 요청 제출
  const handleSuspensionRequestSubmit = () => {
    if (!suspensionRequestReason.trim()) {
      toast({
        title: '요청 실패',
        description: '요청 사유를 입력해주세요.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    if ((window as any).addSuspensionRequest && user) {
      (window as any).addSuspensionRequest(user.id, user.name, suspensionRequestReason.trim());
      
      setSuspensionRequestReason('');
      setShowSuspensionRequestModal(false);
      
      toast({
        title: '요청 완료',
        description: '정지 해제 요청이 제출되었습니다. 관리자 검토 후 처리됩니다.',
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      } else {
      toast({
        title: '요청 실패',
        description: '시스템 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };



  // 제거된 함수: fetchGamesFromAdmin (중앙화된 loadAllData로 대체됨)

  // 제거된 함수: autoCreateGamesFromSchedule (중앙화된 loadAllData로 대체됨)

  // 수동 데이터 로드 함수


  // 페이지 로드 시 토큰 자동 복구
  useEffect(() => {
    console.log('🔄 페이지 로드 시 토큰 자동 복구 시작...');
    reloadTokenFromStorage();
  }, [reloadTokenFromStorage]);

  // 초기 데이터 로드
  useEffect(() => {
    
    const loadData = async () => {
      // 토큰 검증 (더 관대하게)
      const token = localStorage.getItem('token');
      const userData = localStorage.getItem('user');
      
      if (!token) {
        console.log('❌ 토큰이 없습니다. 기본 데이터로 진행');
        // 토큰이 없어도 기본 데이터로 진행
        await loadAllData();
        return;
      }
      
      // 사용자 데이터가 localStorage에 있으면 일단 진행
      if (userData) {
        try {
          const parsedUser = JSON.parse(userData);
          console.log('✅ localStorage에서 사용자 데이터 확인:', parsedUser.name);
          
          // 사용자 데이터 새로고침 시도 (실패해도 계속 진행)
          try {
            await refreshUserData();
            console.log('✅ 사용자 데이터 새로고침 성공');
    } catch (error) {
            console.warn('⚠️ 사용자 데이터 새로고침 실패, localStorage 데이터 사용:', error);
            // 새로고침 실패해도 localStorage 데이터가 있으면 계속 진행
            // localStorage 데이터를 스토어에 설정
            setUser(parsedUser);
          }
          
          // 중앙화된 데이터 로딩
          await loadAllData();
          return;
        } catch (error) {
          console.error('❌ localStorage 사용자 데이터 파싱 실패:', error);
        }
      }
      
      // localStorage에 사용자 데이터가 없으면 새로고침 시도
      try {
        await refreshUserData();
        console.log('✅ 사용자 데이터 새로고침 성공');
        
        // 중앙화된 데이터 로딩
        await loadAllData();
    } catch (error) {
        console.error('❌ 사용자 데이터 새로고침 실패:', error);
        console.warn('⚠️ 사용자 데이터 새로고침 실패, 기본 데이터로 진행');
        
        // 사용자 데이터 새로고침 실패해도 기본 데이터로 진행
        await loadAllData();
        return;
      }
    };
    
    loadData();
    
  // 투표 데이터 자동 새로고침 비활성화 (수동 새로고침만 사용)
    // const interval = setInterval(() => {
    //   loadAllData();
    // }, 30000);
  
  // 투표 데이터 변경 이벤트 리스너
  const handleVoteDataChanged = () => {
    console.log('🔄 투표 데이터 변경 이벤트 수신 - 데이터 새로고침');
    loadAllData();
  };
    
    // 경기 데이터 변경 이벤트 리스너
    const handleGameDataChanged = () => {
    console.log('🔄 경기 데이터 변경 이벤트 수신 - 데이터 새로고침');
      loadAllData();
    };
    
  // 이벤트 리스너 등록
  window.addEventListener('voteDataChanged', handleVoteDataChanged);
    window.addEventListener('gameDataChanged', handleGameDataChanged);
    
    return () => {
      // clearInterval(interval); // interval 변수가 정의되지 않았으므로 제거
    window.removeEventListener('voteDataChanged', handleVoteDataChanged);
      window.removeEventListener('gameDataChanged', handleGameDataChanged);
    };
  }, []);

  // 페이지 로드 시 데이터 강제 새로고침
  useEffect(() => {
    const forceRefreshData = async () => {
      console.log('🔄 페이지 로드 시 데이터 강제 새로고침...');
      // 주의: 인증 토큰을 보존해야 하므로 스토리지는 초기화하지 않음
      // 필요한 비인증 캐시만 개별 키로 정리하도록 유지
      // 예) localStorage.removeItem('some_non_auth_cache_key');

      // 중앙화된 데이터 로딩
      await loadAllData();
      
      console.log('✅ 데이터 강제 새로고침 완료');
    };
    
    forceRefreshData();
  }, []);

  // 매주 월요일 00:01 자동 업데이트 로직
  useEffect(() => {
    const checkAndUpdateWeeklySchedule = () => {
      const now = new Date();
      const currentDay = now.getDay(); // 0: 일요일, 1: 월요일
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      
      // 매주 월요일 00:01 체크
      if (currentDay === 1 && currentHour === 0 && currentMinute === 1) {
        console.log('🕐 매주 월요일 00:01 - 자동 업데이트 시작');
        
        // 1단계: 지난주 다음주 일정투표 결과를 이번주 일정으로 반영
        updateThisWeekSchedule();
        
        // 2단계: 다음주 일정투표 자동 반영
        updateNextWeekVoteSchedule();
        
        // 3단계: 관리자-경기관리에 자동 추가
        updateAdminGameManagement();
      }
    };

    // 1분마다 체크 (정확한 00:01 타이밍을 위해)
    const interval = setInterval(checkAndUpdateWeeklySchedule, 60000);
    
    return () => clearInterval(interval);
  }, []);

  // 1단계: 지난주 다음주 일정투표 결과를 이번주 일정으로 반영
  const updateThisWeekSchedule = () => {
    console.log('📅 1단계: 이번주 일정 자동 업데이트');
    
    // 투표 결과에서 최다 투표를 받은 날짜 찾기
    if (voteResults && voteResults.voteResults) {
      const maxVoteCount = Math.max(...Object.values(voteResults.voteResults));
      const maxVoteDate = Object.keys(voteResults.voteResults).find(
        date => voteResults.voteResults[date] === maxVoteCount
      );
      
      if (maxVoteDate && maxVoteCount > 0) {
        console.log(`✅ 최다 투표 날짜: ${maxVoteDate}, 인원수: ${maxVoteCount}명`);
        
        // 이번주 일정에 자동 반영
        const updatedSchedule = getScheduleData.thisWeekScheduleData.map(schedule => {
          if (schedule.date.includes(maxVoteDate.split('-')[2])) {
            return {
              ...schedule,
              count: maxVoteCount,
              confirmed: true
            };
          }
          return schedule;
        });
        
        // 실제로는 API 호출로 데이터베이스 업데이트
        console.log('📊 이번주 일정 자동 업데이트 완료:', updatedSchedule);
      }
    }
  };

  // 2단계: 다음주 일정투표 자동 반영
  const updateNextWeekVoteSchedule = () => {
    console.log('🗳️ 2단계: 다음주 일정투표 자동 반영');
    
    // 실제 다음주 날짜 계산
    const now = new Date();
    const currentDay = now.getDay(); // 0: 일요일, 1: 월요일, ..., 6: 토요일
    
    // 이번주 월요일 계산
    let daysUntilMonday;
    if (currentDay === 0) { // 일요일
      daysUntilMonday = -6; // 지난 월요일
    } else if (currentDay === 1) { // 월요일
      daysUntilMonday = 0; // 오늘
    } else {
      daysUntilMonday = 1 - currentDay; // 이번주 월요일
    }
    
    const thisWeekMonday = new Date(now);
    thisWeekMonday.setDate(now.getDate() + daysUntilMonday);
    
    // 다음주 월요일 계산
    const nextWeekMonday = new Date(thisWeekMonday);
    nextWeekMonday.setDate(thisWeekMonday.getDate() + 7);
    
    // 다음주 투표 일정 자동 생성 (실제 다음주 월-금)
    const nextWeekVoteData = [];
    for (let i = 0; i < 5; i++) {
      const date = new Date(nextWeekMonday);
      date.setDate(nextWeekMonday.getDate() + i);
      
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const dayNames = ['월', '화', '수', '목', '금'];
      const dayName = dayNames[i];
      
      nextWeekVoteData.push({
        date: `${month}월 ${day}일(${dayName})`,
        count: 0
      });
    }
    
    console.log('📊 다음주 일정투표 자동 반영 완료:', nextWeekVoteData);
  };

  // 3단계: 관리자-경기관리에 자동 추가
  const updateAdminGameManagement = () => {
    console.log('⚙️ 3단계: 관리자-경기관리 자동 추가');
    
    // 투표 결과에서 최다 투표를 받은 날짜의 정보
    if (voteResults && voteResults.voteResults) {
      const maxVoteCount = Math.max(...Object.values(voteResults.voteResults));
      const maxVoteDate = Object.keys(voteResults.voteResults).find(
        date => voteResults.voteResults[date] === maxVoteCount
      );
      
      if (maxVoteDate && maxVoteCount > 0) {
        // 투표한 인원 목록 가져오기
        const memberNames = getVoteMemberNames(maxVoteDate, voteResults, user);
        
        // 관리자-경기관리에 자동 추가할 데이터
        const autoGameData = {
          date: maxVoteDate,
          count: maxVoteCount,
          memberNames: memberNames,
          selectedMembers: memberNames.slice(0, Math.floor(maxVoteCount / 2)), // 예시: 절반을 선택된 회원으로
          mercenaryCount: 0,
          manualInput: memberNames.slice(Math.floor(maxVoteCount / 2)), // 나머지를 수기입력으로
          eventType: null, // 관리자 입력 필요
          time: null, // 관리자 입력 필요
          location: null, // 관리자 입력 필요
          autoGenerated: true, // 자동 생성된 데이터임을 표시
          createdAt: new Date().toISOString()
        };
        
        console.log('⚽ 관리자-경기관리 자동 추가 데이터:', autoGameData);
        
        // 실제로는 API 호출로 데이터베이스에 저장
        // saveGameToAdmin(autoGameData);
      }
    }
  };

  // 자동 업데이트 상태 표시 (더미데이터 시연 후 실제 구현 예정)
  /*
  const [autoUpdateStatus, setAutoUpdateStatus] = useState<{
    lastUpdate: Date | null;
    nextUpdate: Date | null;
    isAutoGenerated: boolean;
  }>({
    lastUpdate: null,
    nextUpdate: null,
    isAutoGenerated: false
  });

  // 다음 월요일 00:01 계산
  useEffect(() => {
    const calculateNextUpdate = () => {
      const now = new Date();
      const daysUntilMonday = (8 - now.getDay()) % 7; // 다음 월요일까지 남은 일수
      const nextMonday = new Date(now);
      nextMonday.setDate(now.getDate() + daysUntilMonday);
      nextMonday.setHours(0, 1, 0, 0); // 00:01:00.000
      
      setAutoUpdateStatus(prev => ({
        ...prev,
        nextUpdate: nextMonday
      }));
    };
    
    calculateNextUpdate();
  }, []);
  */

  // 게임 클릭 핸들러


  // 이번주 일정 더미데이터 (이미지 디자인에 맞게)
  // const thisWeekScheduleData = [
  //   {
  //     id: 1,
  //     date: '8월 18일(월)',
  //     count: 0,
  //     confirmed: false
  //   },
  //   {
  //     id: 2,
  //     date: '8월 19일(화)',
  //     count: 0,
  //     confirmed: false
  //   },
  //   {
  //     id: 3,
  //     date: '8월 20일(수)',
  //     count: 6,
  //     confirmed: true
  //   },
  //   {
  //     id: 4,
  //     date: '8월 21일(목)',
  //     count: 0,
  //     confirmed: false
  //   },
  //   {
  //     id: 5,
  //     date: '8월 22일(금)',
  //     count: 0,
  //     confirmed: false
  //   }
  // ];

  // 이번주 일정 섹션
  const renderThisWeekSchedule = () => (
    <Box
      bg="white"
      p={{ base: 3, md: 4 }}
      borderRadius="lg"
      boxShadow="sm"
      border="1px solid"
      borderColor="gray.200"
      flex="1"
    >
      <Flex align="center" gap={2} mb={{ base: 3, md: 4 }}>
        <Box as="span" fontSize={{ base: "md", md: "lg" }}>⚽</Box>
        <Text fontSize={{ base: "md", md: "lg" }} fontWeight="bold">이번주 일정</Text>
      </Flex>
      
      <VStack spacing={{ base: 1.5, md: 2 }} align="stretch">
        {updateThisWeekScheduleWithGames.map((schedule) => {
          const actualCount = schedule.count;
          const isConfirmed = schedule.confirmed;
          
          return (
          <Flex key={schedule.date} justify="space-between" align="center" p={{ base: 1, md: 1 }}>
              <Flex align="center" gap={{ base: 1, md: 2 }} flex="1" minW="0">
                <Text 
                  fontSize={{ base: "xs", md: "sm" }} 
                  fontWeight={isConfirmed ? "bold" : "normal"} 
                  noOfLines={1}
                  color={(() => {
                    // 날짜 문자열에서 요일 추출하여 주말 판별
                    const match = schedule.date.match(/\((.)\)/);
                    if (!match) return 'gray.700';
                    const day = match[1];
                    
                    // 주말 또는 공휴일 체크
                    const isWeekend = (day === '토' || day === '일');
                    const isHoliday = isHolidayDate(schedule.date);
                    
                    return (isWeekend || isHoliday) ? 'red.500' : 'gray.700';
                  })()}
                >
                  {schedule.date}
                </Text>
                {isConfirmed && (
                <Badge 
                  colorScheme="blue" 
                  variant="outline" 
                  borderRadius="full" 
                  fontSize={{ base: "2xs", md: "xs" }} 
                  px={{ base: 1, md: 1.5 }} 
                  py={{ base: 0.5, md: 0.5 }}
                  minW={{ base: "28px", md: "32px" }}
                  textAlign="center"
                  bg="white"
                  borderColor="blue.400"
                  color="blue.600"
                  fontWeight="bold"
                  flexShrink={0}
                >
                  확정
                </Badge>
              )}
            </Flex>
            <Flex align="center" gap={2} flexShrink={0}>
              <Tooltip
                label={(() => {
                    if (actualCount === 0) {
                      return '참석자 없음';
                    }
                    
                    // 해당 날짜의 참석자 이름 찾기 (확정 경기 우선, 없으면 지난주 투표 결과)
                    const dayMatch = schedule.date.match(/(\d+)월 (\d+)일/);
                    if (dayMatch) {
                      const month = parseInt(dayMatch[1]);
                      const day = parseInt(dayMatch[2]);
                      
                      // 해당 날짜의 게임 데이터 찾기
                      const currentYear = new Date().getFullYear();
                      const gameForDate = games?.find(game => {
                        if (!game.date) return false;
                        const gameDate = new Date(game.date);
                        return gameDate.getFullYear() === currentYear && 
                               gameDate.getDate() === day && 
                               gameDate.getMonth() === month - 1;
                      });
                      
                      if (gameForDate) {
                        // 참석자 이름 수집
                        const attendeeNames = [];
                        
                        // selectedMembers 파싱 (실제 존재하는 회원만 필터링)
                        if (gameForDate.selectedMembers) {
                          try {
                            const selectedMembersArray = JSON.parse(
                              typeof gameForDate.selectedMembers === 'string' 
                                ? gameForDate.selectedMembers 
                                : gameForDate.selectedMembers[0] || '[]'
                            );
                            // 실제 존재하는 회원만 필터링
                            const validMembers = selectedMembersArray.filter((name: string) => {
                              return allMembers.some(member => member.name === name);
                            });
                            attendeeNames.push(...validMembers);
                          } catch (e) {
                            console.warn('selectedMembers 파싱 오류:', e);
                          }
                        }
                        
                        // memberNames 파싱 (회원 + 기타 모두 포함, 중복만 제거)
                        if (gameForDate.memberNames) {
                          try {
                            const memberNamesArray = JSON.parse(
                              typeof gameForDate.memberNames === 'string' 
                                ? gameForDate.memberNames 
                                : gameForDate.memberNames[0] || '[]'
                            );
                            // selectedMembers에 이미 있는 회원은 중복 제거
                            const validSelectedMembers: string[] = [];
                            const selectedSet = new Set(validSelectedMembers);
                            const otherNames = memberNamesArray.filter((name: string) => {
                              return !selectedSet.has(name); // 중복 제거
                            });
                            attendeeNames.push(...otherNames);
                          } catch (e) {
                            console.warn('memberNames 파싱 오류:', e);
                          }
                        }
                        
                        // 용병 수 추가
                        const mercenaryCount = gameForDate.mercenaryCount || 0;
                        if (mercenaryCount > 0) {
                          attendeeNames.push(`용병 ${mercenaryCount}명`);
                        }
                        
                        if (attendeeNames.length > 0) {
                          return attendeeNames.join(', ');
                        }
                      } else if (unifiedVoteData?.lastWeekResults) {
                        // 지난주 투표 결과에서 해당 요일의 참여자 이름 표시
                        const weekStartDate = new Date(unifiedVoteData.lastWeekResults.weekStartDate);
                        const targetDayIndex = [0,1,2,3,4].find(index => {
                          const currentDate = new Date(weekStartDate.getTime() + index * 24 * 60 * 60 * 1000);
                          return currentDate.getMonth() === month - 1 && currentDate.getDate() === day;
                        });
                        if (typeof targetDayIndex === 'number') {
                          const keyMap = ['MON','TUE','WED','THU','FRI'];
                          const key = keyMap[targetDayIndex];
                          const parts = unifiedVoteData.lastWeekResults.results?.[key]?.participants || [];
                          const names = parts.map((p: any) => p.userName).filter(Boolean);
                          if (names.length > 0) return names.join(', ');
                        }
                      }
                    }
                    
                    return `${actualCount}명 참석`;
                })()}
                placement="top"
                hasArrow
                bg="blue.600"
                color="white"
                fontSize="sm"
                borderRadius="md"
                px={3}
                py={2}
                maxW="200px"
                whiteSpace="normal"
              >
                <Badge 
                  colorScheme="purple" 
                  variant="solid" 
                  borderRadius="full" 
                  px={{ base: 2, md: 3 }} 
                  py={{ base: 0.5, md: 1 }} 
                  fontSize={{ base: "2xs", md: "xs" }}
                    bg={isConfirmed ? "blue.600" : "gray.200"}
                    color={isConfirmed ? "white" : "gray.600"}
                  w={{ base: "40px", md: "45px" }}
                  h={{ base: "20px", md: "22px" }}
                  display="flex"
                  alignItems="center"
                  justifyContent="center"
                    fontWeight={isConfirmed ? "bold" : "normal"}
                  flexShrink={0}
                >
                    {isHolidayDate(schedule.date) ? '-' : `${actualCount}명`}
                </Badge>
              </Tooltip>
            </Flex>
          </Flex>
          );
        })}
      </VStack>
    </Box>
  );

  // 투표 현황 모달에서 투표 멤버 이름 가져오기 (통합 API 구조)
  const getVoteMemberNames = (date: string, voteResults: VoteResults | null, _user: any) => {
    const memberNames: string[] = [];
    
    console.log('🔍 getVoteMemberNames 호출:', {
      date,
      allMembersCount: allMembers.length,
      unifiedVoteData: unifiedVoteData ? '있음' : '없음',
      activeSession: unifiedVoteData?.activeSession ? '있음' : '없음',
      participants: unifiedVoteData?.activeSession?.participants?.length || 0
    });
    
    // 통합 API 데이터에서 투표자 이름 찾기
    if (unifiedVoteData?.activeSession?.participants) {
      const participants = unifiedVoteData.activeSession.participants;

      // 기준 월요일: activeSession.weekStartDate(이번주 월요일) 기준으로 다음주 계산
      const baseWeekStartISO: string | undefined = unifiedVoteData?.activeSession?.weekStartDate;
      let baseMonday: Date;
      if (baseWeekStartISO) {
        baseMonday = new Date(baseWeekStartISO);
      } else {
        // fallback: 현재 날짜 기준 이번주 월요일
        const now = new Date();
        const currentDay = now.getDay();
        const daysUntilMonday = currentDay === 0 ? -6 : 1 - currentDay;
        baseMonday = new Date(now);
        baseMonday.setDate(now.getDate() + daysUntilMonday);
      }
      const nextWeekMonday = new Date(baseMonday);
      nextWeekMonday.setDate(baseMonday.getDate() + 7);

      console.log('🔍 기준 월요일 계산:', { baseWeekStartISO, baseMonday: baseMonday.toISOString(), nextWeekMonday: nextWeekMonday.toISOString(), uiDate: date });

      // 각 참가자에 대해 해당 날짜에 투표했는지 확인
      participants.forEach((participant: any) => {
        console.log('🔍 참가자 분석:', {
          userId: participant.userId,
          userName: participant.userName,
          selectedDays: participant.selectedDays
        });
        
        if (participant.selectedDays && Array.isArray(participant.selectedDays)) {
          // selectedDays의 각 날짜를 실제 날짜 형식으로 변환해서 비교
          const hasVotedForDate = participant.selectedDays.some((selectedDay: string) => {
            console.log('🔍 선택된 날짜 확인:', { selectedDay, targetDate: date });
            
            // selectedDay가 'MON', 'TUE' 등의 형태인 경우
            const dayMapping = { 'MON': 0, 'TUE': 1, 'WED': 2, 'THU': 3, 'FRI': 4 };
            const dayIndex = dayMapping[selectedDay as keyof typeof dayMapping];
            
            if (dayIndex !== undefined) {
              // activeSession.weekStartDate 기준 다음주 월요일에서 해당 요일 날짜 계산
              const targetDate = new Date(nextWeekMonday.getTime() + dayIndex * 24 * 60 * 60 * 1000);
              const month = targetDate.getMonth() + 1;
              const day = targetDate.getDate();
              const dayNames = ['월', '화', '수', '목', '금'];
              const dayName = dayNames[dayIndex];
              const formattedDate = `${month}월 ${day}일(${dayName})`;
              
              console.log('🔍 날짜 변환:', { selectedDay, formattedDate, targetDate: date, match: formattedDate === date });
              return formattedDate === date;
            }
            
            // selectedDay가 이미 한국어 형식인 경우
            if (selectedDay === date) {
              console.log('🔍 직접 매칭:', { selectedDay, date });
              return true;
            }
            
            return false;
          });
          
          if (hasVotedForDate) {
            console.log('✅ 투표자 찾음:', participant);
            // 먼저 participant.userName이 있으면 사용
            if (participant.userName) {
              memberNames.push(participant.userName);
              console.log('✅ userName 사용:', participant.userName);
            } else {
              // 없으면 allMembers에서 찾기
            const member = allMembers.find(m => m.id === participant.userId);
            if (member) {
              memberNames.push(member.name);
                console.log('✅ allMembers에서 찾음:', member.name);
              } else {
                // 그래도 없으면 기본값 사용
                memberNames.push(`회원${participant.userId}`);
                console.log('⚠️ 기본값 사용:', `회원${participant.userId}`);
              }
            }
          }
        }
      });
    }
    
    // 통합 API 데이터가 없으면 기존 방식 사용
    if (memberNames.length === 0 && voteResults && voteResults.voteSession && voteResults.voteSession.votes) {
      console.log('🔍 기존 방식 사용');
      voteResults.voteSession.votes.forEach(vote => {
        if (vote.selectedDays && Array.isArray(vote.selectedDays)) {
          const hasVotedForDate = vote.selectedDays.some((selectedDate: string) => {
            const dateObj = new Date(selectedDate);
            const month = dateObj.getMonth() + 1;
            const day = dateObj.getDate();
            const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][dateObj.getDay()];
            const formattedDate = `${month}월 ${day}일(${dayOfWeek})`;
            return formattedDate === date;
          });
          
          if (hasVotedForDate) {
            const member = allMembers.find(m => m.id === vote.userId);
            if (member) {
              memberNames.push(member.name);
            } else {
              memberNames.push(`회원${vote.userId}`);
            }
          }
        }
      });
    }
    
    console.log('📊 최종 멤버 이름:', memberNames);
    return memberNames;
  };

  // 불참자 이름 가져오기 (별도 함수)
  const getAbsentMemberNames = (voteResults: VoteResults | null, user: any) => {
    if (!voteResults || !voteResults.voteSession || !voteResults.voteSession.votes) {
    return [];
    }

    const absentMembers: string[] = [];
    
    // 투표 세션에서 '불참'을 선택한 사용자 찾기
    voteResults.voteSession.votes.forEach(vote => {
      if (vote.selectedDays.includes('불참')) {
        // 실제 회원 정보에 따른 이름 매핑
        // 실제 회원 데이터에서 사용자 이름 찾기
        let userName = '알 수 없음';
        const member = allMembers.find(m => m.id === vote.userId);
        if (member) {
          userName = member.name;
        }
        
        // 실제 사용자 이름이 있으면 사용, 없으면 매핑된 이름 사용
        if (user?.name && vote.userId === user.id) {
          userName = user.name;
        }
        
        absentMembers.push(userName);
      }
    });

    return absentMembers;
  };

  // 경기정보 모달 상태
  const [showGameModal, setShowGameModal] = useState(false);
  const [selectedGameData, setSelectedGameData] = useState<any>(null);

  // 경기정보 모달 표시
  const handleShowGameModal = (gameData: any) => {
    setSelectedGameData(gameData);
    setShowGameModal(true);
  };

  // 경기정보 모달 닫기
  const handleCloseGameModal = () => {
    setShowGameModal(false);
    setSelectedGameData(null);
  };

  return (
    <Box minH="100vh" bg="white" pt="80px">
      <style>
        {`
          /* 애니메이션 옵션들 - 원하는 것을 선택해서 주석 해제하세요 */
          
          /* 옵션 1: 깜빡임 (현재 적용됨) */
          @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
          }
          
          /* 옵션 2: 부드러운 확대/축소 (현재 적용됨) */
          @keyframes gentleScale {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
          }
          
          /* 옵션 3: 위아래 움직임 */
          @keyframes gentleBounce {
            0% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
            100% { transform: translateY(0); }
          }
          
          /* 옵션 4: 테두리 깜빡임 */
          @keyframes borderGlow {
            0% { border: 2px solid transparent; }
            50% { border: 2px solid purple; }
            100% { border: 2px solid transparent; }
          }
          
          /* 옵션 5: 색상 변화 */
          @keyframes colorShift {
            0% { background-color: rgb(147, 51, 234); }
            50% { background-color: rgb(168, 85, 247); }
            100% { background-color: rgb(147, 51, 234); }
          }
          
          /* 글로우 효과 애니메이션 */
          @keyframes glowEffect {
            0% { box-shadow: 0 0 10px rgba(147, 51, 234, 0.3); }
            50% { box-shadow: 0 0 20px rgba(147, 51, 234, 0.6); }
            100% { box-shadow: 0 0 10px rgba(147, 51, 234, 0.3); }
          }
        `}
      </style>
      <Flex direction="column" h="100vh" bg="gray.50">
        {/* 메인 컨텐츠 */}
        <Flex flex="1" overflow="hidden" direction={{ base: 'column', lg: 'row' }}>
          {/* 정지된 회원 안내 */}
          {user && (user as any).status === 'SUSPENDED' && (
            <Box
              w="100%"
              bg="red.50"
              border="1px solid"
              borderColor="red.200"
              borderRadius="md"
              p={4}
              mx={4}
              mt={2}
            >
              <VStack spacing={3} align="stretch">
                <HStack spacing={2} align="center">
                  <Box as="span" fontSize="lg">⚠️</Box>
                  <Text fontSize="lg" fontWeight="bold" color="red.800">
                    계정이 정지되었습니다
                  </Text>
                </HStack>
                <Text fontSize="sm" color="red.700">
                  투표 참여 부족으로 인해 계정이 정지되었습니다. 
                  정지 해제를 원하시면 아래 버튼을 클릭하여 요청해주세요.
                </Text>
                <Button
                  colorScheme="red"
                  variant="outline"
                  size="sm"
                  onClick={() => setShowSuspensionRequestModal(true)}
                  alignSelf="flex-start"
                >
                  정지 해제 요청하기
                </Button>
              </VStack>
            </Box>
          )}

          {/* 왼쪽: 달력 */}
          <Box flex="1" p={{ base: 2, md: 4 }} overflow="auto">
            {appData.isLoading ? (
              <CalendarSkeleton />
            ) : appData.error ? (
              <VStack spacing={4} align="center" justify="center" h="100%" minH="300px">
                <Icon as={WarningIcon} w={12} h={12} color="red.500" />
                <Text color="red.600" fontSize="lg" fontWeight="medium" textAlign="center">데이터 로드 실패</Text>
                <Text color="gray.600" textAlign="center" px={4}>{appData.error}</Text>
                <Button colorScheme="blue" onClick={loadAllData}>
                  다시 시도
                </Button>
              </VStack>
            ) : (
              <NewCalendarV2
                gameDataForCalendar={gameDataForCalendar}
                allDates={allDates}
                onGameClick={handleShowGameModal}
                voteResults={voteResults}
                nextWeekVoteData={nextWeekVoteData}
                allMembers={allMembers}
                unifiedVoteData={unifiedVoteData}
              />
            )}
          </Box>

          {/* 오른쪽: 일정 정보 */}
          <Box w={{ base: '100%', lg: '400px' }} p={{ base: 2, md: 4 }}>
            <VStack spacing={{ base: 4, md: 6 }} align="stretch">
              {/* 이번주 일정 */}
              {renderThisWeekSchedule()}

              {/* 다음주 일정투표 - 섹션은 항상 표시 */}
              {(
                <Box
                  bg="white"
                  p={{ base: 3, md: 4 }}
                  borderRadius="lg"
                  boxShadow="sm"
                  border="1px solid"
                  borderColor="gray.200"
                >
                  <Flex justify="space-between" align="center" mb={{ base: 3, md: 4 }}>
                    <Flex align="center" gap={2}>
                      <Box as="span" fontSize={{ base: "md", md: "lg" }}>🗳️</Box>
                      <Text fontSize={{ base: "md", md: "lg" }} fontWeight="bold">다음주 일정투표</Text>
                      {/* 상태 뱃지 - 제목 바로 옆에 배치 */}
                      {unifiedVoteData?.activeSession && (
                      <Badge
                        colorScheme={isVoteClosed ? "red" : "purple"}
                        variant="solid"
                        fontSize={{ base: "2xs", md: "xs" }}
                        px={{ base: 1, md: 1.5 }}
                        py={0.5}
                        borderRadius="full"
                        minW={{ base: "40px", md: "50px" }}
                        textAlign="center"
                        bg={isVoteClosed ? "red.500" : "purple.500"}
                        color="white"
                      >
                        {isVoteClosed ? "투표종료" : "투표 중"}
                      </Badge>
                      )}
                    </Flex>
                  {/* 투표참여율 - 오른쪽 끝에 배치 */}
                  <Tooltip 
                    label={(() => {
                      console.log('🔍 툴팁 데이터 확인:', {
                        unifiedVoteData: unifiedVoteData ? '있음' : '없음',
                        activeSession: unifiedVoteData?.activeSession ? '있음' : '없음',
                        lastWeekResults: unifiedVoteData?.lastWeekResults ? '있음' : '없음',
                        allMembers: unifiedVoteData?.allMembers?.length || 0
                      });
                      
                      if (!unifiedVoteData?.allMembers || unifiedVoteData.allMembers.length === 0) {
                        return '투표 데이터를 불러오는 중...';
                      }
                      
                      const allMembers = unifiedVoteData.allMembers;
                      let votedUserIds = new Set();
                      
                      // 방법 1: activeSession.participants에서 계산 (가장 정확한 방법)
                      if (unifiedVoteData.activeSession?.participants && Array.isArray(unifiedVoteData.activeSession.participants)) {
                        console.log('🔍 activeSession.participants 사용:', unifiedVoteData.activeSession.participants);
                        unifiedVoteData.activeSession.participants.forEach((participant: any) => {
                          votedUserIds.add(participant.userId);
                        });
                      }
                      // 방법 2: activeSession.results에서 계산 (fallback)
                      else if (unifiedVoteData.activeSession?.results) {
                        console.log('🔍 activeSession.results 사용:', unifiedVoteData.activeSession.results);
                        Object.values(unifiedVoteData.activeSession.results).forEach((dayResult: any) => {
                          if (dayResult.participants && Array.isArray(dayResult.participants)) {
                            dayResult.participants.forEach((participant: any) => {
                              votedUserIds.add(participant.userId);
                            });
                          }
                        });
                      }
                      // 방법 3: allSessions에서 계산 (fallback)
                      else if (unifiedVoteData.allSessions && Array.isArray(unifiedVoteData.allSessions) && unifiedVoteData.allSessions.length > 0) {
                        console.log('🔍 allSessions 사용:', unifiedVoteData.allSessions[0]);
                        const latestSession = unifiedVoteData.allSessions[0];
                        if (latestSession.participants && Array.isArray(latestSession.participants)) {
                          latestSession.participants.forEach((participant: any) => {
                            votedUserIds.add(participant.userId);
                          });
                        }
                      }
                      
                      console.log('🔍 투표한 사용자 IDs:', Array.from(votedUserIds));
                      
                      const votedMembers = allMembers.filter((member: any) => votedUserIds.has(member.id));
                      const nonVotedMembers = allMembers.filter((member: any) => !votedUserIds.has(member.id));
                      
                      console.log('🔍 투표 참여자:', votedMembers.map((m: any) => m.name));
                      console.log('🔍 투표 미참여자:', nonVotedMembers.map((m: any) => m.name));
                      
                      let tooltipText = '';
                      if (votedMembers.length > 0) {
                        tooltipText += `참여: ${votedMembers.map((m: any) => m.name).join(', ')}\n`;
                      }
                      if (nonVotedMembers.length > 0) {
                        tooltipText += `미참여: ${nonVotedMembers.map((m: any) => m.name).join(', ')}`;
                      }
                      
                      return tooltipText || '투표 데이터 없음';
                    })()}
                    placement="bottom"
                    hasArrow
                    bg="gray.800"
                    color="white"
                    fontSize="sm"
                    whiteSpace="pre-line"
                  >
                    <Text fontSize={{ base: "xs", md: "sm" }} color="gray.600" fontWeight="medium" cursor="default">
                      투표참여율: {(() => {
                        console.log('🔍 투표참여율 계산 상세:', {
                          unifiedVoteData: unifiedVoteData ? '있음' : '없음',
                          activeSession: unifiedVoteData?.activeSession ? '있음' : '없음',
                          allMembers: unifiedVoteData?.allMembers?.length || 0,
                          totalParticipants: unifiedVoteData?.activeSession?.totalParticipants || 0,
                          allMembersData: unifiedVoteData?.allMembers,
                          activeSessionData: unifiedVoteData?.activeSession
                        });
                        
                        if (!unifiedVoteData?.activeSession || !unifiedVoteData.allMembers || unifiedVoteData.allMembers.length === 0) {
                          console.log('⚠️ 투표참여율 계산 실패: 데이터 부족');
                          return "0%";
                        }
                        
                        const totalMembers = unifiedVoteData.allMembers.length;
                        
                        // 투표 데이터에서 고유한 사용자 수 계산 (다양한 데이터 구조 지원)
                        let uniqueVoters = 0;
                        
                        // 방법 1: activeSession.votes에서 계산
                        if (unifiedVoteData.activeSession.votes) {
                          uniqueVoters = new Set(unifiedVoteData.activeSession.votes.map(vote => vote.userId)).size;
                        }
                        // 방법 2: lastWeekResults에서 계산 (세션이 마감된 경우)
                        else if (unifiedVoteData.lastWeekResults?.results) {
                          const allParticipants = new Set();
                          Object.values(unifiedVoteData.lastWeekResults.results).forEach((dayResult: any) => {
                            if (dayResult.participants) {
                              dayResult.participants.forEach((participant: any) => {
                                allParticipants.add(participant.userId);
                              });
                            }
                          });
                          uniqueVoters = allParticipants.size;
                        }
                        // 방법 3: totalParticipants 사용
                        else if (unifiedVoteData.activeSession.totalParticipants) {
                          uniqueVoters = unifiedVoteData.activeSession.totalParticipants;
                        }
                        
                        const participationRate = totalMembers > 0 ? Math.round((uniqueVoters / totalMembers) * 100) : 0;
                        
                        console.log('✅ 투표참여율 계산 성공:', { totalMembers, uniqueVoters, participationRate });
                        return `${participationRate}%`;
                      })()}
                    </Text>
                  </Tooltip>
                </Flex>

                <VStack spacing={{ base: 1.5, md: 2 }} align="stretch" mb={{ base: 3, md: 4 }}>
                  {(() => {
                    // 로딩 상태일 때 스켈레톤 표시
                    if (appData.isLoading) {
                      return (
                        <VStack spacing={2} align="stretch">
                          {Array.from({ length: 5 }).map((_, i) => (
                            <Box key={i} p={2} borderWidth={1} borderRadius="lg">
                              <Flex justify="space-between" align="center">
                                <Skeleton height="16px" width="80px" />
                                <Skeleton height="20px" width="40px" />
                              </Flex>
                            </Box>
                          ))}
                        </VStack>
                      );
                    }
                    
                    // 통합 API 데이터에서 활성 세션의 투표 현황을 가져옴
                    if (!unifiedVoteData?.activeSession) {
                      return getScheduleData.nextWeekVoteData.map((vote, index) => {
                        const voteCount = (voteResults?.voteResults && voteResults.voteResults[vote.date]) || 0;
                        const maxVoteCount = voteResults?.voteResults ? Math.max(...Object.values(voteResults.voteResults), 0) : 0;
                        const isMaxVote = voteCount === maxVoteCount && voteCount > 0;
                        
                        return (
                          <Flex 
                            key={index} 
                            justify="space-between" 
                            align="center"
                            p={{ base: 1, md: 1 }}
                            borderRadius="lg"
                            border={selectedDays.includes(vote.date) ? "1px solid" : "none"}
                            borderColor={selectedDays.includes(vote.date) ? "purple.400" : "transparent"}
                            bg={selectedDays.includes(vote.date) ? "purple.50" : "transparent"}
                            onClick={() => {
                              // 공휴일(주말) 선택 불가
                              const match = vote.date.match(/\((.)\)/);
                              if (match) {
                                const day = match[1];
                                const isWeekend = (day === '토' || day === '일');
                                const isHoliday = isHolidayDate(vote.date);
                                
                                if (isWeekend || isHoliday) {
                                  toast({
                                    title: '선택 불가',
                                    description: isWeekend ? '주말은 선택할 수 없습니다.' : '공휴일은 선택할 수 없습니다.',
                                    status: 'warning',
                                    duration: 2000,
                                    isClosable: true,
                                  });
                                  return;
                                }
                              }
                              
                              if (selectedDays.includes(vote.date)) {
                                setSelectedDays(selectedDays.filter(day => day !== vote.date));
                              } else {
                                const filteredDays = selectedDays.filter(day => day !== '불참');
                                setSelectedDays([...filteredDays, vote.date]);
                              }
                            }}
                            _hover={{
                              bg: selectedDays.includes(vote.date) ? "purple.100" : "gray.50",
                              transform: "translateY(-1px)",
                              boxShadow: "sm"
                            }}
                            transition="all 0.2s ease-in-out"
                            _active={{
                              transform: "translateY(0px)",
                              boxShadow: "none"
                            }}
                            _focus={{
                              outline: "2px solid",
                              outlineColor: "purple.400",
                              outlineOffset: "2px"
                            }}
                            tabIndex={0}
                            role="button"
                            aria-pressed={selectedDays.includes(vote.date)}
                            aria-label={`${vote.date} 투표 선택`}
                          >
                            <Flex align="center" gap={{ base: 1, md: 2 }} flex="1" minW="0">
                              <Text 
                                fontSize={{ base: "xs", md: "sm" }} 
                                fontWeight={isMaxVote ? "bold" : "normal"} 
                                noOfLines={1}
                                color={(() => {
                                  // 날짜 문자열에서 요일 추출하여 주말 판별
                                  const match = vote.date.match(/\((.)\)/);
                                  if (!match) return 'gray.700';
                                  const day = match[1];
                                  
                                  // 주말 또는 공휴일 체크
                                  const isWeekend = (day === '토' || day === '일');
                                  const isHoliday = isHolidayDate(vote.date);
                                  
                                  return (isWeekend || isHoliday) ? 'red.500' : 'gray.700';
                                })()}
                              >
                                {vote.date}
                              </Text>
                              {isMaxVote && (
                                <Badge 
                                  colorScheme="purple" 
                                  variant="outline" 
                                  fontSize={{ base: "2xs", md: "xs" }} 
                                  px={{ base: 1, md: 1.5 }} 
                                  py={{ base: 0.5, md: 0.5 }}
                                  borderRadius="full"
                                  minW={{ base: "28px", md: "32px" }}
                                  textAlign="center"
                                  borderColor="purple.400"
                                  color="purple.600"
                                  flexShrink={0}
                                >
                                  최다
                                </Badge>
                              )}
                            </Flex>
                            <Tooltip
                              label={(() => {
                                if (voteCount === 0) return '-';
                                
                                // 통합 API에서 직접 투표자 이름 가져오기
                                if (unifiedVoteData?.activeSession?.results) {
                                  // 날짜 문자열에서 요일 추출
                                  const match = vote.date.match(/(\d+)월 (\d+)일\((.+)\)/);
                                  if (match) {
                                    const dayOfWeek = match[3]; // 월, 화, 수, 목, 금
                                    const dayKeys: { [key: string]: string } = {
                                      '월': 'MON',
                                      '화': 'TUE', 
                                      '수': 'WED',
                                      '목': 'THU',
                                      '금': 'FRI'
                                    };
                                    
                                    const dayKey = dayKeys[dayOfWeek];
                                    
                                    if (dayKey && unifiedVoteData.activeSession.results[dayKey]?.participants) {
                                      const dayResult = unifiedVoteData.activeSession.results[dayKey];
                                      const memberNames = dayResult.participants.map((p: any) => p.userName).filter(Boolean);
                                      
                                      console.log('🔍 툴팁 투표자 이름:', {
                                        voteDate: vote.date,
                                        dayKey,
                                        memberNames
                                      });
                                      
                                      return memberNames.length > 0 ? memberNames.join(', ') : '-';
                                    }
                                  }
                                }
                                
                                // 통합 API 데이터가 없으면 기존 방식 사용
                                const memberNames = getVoteMemberNames(vote.date, voteResults, user);
                                return memberNames.length > 0 ? memberNames.join(', ') : '-';
                              })()}
                              placement="top"
                              hasArrow
                              bg="purple.600"
                              color="white"
                              fontSize="sm"
                              borderRadius="md"
                              px={3}
                              py={2}
                              maxW="200px"
                              whiteSpace="normal"
                            >
                              <Badge
                                colorScheme={isMaxVote ? "purple" : (voteCount === 0 ? "gray" : "blackAlpha")}
                                variant="solid"
                                borderRadius="full"
                                px={3}
                                py={1}
                                fontSize="xs"
                                bg={isMaxVote ? "purple.600" : (voteCount === 0 ? "gray.200" : "black")}
                                color={isMaxVote ? "white" : (voteCount === 0 ? "gray.600" : "white")}
                                w="45px"
                                h="22px"
                                display="flex"
                                alignItems="center"
                                justifyContent="center"
                                fontWeight={isMaxVote ? "bold" : "normal"}
                              >
                                {voteCount}명
                              </Badge>
                            </Tooltip>
                            
                          </Flex>
                        );
                      });
                    }
                    
                    // 통합 API 데이터 사용 - 다음주 날짜로 수정
                    const activeSession = unifiedVoteData.activeSession;
                    const results = activeSession.results || {};
                    
                    // 실제 다음주 날짜 계산 (API의 weekStartDate가 이번주일 수 있으므로)
                    const now = new Date();
                    const currentDay = now.getDay(); // 0: 일요일, 1: 월요일, ..., 6: 토요일
                    
                    // 이번주 월요일 계산
                    let daysUntilMonday;
                    if (currentDay === 0) { // 일요일
                      daysUntilMonday = -6; // 지난 월요일
                    } else if (currentDay === 1) { // 월요일
                      daysUntilMonday = 0; // 오늘
                    } else {
                      daysUntilMonday = 1 - currentDay; // 이번주 월요일
                    }
                    
                    const thisWeekMonday = new Date(now);
                    thisWeekMonday.setDate(now.getDate() + daysUntilMonday);
                    
                    // 다음주 월요일 계산
                    const nextWeekMonday = new Date(thisWeekMonday);
                    nextWeekMonday.setDate(thisWeekMonday.getDate() + 7);
                    
                    const dayMapping = {
                      'MON': 0, 'TUE': 1, 'WED': 2, 'THU': 3, 'FRI': 4
                    };
                    
                    return Object.entries(dayMapping).map(([dayKey, dayIndex]) => {
                      const currentDate = new Date(nextWeekMonday.getTime() + dayIndex * 24 * 60 * 60 * 1000);
                      const month = currentDate.getMonth() + 1;
                      const day = currentDate.getDate();
                      const dayNames = ['월', '화', '수', '목', '금'];
                      const dayName = dayNames[dayIndex];
                      const dateString = `${month}월 ${day}일(${dayName})`;
                      
                      const voteCount = results[dayKey]?.count || 0;
                      const maxVoteCount = Math.max(...Object.values(results).map((r: any) => r.count || 0), 0);
                      const isMaxVote = voteCount === maxVoteCount && voteCount > 0;
                    
                      return (
                        <Flex 
                          key={dayKey} 
                          justify="space-between" 
                          align="center"
                          p={{ base: 1, md: 1 }}
                          borderRadius="lg"
                          border={selectedDays.includes(dateString) ? "1px solid" : "none"}
                          borderColor={selectedDays.includes(dateString) ? "purple.400" : "transparent"}
                          bg={selectedDays.includes(dateString) ? "purple.50" : "transparent"}
                            onClick={() => {
                              // 투표 마감된 경우 선택 불가
                              if (isVoteClosed) return;
                              
                              // 공휴일 선택 불가
                              if (isHolidayDate(dateString)) {
                                toast({
                                  title: '선택 불가',
                                  description: '공휴일은 선택할 수 없습니다.',
                                  status: 'warning',
                                  duration: 2000,
                                  isClosable: true,
                                });
                                return;
                              }
                              
                              // 공휴일(주말) 선택 불가
                              const dateObj = new Date(dateString);
                              const dayOfWeek = dateObj.getDay();
                              const isWeekendDay = dayOfWeek === 0 || dayOfWeek === 6; // 일요일(0) 또는 토요일(6)
                              if (isWeekendDay) {
                                toast({
                                  title: '선택 불가',
                                  description: '주말은 선택할 수 없습니다.',
                                  status: 'warning',
                                  duration: 2000,
                                  isClosable: true,
                                });
                                return;
                              }
                              
                              // 평일은 복수 선택 가능, 불참과 상호배타적
                              if (selectedDays.includes(dateString)) {
                                setSelectedDays(selectedDays.filter(day => day !== dateString));
                              } else {
                                // 불참이 선택되어 있으면 제거하고 평일 추가
                                const filteredDays = selectedDays.filter(day => day !== '불참');
                                setSelectedDays([...filteredDays, dateString]);
                              }
                            }}
                          _hover={{
                            bg: selectedDays.includes(dateString) ? "purple.100" : "gray.50",
                            transform: "translateY(-1px)",
                            boxShadow: "sm"
                          }}
                          transition="all 0.2s ease-in-out"
                          _active={{
                            transform: "translateY(0px)",
                            boxShadow: "none"
                          }}
                          _focus={{
                            outline: "2px solid",
                            outlineColor: "purple.400",
                            outlineOffset: "2px"
                          }}
                          tabIndex={0}
                          role="button"
                          aria-pressed={selectedDays.includes(dateString)}
                          aria-label={`${dateString} 투표 선택`}
                        >
                          <Flex align="center" gap={{ base: 1, md: 2 }} flex="1" minW="0">
                            <Text 
                              fontSize={{ base: "xs", md: "sm" }} 
                              fontWeight={isMaxVote ? "bold" : "normal"} 
                              noOfLines={1}
                              color={isHolidayDate(dateString) ? "red.500" : "gray.700"}
                            >
                              {dateString}
                            </Text>
                            {isMaxVote && (
                              <Badge 
                                colorScheme="purple" 
                                variant="outline" 
                                fontSize={{ base: "2xs", md: "xs" }} 
                                px={{ base: 1, md: 1.5 }} 
                                py={{ base: 0.5, md: 0.5 }}
                                borderRadius="full"
                                minW={{ base: "28px", md: "32px" }}
                                textAlign="center"
                                borderColor="purple.400"
                                color="purple.600"
                                flexShrink={0}
                              >
                                최다
                              </Badge>
                            )}
                          </Flex>
                          <Tooltip
                            label={(() => {
                              if (voteCount === 0) return '-';
                              
                              // 통합 API 데이터에서 직접 투표자 이름 가져오기
                              if (unifiedVoteData?.activeSession?.results?.[dayKey]?.participants) {
                                const dayResult = unifiedVoteData.activeSession.results[dayKey];
                                const memberNames = dayResult.participants.map((p: any) => p.userName).filter(Boolean);
                                
                                console.log('🔍 툴팁 투표자 이름:', {
                                  dateString,
                                  dayKey,
                                  voteCount,
                                  memberNames
                                });
                                
                                return memberNames.length > 0 ? memberNames.join(', ') : '-';
                              }
                              
                              // 통합 API 데이터가 없으면 기존 방식 사용
                              const memberNames = getVoteMemberNames(dateString, voteResults, user);
                              return memberNames.length > 0 ? memberNames.join(', ') : '-';
                            })()}
                            placement="top"
                            hasArrow
                            bg="purple.600"
                            color="white"
                            fontSize="sm"
                            borderRadius="md"
                            px={3}
                            py={2}
                            maxW="200px"
                            whiteSpace="normal"
                          >
                            <Badge
                              colorScheme={isMaxVote ? "purple" : (voteCount === 0 ? "gray" : "blackAlpha")}
                              variant="solid"
                              borderRadius="full"
                              px={3}
                              py={1}
                              fontSize="xs"
                              bg={isMaxVote ? "purple.600" : (voteCount === 0 ? "gray.200" : "black")}
                              color={isMaxVote ? "white" : (voteCount === 0 ? "gray.600" : "white")}
                              w="45px"
                              h="22px"
                              display="flex"
                              alignItems="center"
                              justifyContent="center"
                              fontWeight={isMaxVote ? "bold" : "normal"}
                            >
                              {isHolidayDate(dateString) ? '-' : `${voteCount}명`}
                            </Badge>
                          </Tooltip>
                        </Flex>
                      );
                    });
                  })()}
                  
                  {/* 불참 옵션 */}
                  <Flex 
                    justify="space-between" 
                    align="center"
                    p={{ base: 1, md: 1 }}
                    borderRadius="lg"
                    border={selectedDays.includes('불참') ? "1px solid" : "none"}
                    borderColor={selectedDays.includes('불참') ? "purple.400" : "transparent"}
                    bg={selectedDays.includes('불참') ? "purple.50" : "transparent"}

                    onClick={() => {
                      // 투표가 완료된 경우 선택 불가
                      if (voteResults) return;
                      
                      // 투표 마감된 경우 선택 불가
                      if (isVoteClosed) return;
                      
                      // 불참은 단독 선택 (평일 선택 모두 해제)
                      if (selectedDays.includes('불참')) {
                        setSelectedDays([]);
                      } else {
                        setSelectedDays(['불참']);
                      }
                    }}
                    _hover={{
                      bg: selectedDays.includes('불참') ? "purple.100" : "gray.50",
                      transform: "translateY(-1px)",
                      boxShadow: "sm"
                    }}
                    transition="all 0.2s ease-in-out"
                    _active={{
                      transform: "translateY(0px)",
                      boxShadow: "none"
                    }}
                    _focus={{
                      outline: "2px solid",
                      outlineColor: "purple.400",
                      outlineOffset: "2px"
                    }}
                    tabIndex={0}
                    role="button"
                    aria-pressed={selectedDays.includes('불참')}
                    aria-label="불참 선택"
                  >
                    <Text fontSize={{ base: "xs", md: "sm" }} color="red.500">불참</Text>
                    <Tooltip
                      label={(() => {
                        const absentCount = voteResults?.voteResults['불참'] || 0;
                        if (absentCount === 0) return '-';
                        
                        // 불참한 인원명 가져오기
                        const absentMembers = getAbsentMemberNames(voteResults, null);
                        return absentMembers.length > 0 ? absentMembers.join(', ') : '-';
                      })()}
                      placement="top"
                      hasArrow
                      bg="red.600"
                      color="white"
                      fontSize="sm"
                      borderRadius="md"
                      px={3}
                      py={2}
                      maxW="200px"
                      whiteSpace="normal"
                    >
                    <Badge 
                        bg="red.500"
                        color="white"
                      variant="solid" 
                      borderRadius="full" 
                      px={{ base: 2, md: 3 }} 
                      py={{ base: 0.5, md: 1 }} 
                      fontSize={{ base: "2xs", md: "xs" }}
                      w={{ base: "40px", md: "45px" }}
                      h={{ base: "20px", md: "22px" }}
                      display="flex"
                      alignItems="center"
                      justifyContent="center"
                      flexShrink={0}
                    >
                      {voteResults?.voteResults['불참'] || 0}명
                    </Badge>
                    </Tooltip>
                  </Flex>
                </VStack>

                {/* 버튼들 */}
                <VStack spacing={{ base: 2, md: 3 }} align="stretch">
                  {/* 투표마감, 투표현황, 투표하기를 한 줄에 배치 */}
                  <Flex gap={{ base: 1, md: 2 }} align="center" direction={{ base: 'column', sm: 'row' }}>
                    {/* 투표마감 시간 - 마감 시 숨김 */}
                    {!isVoteClosed && unifiedVoteData?.activeSession && (
                      <Text
                        fontSize={{ base: "2xs", md: "xs" }}
                        color={getVoteDeadlineColor(voteDeadlineInfo.remainingHours)}
                        fontWeight="medium"
                        flex="1"
                        textAlign={{ base: "center", sm: "left" }}
                        mb={{ base: 1, sm: 0 }}
                      >
                        투표마감: {voteDeadlineInfo.text}
                      </Text>
                    )}
                    
                    <Flex gap={{ base: 1, md: 2 }} w={{ base: "100%", sm: "auto" }}>
                      <Button
                        size={{ base: "xs", md: "sm" }}
                        colorScheme="purple"
                        onClick={handleShowVoteStatus}
                        fontSize={{ base: "2xs", md: "xs" }}
                        px={{ base: 1, md: 2 }}
                        h={{ base: "20px", md: "22px" }}
                        flex="1"
                        _hover={{
                          transform: "translateY(-1px)",
                          boxShadow: "md"
                        }}
                        transition="all 0.2s ease-in-out"
                      >
                        투표현황
                      </Button>
                      
                      {(() => {
                        // 현재 활성화된 투표 세션인지 확인
                        if (!voteResults || !voteResults.voteSession || !voteResults.voteSession.votes) return false;
                        
                        const currentDate = new Date();
                        const sessionDate = new Date(voteResults.voteSession.weekStartDate);
                        const isCurrentSession = Math.abs(currentDate.getTime() - sessionDate.getTime()) < 7 * 24 * 60 * 60 * 1000; // 7일 이내
                        
                        if (!isCurrentSession) return false;
                        
                        // 투표 마감 상태 확인
                        if (isVoteClosed) return false;
                        
                        // 현재 사용자가 현재 활성 세션에서 투표했는지 확인
                        const hasUserVoted = voteResults.voteSession.votes.some((vote: any) => 
                          vote.userId === user?.id
                        );
                        
                        console.log('🔍 재투표하기 버튼 조건 확인:', {
                          userVotes: voteResults.voteSession.votes.filter((v: any) => v.userId === user?.id),
                          hasUserVoted,
                          totalVotes: voteResults.voteSession.votes.length
                        });
                        
                        return hasUserVoted;
                      })() ? (
                        <Button
                          size={{ base: "xs", md: "sm" }}
                          bg="#FF6B35"
                          color="white"
                          onClick={handleRevote}
                          fontSize={{ base: "2xs", md: "xs" }}
                          px={{ base: 1, md: 2 }}
                          h={{ base: "20px", md: "22px" }}
                          isDisabled={isVoteClosed}
                          flex="1"
                          _hover={{
                            bg: "#E55A2B",
                            transform: "translateY(-1px)",
                            boxShadow: "md"
                          }}
                          transition="all 0.2s ease-in-out"
                        >
                          {getVoteButtonText()}
                        </Button>
                      ) : (
                        <Button
                          size={{ base: "xs", md: "sm" }}
                          bg={isVoteClosed ? "gray.400" : "purple.600"}
                          color="white"
                          onClick={handleVoteButtonClick}
                          fontSize={{ base: "2xs", md: "xs" }}
                          px={{ base: 1, md: 2 }}
                          h={{ base: "20px", md: "22px" }}
                          isDisabled={isVoteClosed}
                          flex="1"
                          _hover={{
                            bg: isVoteClosed ? "gray.400" : (selectedDays.length > 0 ? "purple.700" : "purple.600"),
                            transform: isVoteClosed ? "none" : (selectedDays.length > 0 ? "translateY(-1px)" : "none"),
                            boxShadow: isVoteClosed ? "none" : (selectedDays.length > 0 ? "md" : "none")
                          }}
                          transition="all 0.2s ease-in-out"
                        >
                          {getVoteButtonText()}
                        </Button>
                      )}
                    </Flex>
                  </Flex>
                </VStack>
              </Box>
              )}
            </VStack>
          </Box>
        </Flex>
      </Flex>

      {/* 투표 현황 모달 */}
      <Modal 
        isOpen={showVoteStatus} 
        onClose={() => setShowVoteStatus(false)} 
        size={{ base: "full", md: "lg" }}
        aria-labelledby="vote-status-modal-title"
        aria-describedby="vote-status-modal-description"
      >
        <ModalOverlay />
        <ModalContent mx={{ base: 2, md: "auto" }} my={{ base: 2, md: "auto" }}>
          <ModalHeader fontSize={{ base: "lg", md: "xl" }} id="vote-status-modal-title">
            📊 투표 현황 [
            <Text as="span" color="purple.600" fontWeight="bold">
              {getScheduleData.nextWeekVoteData[0]?.date} ~ {getScheduleData.nextWeekVoteData[4]?.date}
            </Text>
            ]
          </ModalHeader>
          <ModalCloseButton aria-label="투표 현황 모달 닫기" />
          <ModalBody id="vote-status-modal-description">
            {voteResults ? (
              <VStack spacing={{ base: 3, md: 4 }} align="stretch">
                {/* 요약 정보 */}
                <Flex justify="space-between" align="center" p={{ base: 2, md: 3 }} bg="gray.50" borderRadius="md" direction={{ base: 'column', sm: 'row' }} gap={{ base: 2, sm: 0 }}>
                  <Tooltip 
                    label={(() => {
                      if (!voteResults || !voteResults.voteSession || !voteResults.voteSession.votes) return '투표 데이터가 없습니다.';
                      
                      // 투표에 참여한 인원명 수집 (실제 회원 정보에서 가져오기)
                      const participants = new Set<string>();
                      voteResults.voteSession.votes.forEach(vote => {
                        const member = allMembers.find(m => m.id === vote.userId);
                        console.log('🔍 투표 현황 모달 투표자 분석:', {
                          userId: vote.userId,
                          member: member ? { id: member.id, name: member.name } : null
                        });
                        if (member) {
                          participants.add(member.name);
                        } else {
                          console.warn('⚠️ 투표 현황 모달 - 존재하지 않는 회원의 투표:', vote.userId);
                        }
                      });
                      
                      const participantList = Array.from(participants).sort((a, b) => a.localeCompare(b, 'ko'));
                      console.log('📊 투표 현황 모달 최종 참여자:', participantList);
                      return `투표 참여 인원: ${participantList.join(', ')}`;
                    })()}
                    placement="top"
                    hasArrow
                    bg="purple.600"
                    color="white"
                    fontSize="sm"
                    borderRadius="md"
                    px={3}
                    py={2}
                  >
                    <Text fontSize={{ base: "xs", md: "sm" }} fontWeight="medium"  textAlign={{ base: "center", sm: "left" }}>
                      투표 참여자: 
                      <Badge bg="purple.600" color="white" fontSize={{ base: "xs", md: "sm" }} px={1} py={0.5} borderRadius="md" ml={1}>
                        {(() => {
                          // 통합 API에서 투표 참여자 수 가져오기
                          if (unifiedVoteData?.activeSession?.totalParticipants) {
                            return unifiedVoteData.activeSession.totalParticipants;
                          }
                          return 0;
                        })()}명
                      </Badge>
                    </Text>
                  </Tooltip>
                  
                  <Tooltip 
                    label={(() => {
                      if (!voteResults || !voteResults.voteSession || !voteResults.voteSession.votes) return '투표 데이터가 없습니다.';
                      
                      // 실제 회원 수
                      const totalMembers = allMembers.length;
                      
                      // 투표에 참여한 고유 인원 수 (실제 회원만)
                      const participants = new Set<number>();
                      voteResults.voteSession.votes.forEach(vote => {
                        const member = allMembers.find(m => m.id === vote.userId);
                        if (member) {
                          participants.add(vote.userId);
                        }
                      });
                      
                      // 투표에 참여하지 않은 인원 수
                      const absentCount = totalMembers - participants.size;
                      
                      if (absentCount === 0) return '모든 회원이 투표에 참여했습니다.';
                      
                      // 투표에 참여하지 않은 인원명 수집
                      const absentMemberIds = allMembers.filter(member => !participants.has(member.id));
                      const absentMemberNames = absentMemberIds.map(member => member.name);
                      
                      return `투표 미참여 인원: ${absentMemberNames.join(', ')}`;
                    })()}
                    placement="top"
                    hasArrow
                    bg="red.600"
                    color="white"
                    fontSize="sm"
                    borderRadius="md"
                    px={3}
                    py={2}
                  >
                    <Text fontSize={{ base: "xs", md: "sm" }} fontWeight="medium"  textAlign={{ base: "center", sm: "left" }}>
                      불참자: 
                      <Badge bg="red.600" color="white" fontSize={{ base: "xs", md: "sm" }} px={1} py={0.5} borderRadius="md" ml={1}>
                        {(() => {
                          // 통합 API에서 불참자 수 계산
                          console.log('🔍 불참자 수 계산:', {
                            allMembers: unifiedVoteData?.allMembers?.length || 0,
                            totalParticipants: unifiedVoteData?.activeSession?.totalParticipants || 0,
                            calculated: unifiedVoteData?.allMembers && unifiedVoteData?.activeSession?.totalParticipants 
                              ? unifiedVoteData.allMembers.length - unifiedVoteData.activeSession.totalParticipants 
                              : 0
                          });
                          
                          if (unifiedVoteData?.allMembers && unifiedVoteData?.activeSession?.totalParticipants) {
                            return unifiedVoteData.allMembers.length - unifiedVoteData.activeSession.totalParticipants;
                          }
                          return 0;
                        })()}명
                      </Badge>
                    </Text>
                  </Tooltip>
                </Flex>

                {/* 투표 목록 및 불참 */}
                <VStack spacing={0.5} align="stretch">
                  {getScheduleData.nextWeekVoteData.map((vote, index) => {
                    // 통합 API에서 투표 수 가져오기
                    const voteCount = (() => {
                      if (!unifiedVoteData?.activeSession?.results) return 0;
                      
                      // 날짜 문자열에서 요일 추출
                      const match = vote.date.match(/(\d+)월 (\d+)일\((.+)\)/);
                      if (match) {
                        const dayOfWeek = match[3]; // 월, 화, 수, 목, 금
                        const dayKeys: { [key: string]: string } = {
                          '월': 'MON',
                          '화': 'TUE', 
                          '수': 'WED',
                          '목': 'THU',
                          '금': 'FRI'
                        };
                        
                        const dayKey = dayKeys[dayOfWeek];
                        if (dayKey && unifiedVoteData.activeSession.results[dayKey]) {
                          return unifiedVoteData.activeSession.results[dayKey].count || 0;
                        }
                      }
                      return 0;
                    })();
                    
                    // 기존 getVoteMemberNames 함수 사용
                    console.log('🔍 모달 디버깅:', {
                      voteDate: vote.date,
                      voteCount,
                      unifiedVoteData: unifiedVoteData ? '있음' : '없음',
                      activeSession: unifiedVoteData?.activeSession ? '있음' : '없음',
                      participants: unifiedVoteData?.activeSession?.participants?.length || 0
                    });
                    
                    // 통합 API에서 직접 투표자 이름 가져오기
                    const memberNames = (() => {
                      if (!unifiedVoteData?.activeSession?.results) return [];
                      
                      // 날짜 문자열에서 요일 추출
                      const match = vote.date.match(/(\d+)월 (\d+)일\((.+)\)/);
                      if (match) {
                        const dayOfWeek = match[3]; // 월, 화, 수, 목, 금
                        const dayKeys: { [key: string]: string } = {
                          '월': 'MON',
                          '화': 'TUE', 
                          '수': 'WED',
                          '목': 'THU',
                          '금': 'FRI'
                        };
                        
                        const dayKey = dayKeys[dayOfWeek];
                        if (dayKey && unifiedVoteData.activeSession.results[dayKey]) {
                          const dayResult = unifiedVoteData.activeSession.results[dayKey];
                          if (dayResult.participants) {
                            return dayResult.participants.map((p: any) => p.userName).filter(Boolean);
                          }
                        }
                      }
                      return [];
                    })();
                    
                    const result = memberNames.length > 0 ? memberNames.join(', ') : '-';
                    console.log('🔍 모달 결과:', { memberNames, result });
                    
                    const maxVoteCount = (() => {
                      if (!unifiedVoteData?.activeSession?.results) return 0;
                      const results = unifiedVoteData.activeSession.results;
                      return Math.max(
                        results.MON?.count || 0,
                        results.TUE?.count || 0,
                        results.WED?.count || 0,
                        results.THU?.count || 0,
                        results.FRI?.count || 0
                      );
                    })();
                    const isMaxVote = voteCount === maxVoteCount && voteCount > 0;
                    
                    console.log('🔍 투표 현황 표시:', {
                      date: vote.date,
                      voteCount,
                      memberNames,
                      maxVoteCount,
                      isMaxVote,
                      voteResults: voteResults ? '있음' : '없음'
                    });
                    
                    return (
                      <Flex 
                        key={index} 
                        justify="space-between" 
                        align="center" 
                        p={2} 
                        border={isMaxVote ? "1px solid" : "0 0 1px 0 solid"}
                        borderColor={isMaxVote ? "purple.600" : "gray.200"}
                        bg={isMaxVote ? "purple.50" : "transparent"}
                        borderRadius="md"
                        _hover={{ bg: isMaxVote ? "purple.100" : "gray.50" }}
                      >
                        <Text 
                          fontSize={{ base: "xs", md: "sm" }} 
                          textAlign="center" 
                          w="20%" 
                          fontWeight={isMaxVote ? "bold" : "normal"}
                          color={(() => {
                            // 공휴일 체크
                            const match = vote.date.match(/(\d+)월 (\d+)일\((.+)\)/);
                            if (match) {
                              const month = parseInt(match[1]);
                              const day = parseInt(match[2]);
                              const dateString = `2025-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                              const holidays: Record<string, string> = {
                                '2025-01-01': '신정',
                                '2025-02-09': '설날',
                                '2025-02-10': '설날',
                                '2025-02-11': '설날',
                                '2025-03-01': '삼일절',
                                '2025-05-05': '어린이날',
                                '2025-05-15': '부처님오신날',
                                '2025-06-06': '현충일',
                                '2025-08-15': '광복절',
                                '2025-09-28': '추석',
                                '2025-09-29': '추석',
                                '2025-09-30': '추석',
                                '2025-10-03': '개천절',
                                '2025-10-09': '한글날',
                                '2025-12-25': '크리스마스'
                              };
                              return holidays[dateString] ? '#e53e3e' : 'inherit';
                            }
                            return 'inherit';
                          })()}
                        >
                          {vote.date}
                        </Text>
                        <Badge 
                          bg={isMaxVote ? "purple.600" : (voteCount === 0 ? "gray.200" : "purple.300")}
                          color={isMaxVote ? "white" : (voteCount === 0 ? "gray.600" : "white")}
                          variant="solid" 
                          borderRadius="full" 
                          px={{ base: 1, md: 2 }} 
                          py={{ base: 0.5, md: 1 }} 
                          fontSize={{ base: "2xs", md: "xs" }}
                          w={{ base: "32px", md: "36px" }}
                          h={{ base: "20px", md: "22px" }}
                          display="flex"
                          alignItems="center"
                          justifyContent="center"
                          flexShrink={0}
                          textAlign="center"
                          fontWeight={isMaxVote ? "bold" : "normal"}
                        >
                          {(() => {
                            // 공휴일 체크
                            const match = vote.date.match(/(\d+)월 (\d+)일\((.+)\)/);
                            if (match) {
                              const month = parseInt(match[1]);
                              const day = parseInt(match[2]);
                              const dateString = `2025-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                              const holidays: Record<string, string> = {
                                '2025-01-01': '신정',
                                '2025-02-09': '설날',
                                '2025-02-10': '설날',
                                '2025-02-11': '설날',
                                '2025-03-01': '삼일절',
                                '2025-05-05': '어린이날',
                                '2025-05-15': '부처님오신날',
                                '2025-06-06': '현충일',
                                '2025-08-15': '광복절',
                                '2025-09-28': '추석',
                                '2025-09-29': '추석',
                                '2025-09-30': '추석',
                                '2025-10-03': '개천절',
                                '2025-10-09': '한글날',
                                '2025-12-25': '크리스마스'
                              };
                              return holidays[dateString] ? '-' : `${voteCount}명`;
                            }
                            return `${voteCount}명`;
                          })()}
                        </Badge>
                        <Box w="10%" textAlign="center" display="flex" justifyContent="center" alignItems="center">
                          {isMaxVote && (
                            <Badge 
                              bg="transparent"
                              color="purple.600"
                              border="1px solid"
                              borderColor="purple.600"
                              borderRadius="md"
                              fontSize="2xs"
                              px={1}
                              py={0.5}
                              fontWeight="bold"
                            >
                              최다
                            </Badge>
                          )}
                        </Box>
                        <Text 
                          fontSize={{ base: "xs", md: "sm" }} 
                          color="gray.600" 
                          textAlign="center" 
                          w="55%" 
                          noOfLines={1}
                          fontWeight={isMaxVote ? "bold" : "normal"}
                        >
                          {result}
                        </Text>
                      </Flex>
                    );
                  })}
                  
                  {/* 불참 항목 - 실제 불참 투표가 있는 경우만 표시 */}
                  {(voteResults.voteResults['불참'] || 0) > 0 && (
                    <Flex 
                      justify="space-between" 
                      align="center" 
                      p={2} 
                      borderBottom="1px solid" 
                      borderColor="gray.200"
                      bg="red.50"
                      borderRadius="md"
                      _hover={{ bg: "red.100" }}
                    >
                    <Text fontSize={{ base: "xs", md: "sm" }} textAlign="center" w="20%" fontWeight="normal">불참</Text>
                    <Badge 
                      bg="red.500"
                      color="white"
                      variant="solid" 
                      borderRadius="full" 
                      px={{ base: 1, md: 2 }} 
                      py={{ base: 0.5, md: 1 }} 
                      fontSize={{ base: "2xs", md: "xs" }}
                      w={{ base: "32px", md: "36px" }}
                      h={{ base: "20px", md: "22px" }}
                      display="flex"
                      alignItems="center"
                      justifyContent="center"
                      flexShrink={0}
                      textAlign="center"
                      fontWeight={(() => {
                        const absentCount = voteResults.voteResults['불참'] || 0;
                        const maxVoteCount = Math.max(...Object.values(voteResults.voteResults).filter(val => val > 0), 0);
                        return absentCount === maxVoteCount && absentCount > 0 ? "bold" : "normal";
                      })()}
                    >
                      {voteResults.voteResults['불참'] || 0}명
                    </Badge>
                    <Box w="10%" textAlign="center">
                      {/* 최다 뱃지 공간 */}
                    </Box>
                    <Text fontSize={{ base: "xs", md: "sm" }} color="gray.600" textAlign="center" w="55%">
                      {(() => {
                        const absentCount = voteResults.voteResults['불참'] || 0;
                        if (absentCount === 0) return '-';
                        
                        // 불참한 인원명 가져오기
                        const absentMembers = getAbsentMemberNames(voteResults, null);
                        return absentMembers.length > 0 ? absentMembers.join(', ') : '-';
                      })()}
                    </Text>
                  </Flex>
                  )}
                </VStack>

                {/* 댓글 섹션 */}
                <VStack spacing={{ base: 1, md: 2 }} align="stretch">
                  <Text fontSize={{ base: "xs", md: "sm" }} fontWeight="bold" color="gray.700">
                    댓글
                  </Text>
                  
                  {/* 기존 댓글 */}
                  <VStack spacing={1} align="stretch" maxH="120px" overflowY="auto">
                    {comments.map((comment, index) => (
                      <Box key={index} p={{ base: 1, md: 1.5 }} bg="gray.50" borderRadius="md">
                        {editingCommentIndex === index ? (
                          // 수정 모드
                          <VStack spacing={2} align="stretch">
                            <Input
                              value={editCommentText}
                              onChange={(e) => setEditCommentText(e.target.value)}
                              size="sm"
                              h="24px"
                            />
                            <Flex gap={2} justify="flex-end">
                              <Button
                                size="xs"
                                colorScheme="blue"
                                onClick={() => handleSaveEditComment(index)}
                                h="20px"
                              >
                                저장
                              </Button>
                              <Button
                                size="xs"
                                variant="outline"
                                onClick={() => setEditingCommentIndex(null)}
                                h="20px"
                              >
                                취소
                              </Button>
                            </Flex>
                          </VStack>
                        ) : (
                          // 일반 표시 모드
                          <Flex justify="space-between" align="center">
                            <Text fontSize={{ base: "2xs", md: "xs" }} color="gray.600" flex="1">
                              {comment.text}
                            </Text>
                            <Flex align="center" gap={2} flexShrink={0}>
                              <Text fontSize={{ base: "2xs", md: "xs" }} fontWeight="medium" color="gray.700">
                                {comment.user}
                              </Text>
                              <Text fontSize={{ base: "2xs", md: "xs" }} color="gray.500">
                                {comment.date}
                              </Text>
                              {user && comment.user === user.name && (
                                <Flex gap={1}>
                                  <IconButton
                                    aria-label="댓글 수정"
                                    icon={<Icon as={EditIcon} w={3} h={3} />}
                                    size="xs"
                                    variant="ghost"
                                    colorScheme="blue"
                                    onClick={() => handleEditComment(index)}
                                    h="20px"
                                    w="20px"
                                  />
                                  <IconButton
                                    aria-label="댓글 삭제"
                                    icon={<Icon as={DeleteIcon} w={3} h={3} />}
                                    size="xs"
                                    variant="ghost"
                                    colorScheme="red"
                                    onClick={() => handleDeleteComment(index)}
                                    h="20px"
                                    w="20px"
                                  />
                                </Flex>
                              )}
                            </Flex>
                          </Flex>
                        )}
                      </Box>
                    ))}
                  </VStack>

                  {/* 댓글 입력 */}
                  <Flex gap={2} direction={{ base: 'column', sm: 'row' }}>
                    <Input
                      placeholder="댓글을 입력하세요..."
                      size={{ base: "xs", md: "sm" }}
                      flex="1"
                      value={commentText}
                      onChange={(e) => setCommentText(e.target.value)}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter') {
                          handleAddComment();
                        }
                      }}
                      h={{ base: "24px", md: "28px" }}
                      border="2px solid"
                      borderColor="blue.300"
                      _focus={{ borderColor: "blue.500", boxShadow: "0 0 0 1px var(--chakra-colors-blue-500)" }}
                      _hover={{ borderColor: "blue.400" }}
                    />
                    <IconButton
                      aria-label="댓글 작성"
                      icon={<ArrowUpIcon />}
                      size={{ base: "xs", md: "sm" }}
                      colorScheme="blue"
                      onClick={handleAddComment}
                      isDisabled={!commentText.trim()}
                      w={{ base: "100%", sm: "auto" }}
                      h={{ base: "24px", md: "28px" }}
                    />
                  </Flex>
                </VStack>
              </VStack>
            ) : (
              <VStack spacing={4} align="stretch">
                {/* 투표 참여자 및 불참자 정보 */}
                <Flex justify="space-between" align="center" wrap="wrap" gap={2}>
                  <Tooltip 
                    label="투표에 참여한 회원 수"
                    placement="top"
                    hasArrow
                    bg="purple.600"
                    color="white"
                    fontSize="sm"
                    borderRadius="md"
                    px={3}
                    py={2}
                  >
                    <Text fontSize={{ base: "xs", md: "sm" }} fontWeight="medium" textAlign={{ base: "center", sm: "left" }}>
                      투표 참여자: 
                      <Badge bg="purple.600" color="white" fontSize={{ base: "xs", md: "sm" }} px={1} py={0.5} borderRadius="md" ml={1}>
                        {(() => {
                          if (!voteResults || !(voteResults as any).voteSession || !(voteResults as any).voteSession.votes) return '0명';
                          
                          // 현재 세션 ID 계산
                          const currentSessionId = `session_${new Date().toISOString().split('T')[0].replace(/-/g, '_')}`;
                          
                          // 현재 세션의 투표만 필터링
                          const currentSessionVotes = (voteResults as any).voteSession.votes.filter((vote: any) => vote.sessionId === currentSessionId);
                          
                          // 실제 회원 중 투표에 참여한 회원만 계산 (관리자 역할 제외)
                          const currentParticipants = new Set<number>();
                          currentSessionVotes.forEach((vote: any) => {
                            const member = allMembers.find(m => m.id === vote.userId);
                            if (member && (member as any).role !== 'ADMIN') {
                              currentParticipants.add(vote.userId);
                            }
                          });
                          
                          return `${currentParticipants.size}명`;
                        })()}
                      </Badge>
                    </Text>
                  </Tooltip>
                  
                  <Tooltip 
                    label={`투표 미참여 인원: ${allMembers.map(member => member.name).join(', ')}`}
                    placement="top"
                    hasArrow
                    bg="red.600"
                    color="white"
                    fontSize="sm"
                    borderRadius="md"
                    px={3}
                    py={2}
                  >
                    <Text fontSize={{ base: "xs", md: "sm" }} fontWeight="medium" textAlign={{ base: "center", sm: "left" }}>
                      불참자: 
                      <Badge bg="red.600" color="white" fontSize={{ base: "xs", md: "sm" }} px={1} py={0.5} borderRadius="md" ml={1}>
                        {(() => {
                          // 통합 API에서 불참자 수 계산
                          console.log('🔍 불참자 수 계산:', {
                            allMembers: unifiedVoteData?.allMembers?.length || 0,
                            totalParticipants: unifiedVoteData?.activeSession?.totalParticipants || 0,
                            calculated: unifiedVoteData?.allMembers && unifiedVoteData?.activeSession?.totalParticipants 
                              ? unifiedVoteData.allMembers.length - unifiedVoteData.activeSession.totalParticipants 
                              : 0
                          });
                          
                          if (unifiedVoteData?.allMembers && unifiedVoteData?.activeSession?.totalParticipants) {
                            return unifiedVoteData.allMembers.length - unifiedVoteData.activeSession.totalParticipants;
                          }
                          return 0;
                        })()}명
                      </Badge>
                    </Text>
                  </Tooltip>
                </Flex>

                {/* 투표 목록 */}
                <VStack spacing={0.5} align="stretch">
                  {getScheduleData.nextWeekVoteData.map((vote, index) => (
                    <Flex 
                      key={index} 
                      justify="space-between" 
                      align="center" 
                      p={2} 
                      border="0 0 1px 0 solid"
                      borderColor="gray.200"
                      bg="transparent"
                      borderRadius="md"
                      _hover={{ bg: "gray.50" }}
                    >
                      <Text 
                        fontSize={{ base: "xs", md: "sm" }} 
                        textAlign="center" 
                        w="20%" 
                        fontWeight="normal"
                      >
                        {vote.date}
                      </Text>
                      <Badge 
                        bg="gray.200"
                        color="gray.600"
                        variant="solid" 
                        borderRadius="full" 
                        px={{ base: 1, md: 2 }} 
                        py={{ base: 0.5, md: 1 }} 
                        fontSize={{ base: "2xs", md: "xs" }}
                        w={{ base: "32px", md: "36px" }}
                        h={{ base: "20px", md: "22px" }}
                        display="flex"
                        alignItems="center"
                        justifyContent="center"
                        flexShrink={0}
                        textAlign="center"
                        fontWeight="normal"
                      >
                        0명
                      </Badge>
                      <Text 
                        fontSize={{ base: "2xs", md: "xs" }} 
                        color="gray.500" 
                        textAlign="center" 
                        w="60%"
                        fontStyle="italic"
                      >
                        투표 없음
                      </Text>
                    </Flex>
                  ))}
                </VStack>

                {/* 댓글 입력 */}
                <Flex gap={2} direction={{ base: 'column', sm: 'row' }}>
                  <Input
                    placeholder="댓글을 입력하세요..."
                    size={{ base: "xs", md: "sm" }}
                    flex="1"
                    value={commentText}
                    onChange={(e) => setCommentText(e.target.value)}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        handleAddComment();
                      }
                    }}
                    h={{ base: "24px", md: "28px" }}
                    border="2px solid"
                    borderColor="blue.300"
                    _focus={{ borderColor: "blue.500", boxShadow: "0 0 0 1px var(--chakra-colors-blue-500)" }}
                    _hover={{ borderColor: "blue.400" }}
                  />
                  <IconButton
                    aria-label="댓글 작성"
                    icon={<ArrowUpIcon />}
                    size={{ base: "xs", md: "sm" }}
                    colorScheme="blue"
                    onClick={handleAddComment}
                    isDisabled={!commentText.trim()}
                    w={{ base: "100%", sm: "auto" }}
                    h={{ base: "24px", md: "28px" }}
                  />
                </Flex>

                {/* 투표하기 버튼 */}
                <Flex justify="center" mt={4}>
                  <Button
                    colorScheme="blue"
                    size="sm"
                    onClick={() => setShowVoteStatus(false)}
                  >
                    투표하기
                  </Button>
                </Flex>
              </VStack>
            )}
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* 경기정보 모달 */}
      <Modal 
        isOpen={showGameModal} 
        onClose={handleCloseGameModal} 
        size="xs" 
        isCentered
        aria-labelledby="game-detail-modal-title"
        aria-describedby="game-detail-modal-description"
      >
        <ModalOverlay />
        <ModalContent maxW="380px">
          <ModalHeader fontSize="md" pb={2} id="game-detail-modal-title">
            📅 일정 상세정보
          </ModalHeader>
          <ModalCloseButton size="sm" aria-label="경기 상세정보 모달 닫기" />
          <ModalBody pb={4} id="game-detail-modal-description">
            {selectedGameData ? (
              <VStack spacing={3} align="stretch">
                {/* 유형 */}
                <Flex align="center" gap={2}>
                  <Box as="span" fontSize="md">⚽</Box>
                  <Text fontSize="sm" fontWeight="medium">
                    유형: {selectedGameData.eventType || '자체'}
                  </Text>
                </Flex>

                {/* 일시 */}
                <Flex align="center" gap={2}>
                  <Box as="span" fontSize="md">🕐</Box>
                  <Text fontSize="sm" fontWeight="medium">
                    일시: {(() => {
                      if (selectedGameData.date && selectedGameData.time) {
                        const date = new Date(selectedGameData.date);
                        const month = date.getMonth() + 1;
                        const day = date.getDate();
                        const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][date.getDay()];
                        return `${month}월 ${day}일(${dayOfWeek}) ${selectedGameData.time}`;
                      } else if (selectedGameData.date) {
                        const date = new Date(selectedGameData.date);
                        const month = date.getMonth() + 1;
                        const day = date.getDate();
                        const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][date.getDay()];
                        return `${month}월 ${day}일(${dayOfWeek})`;
                      }
                      return '일시 미정';
                    })()}
                  </Text>
                </Flex>

                {/* 장소 */}
                <Flex align="center" justify="space-between">
                  <Flex align="center" gap={2}>
                    <Box as="span" fontSize="md">📍</Box>
                    <Text fontSize="sm" fontWeight="medium">
                      장소: {selectedGameData.location || '장소 미정'}
                    </Text>
                  </Flex>
                  <Button
                    size="xs"
                    height="22px"
                    minW="22px"
                    fontSize="11px"
                    p={0}
                    bg="yellow.400"
                    color="blue.600"
                    onClick={() => {
                      const searchQuery = encodeURIComponent(selectedGameData.location || '');
                      window.open(`https://map.kakao.com/link/search/${searchQuery}`, '_blank');
                    }}
                  >
                    K
                  </Button>
                </Flex>

                {/* 참석자 정보 */}
                <Flex align="center" gap={2}>
                  <Box as="span" fontSize="md">👥</Box>
                  <Text fontSize="sm" fontWeight="medium">
                    참석자 : {(() => {
                      const rawMemberNames = Array.isArray(selectedGameData.memberNames) ? 
                        selectedGameData.memberNames : 
                        (typeof selectedGameData.memberNames === 'string' ? 
                          JSON.parse(selectedGameData.memberNames) : []);
                      const rawSelectedMembers = Array.isArray(selectedGameData.selectedMembers) ? 
                        selectedGameData.selectedMembers : 
                        (typeof selectedGameData.selectedMembers === 'string' ? 
                          JSON.parse(selectedGameData.selectedMembers) : []);

                      // 실제 존재하는 회원만 필터링
                      const validSelectedMembers = rawSelectedMembers.filter((name: string) => {
                        return allMembers.some(member => member.name === name);
                      });

                      const selectedSet = new Set<string>(validSelectedMembers);
                      const namesSet = new Set<string>(rawMemberNames as string[]);

                      const memberCount = validSelectedMembers.length; // 유효한 회원만 계산
                      const mercenaryCount = selectedGameData.mercenaryCount || 0;
                      // 기타: 수기 입력 이름들(회원/용병 제외)
                      let otherCount = 0;
                      namesSet.forEach((name) => {
                        if (typeof name !== 'string') return;
                        if (selectedSet.has(name)) return; // 이미 회원으로 계산
                        if (name.startsWith('용병')) return; // 용병 문구 제외
                        otherCount++;
                      });

                      return memberCount + mercenaryCount + otherCount;
                    })()}명
                  </Text>
                  <Text fontSize="xs" whiteSpace="nowrap">
                    ({(() => {
                      const rawMemberNames = Array.isArray(selectedGameData.memberNames) ? 
                        selectedGameData.memberNames : 
                        (typeof selectedGameData.memberNames === 'string' ? 
                          JSON.parse(selectedGameData.memberNames) : []);
                      const rawSelectedMembers = Array.isArray(selectedGameData.selectedMembers) ? 
                        selectedGameData.selectedMembers : 
                        (typeof selectedGameData.selectedMembers === 'string' ? 
                          JSON.parse(selectedGameData.selectedMembers) : []);

                      // 실제 존재하는 회원만 필터링
                      const validSelectedMembers = rawSelectedMembers.filter((name: string) => {
                        return allMembers.some(member => member.name === name);
                      });

                      const selectedSet = new Set<string>(validSelectedMembers);
                      const namesSet = new Set<string>(rawMemberNames as string[]);

                      const memberCount = validSelectedMembers.length; // 유효한 회원만 계산
                      const mercenaryCount = selectedGameData.mercenaryCount || 0;
                      // 기타: 수기 입력 이름들(회원/용병 제외)
                      let otherCount = 0;
                      namesSet.forEach((name) => {
                        if (typeof name !== 'string') return;
                        if (selectedSet.has(name)) return; // 이미 회원으로 계산
                        if (name.startsWith('용병')) return; // 용병 문구 제외
                        otherCount++;
                      });

                      const parts = [] as Array<{ text: string; color: string }>;
                      if (memberCount > 0) parts.push({ text: `회원 ${memberCount}명`, color: '#004ea8' });
                      if (mercenaryCount > 0) parts.push({ text: `용병 ${mercenaryCount}명`, color: '#000000' });
                      if (otherCount > 0) parts.push({ text: `기타 ${otherCount}명`, color: '#ff6b35' });

                      return parts.length > 0 ? (
                        <span>
                          {parts.map((part, index) => (
                            <span
                              key={index}
                              style={{ color: part.color, fontWeight: '500' }}
                            >
                              {part.text}{index < parts.length - 1 ? ' + ' : ''}
                            </span>
                          ))}
                        </span>
                      ) : '참석자 없음';
                    })()})
                  </Text>
                </Flex>

                {/* 참석자 목록 */}
                {(() => {
                  const rawMemberNames = Array.isArray(selectedGameData.memberNames) ? 
                    selectedGameData.memberNames : 
                    (typeof selectedGameData.memberNames === 'string' ? 
                      JSON.parse(selectedGameData.memberNames) : []);
                  const rawSelectedMembers = Array.isArray(selectedGameData.selectedMembers) ? 
                    selectedGameData.selectedMembers : 
                    (typeof selectedGameData.selectedMembers === 'string' ? 
                      JSON.parse(selectedGameData.selectedMembers) : []);

                  const participants: Array<{name: string, type: 'member' | 'mercenary' | 'other'}> = [];
                  
                  // 실제 존재하는 회원만 필터링
                  const validSelectedMembers = rawSelectedMembers.filter((name: string) => {
                    return allMembers.some(member => member.name === name);
                  });
                  
                  const selectedSet = new Set<string>(validSelectedMembers);
                  const namesSet = new Set<string>(rawMemberNames as string[]);

                  // 회원 배지: 유효한 회원만 표시
                  validSelectedMembers.forEach((name: string) => {
                    participants.push({ name, type: 'member' });
                  });

                  // 용병 배지: 묶음으로 1개 배지
                  const mercenaryCount = selectedGameData.mercenaryCount || 0;
                  if (mercenaryCount > 0) participants.push({ name: `용병 ${mercenaryCount}명`, type: 'mercenary' });

                  // 기타 배지: 수기 입력 이름들(회원/용병 제외)
                  namesSet.forEach((name) => {
                    if (typeof name !== 'string') return;
                    if (selectedSet.has(name)) return; // 이미 회원으로 처리됨
                    if (name.startsWith('용병')) return; // 용병 문구 제외
                    participants.push({ name, type: 'other' });
                  });
                  
                  return participants.length > 0 ? (
                    <Flex wrap="wrap" gap={1} justify="center">
                      {participants.map((participant, index) => (
                        <Badge
                          key={index}
                          bg={
                            participant.type === 'member' ? '#004ea8' : 
                            participant.type === 'mercenary' ? '#000000' : 
                            '#ff6b35'
                          }
                          color="white"
                          variant="solid"
                          borderRadius="full"
                          px={2}
                          py={0.5}
                          fontSize="xs"
                        >
                          {participant.name}
                        </Badge>
                      ))}
                    </Flex>
                  ) : null;
                })()}
              </VStack>
            ) : (
              <Text>데이터를 불러오는 중...</Text>
            )}
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* 정지 해제 요청 모달 */}
      <Modal 
        isOpen={showSuspensionRequestModal} 
        onClose={() => setShowSuspensionRequestModal(false)}
        aria-labelledby="suspension-request-modal-title"
        aria-describedby="suspension-request-modal-description"
      >
        <ModalOverlay />
        <ModalContent>
          <ModalHeader color="#004ea8" id="suspension-request-modal-title">🔓 정지 해제 요청</ModalHeader>
          <ModalCloseButton aria-label="정지 해제 요청 모달 닫기" />
          <ModalBody pb={6} id="suspension-request-modal-description">
            <VStack spacing={4} align="stretch">
              <Text color="gray.700">
                정지 해제를 요청하시는 사유를 자세히 작성해주세요. 
                관리자 검토 후 승인 또는 거절됩니다.
              </Text>
              
              <FormControl>
                <FormLabel color="gray.700" fontWeight="bold">요청 사유</FormLabel>
                <Textarea
                  value={suspensionRequestReason}
                  onChange={(e) => setSuspensionRequestReason(e.target.value)}
                  placeholder="정지 해제를 원하는 구체적인 사유를 작성해주세요..."
                  rows={4}
                  resize="vertical"
                  aria-label="정지 해제 요청 사유 입력"
                  aria-required="true"
                />
              </FormControl>
              
              <HStack spacing={3} justify="flex-end">
                <Button
                  variant="outline"
                  onClick={() => setShowSuspensionRequestModal(false)}
                >
                  취소
      </Button>
                <Button
                  colorScheme="blue"
                  onClick={handleSuspensionRequestSubmit}
                  isDisabled={!suspensionRequestReason.trim()}
                >
                  요청 제출
                </Button>
              </HStack>
  </VStack>
          </ModalBody>
        </ModalContent>
      </Modal>
    </Box>
);
}

