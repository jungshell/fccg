"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("dotenv/config");
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const auth_simple_1 = __importDefault(require("./routes/auth_simple"));
const holiday_1 = __importDefault(require("./routes/holiday"));
const body_parser_1 = __importDefault(require("body-parser"));
const axios_1 = __importDefault(require("axios"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const client_1 = require("@prisma/client");
const app = (0, express_1.default)();
const PORT = process.env.PORT || 4000;
const prisma = new client_1.PrismaClient();
console.log('서버 시작');
// JWT 인증 미들웨어
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    if (!token) {
        return res.status(401).json({ message: '액세스 토큰이 필요합니다.' });
    }
    jsonwebtoken_1.default.verify(token, process.env.JWT_SECRET || 'fc-chalggyeo-secret', (err, user) => {
        if (err) {
            return res.status(403).json({ message: '유효하지 않은 토큰입니다.' });
        }
        req.user = user;
        next();
    });
};
// 미들웨어
app.use((0, cors_1.default)());
// app.use(express.json()); // 기존 코드 주석 처리
app.use(body_parser_1.default.json()); // body-parser로 대체
// 라우트 - authRoutes 사용 (직접 구현한 API보다 먼저 등록)
console.log('authRoutes 등록 시작');
app.use('/api/auth', auth_simple_1.default);
console.log('authRoutes 등록 완료');
// 공휴일 API 라우트 등록
console.log('holidayRoutes 등록 시작');
app.use('/api/holiday', holiday_1.default);
console.log('holidayRoutes 등록 완료');
// 안전망 라우트 제거: authRoutes에서 모든 경로를 처리
// 라우트는 모두 authRoutes에서 처리 (중복 등록 제거)
// 통합 회원 및 경기 정보 조회 API
app.get('/api/auth/members', async (req, res) => {
    try {
        console.log('🔍 통합 API 호출 - 회원 및 경기 정보 조회');
        const { PrismaClient } = require('@prisma/client');
        const prisma = new PrismaClient();
        // 모든 회원 조회 (완전한 정보 포함)
        const members = await prisma.user.findMany({
            select: {
                id: true,
                name: true,
                email: true,
                role: true,
                status: true,
                attendance: true,
                createdAt: true,
                updatedAt: true,
                lastLoginAt: true,
                statusChangedAt: true,
                statusChangeReason: true
            },
            orderBy: {
                createdAt: 'desc'
            }
        });
        // 모든 경기 조회
        const games = await prisma.game.findMany({
            select: {
                id: true,
                date: true,
                location: true,
                gameType: true,
                eventType: true,
                mercenaryCount: true,
                memberNames: true,
                selectedMembers: true,
                autoGenerated: true,
                confirmed: true,
                createdById: true,
                createdAt: true,
                updatedAt: true
            },
            orderBy: {
                date: 'asc'
            }
        });
        console.log('✅ 통합 데이터 조회 성공:', members.length, '명 회원,', games.length, '경기');
        console.log('📋 첫 번째 회원 데이터:', {
            id: members[0]?.id,
            name: members[0]?.name,
            email: members[0]?.email,
            createdAt: members[0]?.createdAt
        });
        const response = {
            members,
            games,
            totalMembers: members.length,
            totalGames: games.length,
            activeMembers: members.filter(m => m.status === 'ACTIVE').length
        };
        console.log('📤 응답 데이터 구조:', {
            membersCount: response.members.length,
            gamesCount: response.games.length,
            firstMemberFields: Object.keys(response.members[0] || {})
        });
        res.json(response);
        await prisma.$disconnect();
    }
    catch (error) {
        console.error('❌ 통합 데이터 조회 API 오류:', error);
        res.status(500).json({ error: '데이터를 가져오는 중 오류가 발생했습니다.' });
    }
});
// 중복/직접 라우트 제거: 통합 및 결과 API는 모두 authRoutes에서 처리
// 프로필 조회 API
app.get('/api/auth/profile', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.userId;
        console.log('🔍 직접 등록된 /api/auth/profile 호출됨, userId:', userId);
        const { PrismaClient } = require('@prisma/client');
        const prisma = new PrismaClient();
        // 사용자 정보 조회
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: {
                id: true,
                email: true,
                name: true,
                role: true,
                phone: true,
                avatarUrl: true,
                status: true,
                createdAt: true,
                updatedAt: true
            }
        });
        if (!user) {
            await prisma.$disconnect();
            return res.status(404).json({ error: '사용자를 찾을 수 없습니다.' });
        }
        // 투표 참여 상세 정보 계산 (직접 구현)
        const fs = require('fs');
        const path = require('path');
        const voteDataPath = path.join(process.cwd(), 'voteData.json');
        let voteData = [];
        if (fs.existsSync(voteDataPath)) {
            const data = fs.readFileSync(voteDataPath, 'utf8');
            voteData = JSON.parse(data);
        }
        // 주간 투표 창(월 00:01 ~ 목 17:00) 계산 - 매주 동일 규칙
        const now = new Date();
        const currentWeekStart = new Date(now);
        // getDay(): 일0 월1 ... 토6 → 이번주 월요일로 이동
        const dow = currentWeekStart.getDay();
        const deltaToMonday = dow === 0 ? -6 : (1 - dow);
        currentWeekStart.setDate(currentWeekStart.getDate() + deltaToMonday);
        currentWeekStart.setHours(0, 1, 0, 0); // 월요일 00:01
        const currentWeekEnd = new Date(currentWeekStart);
        currentWeekEnd.setDate(currentWeekStart.getDate() + 3); // 목요일
        currentWeekEnd.setHours(17, 0, 0, 0); // 목요일 17:00
        // 현재 날짜가 목요일 17:00 이후라면 다음 주 투표 창으로 확장
        if (now > currentWeekEnd) {
            // 다음 주 월요일부터 목요일까지로 확장
            currentWeekStart.setDate(currentWeekStart.getDate() + 7);
            currentWeekEnd.setDate(currentWeekEnd.getDate() + 7);
        }
        // 활성 투표 세션 확인 (현재 주 또는 다음 주)
        const activeVoteSessions = new Set(voteData.map((vote) => vote.sessionId));
        const userVotes = voteData.filter((vote) => vote.userId === userId);
        // 사용자가 이번 주 투표 창 내에서 투표했는지 확인
        const recentUserVotes = userVotes.filter((vote) => {
            const voteDate = new Date(vote.timestamp);
            return voteDate >= currentWeekStart && voteDate < currentWeekEnd;
        });
        console.log('투표 데이터 계산:', {
            userId,
            totalVotes: voteData.length,
            userVotes: userVotes.length,
            recentUserVotes: recentUserVotes.length,
            activeSessions: Array.from(activeVoteSessions),
            weekRange: `${currentWeekStart.toISOString().split('T')[0]} ~ ${currentWeekEnd.toISOString().split('T')[0]}`
        });
        // 헤더 투표율 계산 - DB 기준으로 정확히 계산
        const prismaClient = new PrismaClient();
        const totalVoteSessions = await prismaClient.voteSession.count();
        const participatedSessions = await prismaClient.vote.count({ where: { userId } });
        // 세션 상세 정보 조회 (투표율 근거 제공)
        const allSessions = await prismaClient.voteSession.findMany({
            orderBy: { createdAt: 'desc' },
            include: { votes: { where: { userId } } }
        });
        const sessionDetails = allSessions.map((session) => ({
            id: session.id,
            weekStartDate: session.weekStartDate,
            isActive: session.isActive,
            isCompleted: session.isCompleted,
            userParticipated: session.votes.length > 0,
            createdAt: session.createdAt
        }));
        const voteDetails = {
            total: totalVoteSessions,
            participated: participatedSessions,
            missed: Math.max(0, totalVoteSessions - participatedSessions),
            sessions: sessionDetails
        };
        // 디버그 로그 (전체 투표 세션 기준)
        console.log('전체 투표 세션 기준(DB):', {
            totalVoteSessions,
            participatedSessions,
            sessionDetails: sessionDetails.map((s) => ({
                id: s.id,
                weekStart: s.weekStartDate,
                participated: s.userParticipated,
                status: s.isActive ? 'active' : (s.isCompleted ? 'completed' : 'pending')
            }))
        });
        // 헤더 투표율: 전체 투표 세션 중 참여한 비율
        const voteAttendance = totalVoteSessions > 0 ? Math.round((participatedSessions / totalVoteSessions) * 100) : 0;
        // 경기 참여 상세 정보 계산 (직접 구현)
        const allGames = await prismaClient.game.findMany();
        const participatedGames = allGames.filter((game) => {
            try {
                const memberNames = JSON.parse(game.memberNames || '[]');
                const selectedMembers = JSON.parse(game.selectedMembers || '[]');
                return memberNames.includes(user.name) || selectedMembers.includes(user.name);
            }
            catch (error) {
                return false;
            }
        });
        const gameDetails = {
            total: allGames.length,
            participated: participatedGames.length,
            missed: Math.max(0, allGames.length - participatedGames.length)
        };
        console.log('투표율 계산:', {
            total: voteDetails.total,
            participated: voteDetails.participated,
            voteAttendance
        });
        // 경기 참여율 계산
        const gameAttendance = gameDetails.total > 0 ?
            Math.round((gameDetails.participated / gameDetails.total) * 100) : 0;
        const profileData = {
            ...user,
            voteAttendance,
            attendance: gameAttendance,
            voteDetails,
            gameDetails
        };
        console.log('✅ 프로필 조회 성공:', profileData);
        res.json(profileData);
        await prismaClient.$disconnect();
    }
    catch (error) {
        console.error('❌ 프로필 조회 오류:', error);
        res.status(500).json({ error: '프로필을 가져오는 중 오류가 발생했습니다.' });
    }
});
// 투표 데이터 로드 함수
function loadVoteData() {
    try {
        const fs = require('fs');
        const path = require('path');
        const voteDataPath = path.join(process.cwd(), 'backend/voteData.json');
        console.log('투표 데이터 파일 경로:', voteDataPath);
        if (fs.existsSync(voteDataPath)) {
            const data = fs.readFileSync(voteDataPath, 'utf8');
            const parsedData = JSON.parse(data);
            console.log('투표 데이터 로드 성공:', parsedData.length, '개');
            return parsedData;
        }
        else {
            console.log('투표 데이터 파일이 존재하지 않음:', voteDataPath);
            return [];
        }
    }
    catch (error) {
        console.error('투표 데이터 파일 읽기 오류:', error);
        return [];
    }
}
// 투표 데이터 API
app.get('/api/votes', (req, res) => {
    try {
        console.log('🔍 투표 데이터 API 호출됨');
        const fs = require('fs');
        const path = require('path');
        const voteDataPath = path.join(process.cwd(), 'voteData.json');
        console.log('투표 데이터 파일 경로:', voteDataPath);
        if (fs.existsSync(voteDataPath)) {
            const data = fs.readFileSync(voteDataPath, 'utf8');
            const parsedData = JSON.parse(data);
            console.log('투표 데이터 로드 성공:', parsedData.length, '개');
            res.json(parsedData);
        }
        else {
            console.log('투표 데이터 파일이 존재하지 않음:', voteDataPath);
            res.json([]);
        }
    }
    catch (error) {
        console.error('투표 데이터 로드 오류:', error);
        res.status(500).json({ error: '투표 데이터를 불러올 수 없습니다.' });
    }
});
// 멤버 통계 API
app.get('/api/auth/members/stats', authenticateToken, async (req, res) => {
    try {
        const userId = req.user?.userId;
        if (!userId) {
            return res.status(401).json({ error: '인증이 필요합니다.' });
        }
        // 전체 멤버 수
        const totalMembers = await prisma.user.count({
            where: { status: 'ACTIVE' }
        });
        // 활성 멤버 수
        const activeMembers = await prisma.user.count({
            where: { status: 'ACTIVE' }
        });
        // 이번 주 경기 수
        const now = new Date();
        const startOfWeek = new Date(now);
        startOfWeek.setDate(now.getDate() - now.getDay() + 1); // 월요일
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6); // 일요일
        const thisWeekGames = await prisma.game.count({
            where: {
                date: {
                    gte: startOfWeek,
                    lte: endOfWeek
                }
            }
        });
        // 다음 주 투표 세션
        const nextWeekVote = await prisma.voteSession.findFirst({
            where: {
                isActive: true
            }
        });
        const stats = {
            totalMembers,
            activeMembers,
            thisWeekGames,
            nextWeekVote: nextWeekVote ? {
                id: nextWeekVote.id,
                weekStartDate: nextWeekVote.weekStartDate,
                endTime: nextWeekVote.endTime,
                isActive: nextWeekVote.isActive
            } : null
        };
        console.log('📊 멤버 통계 조회:', stats);
        res.json(stats);
    }
    catch (error) {
        console.error('❌ 멤버 통계 조회 오류:', error);
        res.status(500).json({ error: '통계 조회 중 오류가 발생했습니다.' });
    }
});
// 투표 재설정 API (인증 필요)
app.delete('/api/votes/reset', authenticateToken, async (req, res) => {
    try {
        const userId = req.user?.userId;
        console.log('🗑️ 투표 재설정 API 호출됨:', { userId });
        if (!userId) {
            return res.status(401).json({ error: '인증이 필요합니다.' });
        }
        // 투표 데이터 파일에서 해당 사용자의 투표 삭제
        const fs = require('fs');
        const path = require('path');
        const voteDataPath = path.join(process.cwd(), 'voteData.json');
        let voteData = [];
        if (fs.existsSync(voteDataPath)) {
            const data = fs.readFileSync(voteDataPath, 'utf8');
            voteData = JSON.parse(data);
        }
        // 해당 사용자의 투표 데이터 삭제
        const originalLength = voteData.length;
        voteData = voteData.filter(vote => vote.userId !== userId);
        const deletedCount = originalLength - voteData.length;
        // 파일에 저장
        fs.writeFileSync(voteDataPath, JSON.stringify(voteData, null, 2));
        console.log('✅ 투표 재설정 성공:', { userId, deletedCount });
        res.json({ message: '투표가 재설정되었습니다.', deletedCount });
    }
    catch (error) {
        console.error('❌ 투표 재설정 오류:', error);
        res.status(500).json({ error: '투표 재설정 중 오류가 발생했습니다.' });
    }
});
// 투표 제출 API (인증 필요) - 데이터베이스 저장
app.post('/api/votes', authenticateToken, async (req, res) => {
    try {
        const userId = req.user?.userId;
        const { selectedDays, timestamp } = req.body;
        console.log('🗳️ 투표 제출 API 호출됨:', {
            userId,
            selectedDays,
            timestamp,
            userFromToken: req.user
        });
        if (!userId) {
            console.log('❌ 투표 제출 실패: userId 없음');
            return res.status(401).json({ error: '인증이 필요합니다.' });
        }
        if (!selectedDays || !Array.isArray(selectedDays)) {
            return res.status(400).json({ error: '선택된 날짜가 필요합니다.' });
        }
        console.log('🗳️ 투표 제출:', { userId, selectedDays, timestamp });
        const prismaClient = new client_1.PrismaClient();
        // 1. 현재 활성 투표 세션 찾기
        const activeSession = await prismaClient.voteSession.findFirst({
            where: {
                isActive: true,
                isCompleted: false
            }
        });
        if (!activeSession) {
            await prismaClient.$disconnect();
            return res.status(400).json({ error: '활성 투표 세션이 없습니다.' });
        }
        // 2. 기존 투표가 있는지 확인
        const existingVote = await prismaClient.vote.findFirst({
            where: {
                userId: userId,
                voteSessionId: activeSession.id
            }
        });
        let voteResult;
        if (existingVote) {
            // 기존 투표 업데이트
            voteResult = await prismaClient.vote.update({
                where: { id: existingVote.id },
                data: {
                    selectedDays: JSON.stringify(selectedDays),
                    updatedAt: new Date()
                }
            });
            console.log('✅ 기존 투표 업데이트:', voteResult);
        }
        else {
            // 새로운 투표 생성
            voteResult = await prismaClient.vote.create({
                data: {
                    userId: userId,
                    voteSessionId: activeSession.id,
                    selectedDays: JSON.stringify(selectedDays),
                    createdAt: new Date(),
                    updatedAt: new Date()
                }
            });
            console.log('✅ 새로운 투표 생성:', voteResult);
        }
        // 3. 파일에도 백업 저장 (호환성 유지)
        const fs = require('fs');
        const path = require('path');
        const voteDataPath = path.join(process.cwd(), 'voteData.json');
        let voteData = [];
        if (fs.existsSync(voteDataPath)) {
            const data = fs.readFileSync(voteDataPath, 'utf8');
            voteData = JSON.parse(data);
        }
        // 기존 투표 제거 후 새 투표 추가
        voteData = voteData.filter((vote) => vote.userId !== userId);
        voteData.push({
            id: voteResult.id,
            userId: userId,
            selectedDays: selectedDays,
            timestamp: voteResult.createdAt.toISOString(),
            sessionId: activeSession.id
        });
        fs.writeFileSync(voteDataPath, JSON.stringify(voteData, null, 2));
        await prismaClient.$disconnect();
        console.log('✅ 투표 데이터 저장 성공 (DB + 파일):', voteResult);
        res.json({
            message: '투표가 성공적으로 저장되었습니다.',
            vote: {
                id: voteResult.id,
                userId: userId,
                selectedDays: selectedDays,
                sessionId: activeSession.id,
                isUpdate: !!existingVote
            }
        });
    }
    catch (error) {
        console.error('❌ 투표 제출 오류:', error);
        res.status(500).json({ error: '투표 제출 중 오류가 발생했습니다.' });
    }
});
console.log('긴급 수정: 직접 API 등록 완료');
// authRoutes 테스트
app.get('/api/auth-test', (req, res) => {
    res.json({ message: 'authRoutes 테스트 성공!', timestamp: new Date().toISOString() });
});
console.log('✅ authRoutes 테스트 라우트 등록 완료: /api/auth-test');
// 중복된 API 제거 - authRoutes에서 제공됨
// 중복된 회원 추가 API 제거 - authRoutes에서 제공됨
// 중복된 회원 수정 API 제거 - authRoutes에서 제공됨
// 중복된 회원 삭제 API 제거 - authRoutes에서 제공됨
// 중복된 비밀번호 초기화 API 제거 - authRoutes에서 제공됨
// 중복된 긴급 회원 관리 API 제거 - authRoutes에서 제공됨
// 주석 처리된 중복 API 제거됨
// 카카오맵 장소 검색 API - 직접 등록
app.get('/api/auth/search-location', async (req, res) => {
    try {
        const { query } = req.query;
        console.log('🔍 장소 검색 요청:', query);
        if (!query || typeof query !== 'string' || query.trim().length === 0) {
            console.log('❌ 유효하지 않은 검색어:', query);
            return res.status(400).json({ error: '유효한 검색어가 필요합니다.' });
        }
        // 검색어 길이 제한 (너무 긴 요청 방지)
        if (query.length > 100) {
            console.log('❌ 검색어가 너무 김:', query.length);
            return res.status(400).json({ error: '검색어는 100자 이하여야 합니다.' });
        }
        // 카카오맵 API 키 (환경변수에서 읽기, 없으면 기본값 사용)
        const KAKAO_API_KEY = process.env.KAKAO_API_KEY || '4413813ca702d0fb6239ae38d9202d7e';
        if (!KAKAO_API_KEY) {
            console.log('❌ 카카오맵 API 키가 설정되지 않음');
            return res.status(500).json({ error: 'API 키가 설정되지 않았습니다.' });
        }
        console.log('🌐 카카오맵 API 호출 시작...');
        console.log('📡 요청 URL:', 'https://dapi.kakao.com/v2/local/search/keyword.json');
        console.log('📝 검색어:', query.toString());
        // 카카오맵 API 호출
        const response = await axios_1.default.get('https://dapi.kakao.com/v2/local/search/keyword.json', {
            headers: {
                'Authorization': `KakaoAK ${KAKAO_API_KEY}`
            },
            params: {
                query: query.toString(),
                size: 10
            }
        });
        console.log('✅ 카카오맵 API 응답 성공:', response.status);
        console.log('📊 검색 결과 수:', response.data.documents?.length || 0);
        res.json(response.data);
    }
    catch (error) {
        console.error('❌ 장소 검색 오류:', error);
        if (error.response) {
            console.error('🚫 API 응답 오류:', error.response.status, error.response.data);
        }
        res.status(500).json({ error: '장소 검색 중 오류가 발생했습니다.' });
    }
});
// 경기 관리 API
// 중복된 경기 생성 API 제거 - authRoutes에서 제공됨
// 게임 조회/수정/삭제는 authRoutes(auth_simple)에서만 처리 (중복 제거)
// 중복된 경기 삭제/자동생성 API 제거 - authRoutes에서 제공됨
// 중복된 경기 수정 API 제거 - authRoutes에서 제공됨
// 비밀번호 변경 API는 authController에서 처리
// 중복된 프로필 수정 API 제거 - authRoutes에서 제공됨
// 로그인 라우트 - authRoutes로 이동됨
// app.post('/api/auth/login', ...
// 자동화 기능 제거됨 - 수동 관리로 전환
// 자동화 기능 제거됨 - 수동 관리로 전환
// 대시보드 통계 API 추가
// 중복된 통계 API 제거 - authRoutes에서 제공됨
// 중복된 API 제거됨 - /api/auth/members로 통합
// 중복된 통합 API 제거 - authRoutes에서 제공됨
// 중복된 프로필 API 제거 - authRoutes에서 제공됨
// 투표 데이터 로드 함수
function loadVoteData() {
    try {
        const fs = require('fs');
        const path = require('path');
        const voteDataPath = path.join(__dirname, 'voteData.json');
        if (fs.existsSync(voteDataPath)) {
            const data = fs.readFileSync(voteDataPath, 'utf8');
            return JSON.parse(data);
        }
        else {
            return [];
        }
    }
    catch (error) {
        console.error('투표 데이터 파일 읽기 오류:', error);
        return [];
    }
}
// 투표 데이터 API
// 중복된 투표 데이터 API 제거 - authRoutes에서 제공됨
// 회원 상태 자동 체크 API
app.post('/api/admin/check-member-status', authenticateToken, async (req, res) => {
    try {
        const userId = req.user?.userId;
        const user = await prisma.user.findUnique({ where: { id: userId } });
        if (!user || (user.role !== 'ADMIN' && user.role !== 'SUPER_ADMIN')) {
            return res.status(403).json({ error: '관리자 권한이 필요합니다.' });
        }
        const { checkMemberStatusRules } = require('./controllers/authController');
        await checkMemberStatusRules();
        res.json({ message: '회원 상태 체크가 완료되었습니다.' });
    }
    catch (error) {
        console.error('회원 상태 체크 API 오류:', error);
        res.status(500).json({ error: '회원 상태 체크 중 오류가 발생했습니다.' });
    }
});
console.log('✅ 회원 상태 체크 API 등록 완료: /api/admin/check-member-status');
console.log('✅ 비밀번호 변경 API 등록 완료: /api/auth/change-password');
// 비밀번호 변경 API
app.put('/api/auth/change-password', authenticateToken, async (req, res) => {
    try {
        const userId = req.user?.userId;
        const { newPassword } = req.body;
        if (!userId) {
            return res.status(401).json({ error: '인증이 필요합니다.' });
        }
        if (!newPassword || newPassword.length < 6) {
            return res.status(400).json({ error: '비밀번호는 최소 6자 이상이어야 합니다.' });
        }
        const bcrypt = require('bcrypt');
        const hashedPassword = await bcrypt.hash(newPassword, 10);
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { password: hashedPassword }
        });
        res.json({
            message: '비밀번호가 변경되었습니다.',
            user: {
                id: updatedUser.id,
                email: updatedUser.email,
                name: updatedUser.name,
                role: updatedUser.role
            }
        });
    }
    catch (error) {
        console.error('비밀번호 변경 오류:', error);
        res.status(500).json({ error: '서버 오류가 발생했습니다.' });
    }
});
// 간단한 테스트 API
app.get('/api/test', (req, res) => {
    res.json({ message: '테스트 API가 작동합니다!', timestamp: new Date().toISOString() });
});
console.log('✅ 테스트 API 등록 완료: /api/test');
// 로그인 API 직접 구현
// 중복된 로그인/회원가입 API 제거 - authRoutes에서 제공됨
// 자동화 기능 제거됨 - 수동 관리로 전환
console.log('✅ 회원 상태 자동 체크 스케줄러 설정 완료: 매일 오전 9시');
// 중복된 경기 수정/삭제 API 제거됨 (auth_simple 사용)
app.listen(PORT, () => {
    console.log(`서버가 ${PORT}번 포트에서 실행 중`);
});
