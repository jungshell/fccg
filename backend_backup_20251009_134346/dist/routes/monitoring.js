"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const client_1 = require("@prisma/client");
const transaction_1 = require("../utils/transaction");
const logger_1 = require("../utils/logger");
const router = express_1.default.Router();
const prisma = new client_1.PrismaClient();
// 시스템 상태 조회
router.get('/status', async (req, res) => {
    try {
        const startTime = Date.now();
        // 데이터베이스 연결 상태 확인
        const dbConnected = await (0, transaction_1.checkDatabaseConnection)();
        // 기본 시스템 정보
        const systemInfo = {
            uptime: process.uptime(),
            memory: process.memoryUsage(),
            cpu: process.cpuUsage(),
            platform: process.platform,
            nodeVersion: process.version,
            environment: process.env.NODE_ENV || 'development',
        };
        // 데이터베이스 통계
        let dbStats = null;
        if (dbConnected) {
            try {
                const [userCount, gameCount, voteCount] = await Promise.all([
                    prisma.user.count(),
                    prisma.game.count(),
                    prisma.vote.count(),
                ]);
                dbStats = {
                    users: userCount,
                    games: gameCount,
                    votes: voteCount,
                };
            }
            catch (error) {
                console.error('데이터베이스 통계 조회 실패:', error);
            }
        }
        const responseTime = Date.now() - startTime;
        const status = {
            status: dbConnected ? 'healthy' : 'unhealthy',
            timestamp: new Date().toISOString(),
            responseTime: `${responseTime}ms`,
            system: systemInfo,
            database: {
                connected: dbConnected,
                stats: dbStats,
            },
        };
        (0, logger_1.logSystemEvent)('System Status Check', { responseTime, dbConnected });
        const statusCode = dbConnected ? 200 : 503;
        res.status(statusCode).json(status);
    }
    catch (error) {
        console.error('시스템 상태 조회 오류:', error);
        res.status(500).json({
            status: 'error',
            timestamp: new Date().toISOString(),
            error: 'System status check failed',
        });
    }
});
// 사용자 통계 조회
router.get('/stats/users', async (req, res) => {
    try {
        const stats = await prisma.user.groupBy({
            by: ['status', 'role'],
            _count: {
                id: true,
            },
        });
        const totalUsers = await prisma.user.count();
        const activeUsers = await prisma.user.count({
            where: { status: 'ACTIVE' },
        });
        res.json({
            total: totalUsers,
            active: activeUsers,
            byStatus: stats.reduce((acc, stat) => {
                acc[stat.status] = (acc[stat.status] || 0) + stat._count.id;
                return acc;
            }, {}),
            byRole: stats.reduce((acc, stat) => {
                acc[stat.role] = (acc[stat.role] || 0) + stat._count.id;
                return acc;
            }, {}),
        });
    }
    catch (error) {
        console.error('사용자 통계 조회 오류:', error);
        res.status(500).json({ error: 'Failed to fetch user statistics' });
    }
});
// 게임 통계 조회
router.get('/stats/games', async (req, res) => {
    try {
        const totalGames = await prisma.game.count();
        const confirmedGames = await prisma.game.count({
            where: { confirmed: true },
        });
        const autoGeneratedGames = await prisma.game.count({
            where: { autoGenerated: true },
        });
        // 최근 30일 게임 통계
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const recentGames = await prisma.game.count({
            where: {
                createdAt: {
                    gte: thirtyDaysAgo,
                },
            },
        });
        res.json({
            total: totalGames,
            confirmed: confirmedGames,
            autoGenerated: autoGeneratedGames,
            recent30Days: recentGames,
        });
    }
    catch (error) {
        console.error('게임 통계 조회 오류:', error);
        res.status(500).json({ error: 'Failed to fetch game statistics' });
    }
});
// 투표 통계 조회
router.get('/stats/votes', async (req, res) => {
    try {
        const totalVotes = await prisma.vote.count();
        const activeSessions = await prisma.voteSession.count({
            where: { isActive: true },
        });
        // 최근 7일 투표 통계
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const recentVotes = await prisma.vote.count({
            where: {
                createdAt: {
                    gte: sevenDaysAgo,
                },
            },
        });
        res.json({
            total: totalVotes,
            activeSessions,
            recent7Days: recentVotes,
        });
    }
    catch (error) {
        console.error('투표 통계 조회 오류:', error);
        res.status(500).json({ error: 'Failed to fetch vote statistics' });
    }
});
// 성능 메트릭 조회
router.get('/metrics', async (req, res) => {
    try {
        const memUsage = process.memoryUsage();
        const cpuUsage = process.cpuUsage();
        res.json({
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
            memory: {
                rss: Math.round(memUsage.rss / 1024 / 1024), // MB
                heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024), // MB
                heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024), // MB
                external: Math.round(memUsage.external / 1024 / 1024), // MB
            },
            cpu: {
                user: cpuUsage.user,
                system: cpuUsage.system,
            },
            node: {
                version: process.version,
                platform: process.platform,
                arch: process.arch,
            },
        });
    }
    catch (error) {
        console.error('메트릭 조회 오류:', error);
        res.status(500).json({ error: 'Failed to fetch metrics' });
    }
});
// 로그 조회 (최근 100개)
router.get('/logs', async (req, res) => {
    try {
        const fs = require('fs');
        const path = require('path');
        const logFile = path.join(process.cwd(), 'logs', 'combined.log');
        if (!fs.existsSync(logFile)) {
            return res.json({ logs: [] });
        }
        const logContent = fs.readFileSync(logFile, 'utf8');
        const logLines = logContent.split('\n').filter(line => line.trim());
        // 최근 100개 로그만 반환
        const recentLogs = logLines.slice(-100).map(line => {
            try {
                return JSON.parse(line);
            }
            catch {
                return { message: line, timestamp: new Date().toISOString() };
            }
        });
        res.json({ logs: recentLogs });
    }
    catch (error) {
        console.error('로그 조회 오류:', error);
        res.status(500).json({ error: 'Failed to fetch logs' });
    }
});
exports.default = router;
