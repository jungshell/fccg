"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleTransactionError = exports.checkDatabaseConnection = exports.voteTransaction = exports.voteSessionTransaction = exports.gameTransaction = exports.executeWithRetry = void 0;
const client_1 = require("@prisma/client");
const prisma = new client_1.PrismaClient();
/**
 * íŠ¸ëœì­ì…˜ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
 * ë°ì´í„° ì¼ê´€ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•œ íŠ¸ëœì­ì…˜ ì²˜ë¦¬
 */
// ì¬ì‹œë„ ë¡œì§ì´ í¬í•¨ëœ íŠ¸ëœì­ì…˜ ì‹¤í–‰
const executeWithRetry = async (operation, maxRetries = 3, delay = 1000) => {
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await operation();
        }
        catch (error) {
            lastError = error;
            console.log(`ğŸ”„ ì‹œë„ ${attempt}/${maxRetries} ì‹¤íŒ¨:`, error);
            if (attempt < maxRetries) {
                // ì§€ìˆ˜ ë°±ì˜¤í”„ë¡œ ëŒ€ê¸° ì‹œê°„ ì¦ê°€
                const waitTime = delay * Math.pow(2, attempt - 1);
                console.log(`â³ ${waitTime}ms í›„ ì¬ì‹œë„...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }
    throw lastError;
};
exports.executeWithRetry = executeWithRetry;
// ê²Œì„ ìƒì„±/ìˆ˜ì • íŠ¸ëœì­ì…˜
const gameTransaction = async (gameData, isUpdate = false) => {
    return await prisma.$transaction(async (tx) => {
        try {
            let game;
            if (isUpdate) {
                // ê¸°ì¡´ ê²Œì„ ì—…ë°ì´íŠ¸
                game = await tx.game.update({
                    where: { id: gameData.id },
                    data: {
                        date: gameData.date,
                        time: gameData.time,
                        location: gameData.location,
                        eventType: gameData.eventType,
                        gameType: gameData.gameType,
                        memberNames: JSON.stringify(gameData.memberNames || []),
                        selectedMembers: JSON.stringify(gameData.selectedMembers || []),
                        mercenaryCount: gameData.mercenaryCount || 0,
                        autoGenerated: false, // ìˆ˜ì • ì‹œ ìë™ìƒì„± í•´ì œ
                        confirmed: true, // ìˆ˜ì • ì‹œ í™•ì • ìƒíƒœë¡œ ë³€ê²½
                        updatedAt: new Date()
                    }
                });
            }
            else {
                // ìƒˆ ê²Œì„ ìƒì„±
                game = await tx.game.create({
                    data: {
                        date: gameData.date,
                        time: gameData.time,
                        location: gameData.location,
                        eventType: gameData.eventType,
                        gameType: gameData.gameType,
                        memberNames: JSON.stringify(gameData.memberNames || []),
                        selectedMembers: JSON.stringify(gameData.selectedMembers || []),
                        mercenaryCount: gameData.mercenaryCount || 0,
                        autoGenerated: false,
                        confirmed: true,
                        createdById: gameData.createdById,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    }
                });
            }
            // ê¸°ì¡´ ì¶œì„ ê¸°ë¡ ì‚­ì œ (ìˆ˜ì • ì‹œ)
            if (isUpdate) {
                await tx.attendance.deleteMany({
                    where: { gameId: game.id }
                });
            }
            // ì¶œì„ ê¸°ë¡ ìƒì„±
            const attendanceRecords = [];
            // ì„ íƒëœ íšŒì›ë“¤
            if (gameData.selectedMembers && gameData.selectedMembers.length > 0) {
                for (const memberId of gameData.selectedMembers) {
                    attendanceRecords.push({
                        gameId: game.id,
                        userId: memberId,
                        status: 'ATTENDING',
                        createdAt: new Date(),
                        updatedAt: new Date()
                    });
                }
            }
            // ìˆ˜ê¸° ì…ë ¥ëœ íšŒì›ë“¤ (ì„ì‹œ ì‚¬ìš©ì ID ì‚¬ìš©)
            if (gameData.memberNames && gameData.memberNames.length > 0) {
                for (const memberName of gameData.memberNames) {
                    attendanceRecords.push({
                        gameId: game.id,
                        userId: -1, // ì„ì‹œ ID (ìˆ˜ê¸° ì…ë ¥)
                        memberName: memberName,
                        status: 'ATTENDING',
                        createdAt: new Date(),
                        updatedAt: new Date()
                    });
                }
            }
            if (attendanceRecords.length > 0) {
                await tx.attendance.createMany({
                    data: attendanceRecords
                });
            }
            // ìë™ìƒì„±ëœ ê²Œì„ì´ í™•ì •ëœ ê²½ìš° ê°™ì€ ì£¼ì˜ ë‹¤ë¥¸ ìë™ìƒì„± ê²Œì„ ì‚­ì œ
            let autoGeneratedGamesDeleted = false;
            if (gameData.autoGenerated || (!isUpdate && gameData.confirmed)) {
                const gameDate = new Date(gameData.date);
                const weekStart = new Date(gameDate);
                weekStart.setDate(gameDate.getDate() - gameDate.getDay() + 1); // ì›”ìš”ì¼
                weekStart.setHours(0, 0, 0, 0);
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6); // ì¼ìš”ì¼
                weekEnd.setHours(23, 59, 59, 999);
                const deletedGames = await tx.game.deleteMany({
                    where: {
                        autoGenerated: true,
                        confirmed: false,
                        date: {
                            gte: weekStart,
                            lte: weekEnd
                        },
                        id: {
                            not: game.id // í˜„ì¬ ê²Œì„ ì œì™¸
                        }
                    }
                });
                autoGeneratedGamesDeleted = deletedGames.count > 0;
                console.log(`ğŸ—‘ï¸ ìë™ìƒì„± ê²Œì„ ${deletedGames.count}ê°œ ì‚­ì œë¨`);
            }
            return {
                game,
                autoGeneratedGamesDeleted
            };
        }
        catch (error) {
            console.error('âŒ ê²Œì„ íŠ¸ëœì­ì…˜ ì‹¤íŒ¨:', error);
            throw error;
        }
    });
};
exports.gameTransaction = gameTransaction;
// íˆ¬í‘œ ì„¸ì…˜ ìƒì„± íŠ¸ëœì­ì…˜
const voteSessionTransaction = async (sessionData) => {
    return await prisma.$transaction(async (tx) => {
        try {
            // ê¸°ì¡´ í™œì„± ì„¸ì…˜ ë¹„í™œì„±í™”
            await tx.voteSession.updateMany({
                where: { isActive: true },
                data: { isActive: false, updatedAt: new Date() }
            });
            // ìƒˆ íˆ¬í‘œ ì„¸ì…˜ ìƒì„±
            const session = await tx.voteSession.create({
                data: {
                    weekStartDate: sessionData.weekStartDate,
                    startTime: sessionData.startTime,
                    endTime: sessionData.endTime,
                    isActive: true,
                    isCompleted: false,
                    createdAt: new Date(),
                    updatedAt: new Date()
                }
            });
            return session;
        }
        catch (error) {
            console.error('âŒ íˆ¬í‘œ ì„¸ì…˜ íŠ¸ëœì­ì…˜ ì‹¤íŒ¨:', error);
            throw error;
        }
    });
};
exports.voteSessionTransaction = voteSessionTransaction;
// íˆ¬í‘œ ìƒì„± íŠ¸ëœì­ì…˜
const voteTransaction = async (voteData) => {
    return await prisma.$transaction(async (tx) => {
        try {
            // ê¸°ì¡´ íˆ¬í‘œ ì‚­ì œ
            await tx.vote.deleteMany({
                where: {
                    userId: voteData.userId,
                    voteSessionId: voteData.voteSessionId
                }
            });
            // ìƒˆ íˆ¬í‘œ ìƒì„±
            const vote = await tx.vote.create({
                data: {
                    userId: voteData.userId,
                    voteSessionId: voteData.voteSessionId,
                    selectedDays: JSON.stringify(voteData.selectedDays),
                    createdAt: new Date(),
                    updatedAt: new Date()
                }
            });
            return vote;
        }
        catch (error) {
            console.error('âŒ íˆ¬í‘œ íŠ¸ëœì­ì…˜ ì‹¤íŒ¨:', error);
            throw error;
        }
    });
};
exports.voteTransaction = voteTransaction;
// ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒíƒœ í™•ì¸
const checkDatabaseConnection = async () => {
    try {
        await prisma.$queryRaw `SELECT 1`;
        return true;
    }
    catch (error) {
        console.error('âŒ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨:', error);
        return false;
    }
};
exports.checkDatabaseConnection = checkDatabaseConnection;
// íŠ¸ëœì­ì…˜ ë¡¤ë°± ì²˜ë¦¬
const handleTransactionError = (error, operation) => {
    console.error(`âŒ ${operation} íŠ¸ëœì­ì…˜ ì‹¤íŒ¨:`, error);
    // íŠ¹ì • ì—ëŸ¬ íƒ€ì…ì— ë”°ë¥¸ ì²˜ë¦¬
    if (error.code === 'P2002') {
        throw new Error('ì¤‘ë³µëœ ë°ì´í„°ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.');
    }
    else if (error.code === 'P2003') {
        throw new Error('ì°¸ì¡°í•˜ëŠ” ë°ì´í„°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }
    else if (error.code === 'P2025') {
        throw new Error('ìš”ì²­í•œ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
    else {
        throw new Error('ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
};
exports.handleTransactionError = handleTransactionError;
