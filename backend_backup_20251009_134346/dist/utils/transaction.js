"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleTransactionError = exports.checkDatabaseConnection = exports.voteTransaction = exports.voteSessionTransaction = exports.gameTransaction = exports.executeWithRetry = void 0;
const client_1 = require("@prisma/client");
const prisma = new client_1.PrismaClient();
/**
 * 트랜잭션 유틸리티 함수들
 * 데이터 일관성을 보장하기 위한 트랜잭션 처리
 */
// 재시도 로직이 포함된 트랜잭션 실행
const executeWithRetry = async (operation, maxRetries = 3, delay = 1000) => {
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await operation();
        }
        catch (error) {
            lastError = error;
            console.log(`🔄 시도 ${attempt}/${maxRetries} 실패:`, error);
            if (attempt < maxRetries) {
                // 지수 백오프로 대기 시간 증가
                const waitTime = delay * Math.pow(2, attempt - 1);
                console.log(`⏳ ${waitTime}ms 후 재시도...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }
    throw lastError;
};
exports.executeWithRetry = executeWithRetry;
// 게임 생성/수정 트랜잭션
const gameTransaction = async (gameData, isUpdate = false) => {
    return await prisma.$transaction(async (tx) => {
        try {
            let game;
            if (isUpdate) {
                // 기존 게임 업데이트
                game = await tx.game.update({
                    where: { id: gameData.id },
                    data: {
                        date: gameData.date,
                        time: gameData.time,
                        location: gameData.location,
                        eventType: gameData.eventType,
                        gameType: gameData.gameType,
                        memberNames: JSON.stringify(gameData.memberNames || []),
                        selectedMembers: JSON.stringify(gameData.selectedMembers || []),
                        mercenaryCount: gameData.mercenaryCount || 0,
                        autoGenerated: false, // 수정 시 자동생성 해제
                        confirmed: true, // 수정 시 확정 상태로 변경
                        updatedAt: new Date()
                    }
                });
            }
            else {
                // 새 게임 생성
                game = await tx.game.create({
                    data: {
                        date: gameData.date,
                        time: gameData.time,
                        location: gameData.location,
                        eventType: gameData.eventType,
                        gameType: gameData.gameType,
                        memberNames: JSON.stringify(gameData.memberNames || []),
                        selectedMembers: JSON.stringify(gameData.selectedMembers || []),
                        mercenaryCount: gameData.mercenaryCount || 0,
                        autoGenerated: false,
                        confirmed: true,
                        createdById: gameData.createdById,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    }
                });
            }
            // 기존 출석 기록 삭제 (수정 시)
            if (isUpdate) {
                await tx.attendance.deleteMany({
                    where: { gameId: game.id }
                });
            }
            // 출석 기록 생성
            const attendanceRecords = [];
            // 선택된 회원들
            if (gameData.selectedMembers && gameData.selectedMembers.length > 0) {
                for (const memberId of gameData.selectedMembers) {
                    attendanceRecords.push({
                        gameId: game.id,
                        userId: memberId,
                        status: 'ATTENDING',
                        createdAt: new Date(),
                        updatedAt: new Date()
                    });
                }
            }
            // 수기 입력된 회원들 (임시 사용자 ID 사용)
            if (gameData.memberNames && gameData.memberNames.length > 0) {
                for (const memberName of gameData.memberNames) {
                    attendanceRecords.push({
                        gameId: game.id,
                        userId: -1, // 임시 ID (수기 입력)
                        memberName: memberName,
                        status: 'ATTENDING',
                        createdAt: new Date(),
                        updatedAt: new Date()
                    });
                }
            }
            if (attendanceRecords.length > 0) {
                await tx.attendance.createMany({
                    data: attendanceRecords
                });
            }
            // 자동생성된 게임이 확정된 경우 같은 주의 다른 자동생성 게임 삭제
            let autoGeneratedGamesDeleted = false;
            if (gameData.autoGenerated || (!isUpdate && gameData.confirmed)) {
                const gameDate = new Date(gameData.date);
                const weekStart = new Date(gameDate);
                weekStart.setDate(gameDate.getDate() - gameDate.getDay() + 1); // 월요일
                weekStart.setHours(0, 0, 0, 0);
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6); // 일요일
                weekEnd.setHours(23, 59, 59, 999);
                const deletedGames = await tx.game.deleteMany({
                    where: {
                        autoGenerated: true,
                        confirmed: false,
                        date: {
                            gte: weekStart,
                            lte: weekEnd
                        },
                        id: {
                            not: game.id // 현재 게임 제외
                        }
                    }
                });
                autoGeneratedGamesDeleted = deletedGames.count > 0;
                console.log(`🗑️ 자동생성 게임 ${deletedGames.count}개 삭제됨`);
            }
            return {
                game,
                autoGeneratedGamesDeleted
            };
        }
        catch (error) {
            console.error('❌ 게임 트랜잭션 실패:', error);
            throw error;
        }
    });
};
exports.gameTransaction = gameTransaction;
// 투표 세션 생성 트랜잭션
const voteSessionTransaction = async (sessionData) => {
    return await prisma.$transaction(async (tx) => {
        try {
            // 기존 활성 세션 비활성화
            await tx.voteSession.updateMany({
                where: { isActive: true },
                data: { isActive: false, updatedAt: new Date() }
            });
            // 새 투표 세션 생성
            const session = await tx.voteSession.create({
                data: {
                    weekStartDate: sessionData.weekStartDate,
                    startTime: sessionData.startTime,
                    endTime: sessionData.endTime,
                    isActive: true,
                    isCompleted: false,
                    createdAt: new Date(),
                    updatedAt: new Date()
                }
            });
            return session;
        }
        catch (error) {
            console.error('❌ 투표 세션 트랜잭션 실패:', error);
            throw error;
        }
    });
};
exports.voteSessionTransaction = voteSessionTransaction;
// 투표 생성 트랜잭션
const voteTransaction = async (voteData) => {
    return await prisma.$transaction(async (tx) => {
        try {
            // 기존 투표 삭제
            await tx.vote.deleteMany({
                where: {
                    userId: voteData.userId,
                    voteSessionId: voteData.voteSessionId
                }
            });
            // 새 투표 생성
            const vote = await tx.vote.create({
                data: {
                    userId: voteData.userId,
                    voteSessionId: voteData.voteSessionId,
                    selectedDays: JSON.stringify(voteData.selectedDays),
                    createdAt: new Date(),
                    updatedAt: new Date()
                }
            });
            return vote;
        }
        catch (error) {
            console.error('❌ 투표 트랜잭션 실패:', error);
            throw error;
        }
    });
};
exports.voteTransaction = voteTransaction;
// 데이터베이스 연결 상태 확인
const checkDatabaseConnection = async () => {
    try {
        await prisma.$queryRaw `SELECT 1`;
        return true;
    }
    catch (error) {
        console.error('❌ 데이터베이스 연결 실패:', error);
        return false;
    }
};
exports.checkDatabaseConnection = checkDatabaseConnection;
// 트랜잭션 롤백 처리
const handleTransactionError = (error, operation) => {
    console.error(`❌ ${operation} 트랜잭션 실패:`, error);
    // 특정 에러 타입에 따른 처리
    if (error.code === 'P2002') {
        throw new Error('중복된 데이터가 존재합니다.');
    }
    else if (error.code === 'P2003') {
        throw new Error('참조하는 데이터가 존재하지 않습니다.');
    }
    else if (error.code === 'P2025') {
        throw new Error('요청한 데이터를 찾을 수 없습니다.');
    }
    else {
        throw new Error('데이터베이스 작업 중 오류가 발생했습니다.');
    }
};
exports.handleTransactionError = handleTransactionError;
