import { 
  Box, 
  Flex, 
  Text, 
  HStack, 
  VStack, 
  Button, 
  Input, 
  Badge, 
  IconButton, 
  Image, 
  SimpleGrid,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  Select,
  Tooltip,
  Divider,
  useToast,
  Textarea
} from '@chakra-ui/react';
import { 
  useState, 
  useRef, 
  useCallback, 
  useEffect,
  useMemo
} from 'react';
import { 
  PlusSquareIcon, 
  DownloadIcon,
  DeleteIcon,
  EditIcon,
  ArrowUpIcon
} from '@chakra-ui/icons';
import { useAuthStore } from '../store/auth';

// 사진 데이터
const photoItems = [
  {
    id: 1,
    type: 'photo',
    src: 'https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=400&q=80',
    date: '2025.06.30.(월)',
    author: '정성인',
    likes: 12,
    comments: 5,
    badge: '+3',
    label: '사진',
    tags: ['경기', '팀', '축구'],
    description: '오늘 경기에서 찍은 멋진 사진들',
    eventType: '매치',
    thumbnail: 'https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=400&q=80',
    isLiked: false,
    commentsList: [
      { id: 1, author: '김철수', text: '정말 멋진 사진이네요!', date: '06.30.' },
      { id: 2, author: '이영희', text: '다음 경기도 화이팅!', date: '06.30.' }
    ]
  },
  {
    id: 2,
    type: 'photo',
    src: 'https://images.unsplash.com/photo-1519125323398-675f0ddb6308?auto=format&fit=crop&w=400&q=80',
    date: '2025.06.29.(일)',
    author: '정성인',
    likes: 8,
    comments: 3,
    badge: '+2',
    label: '사진',
    tags: ['연습', '기술'],
    description: '기술 연습 중',
    eventType: '자체',
    thumbnail: 'https://images.unsplash.com/photo-1519125323398-675f0ddb6308?auto=format&fit=crop&w=400&q=80',
    isLiked: true,
    commentsList: [
      { id: 1, author: '박민수', text: '기술이 많이 늘었네요!', date: '06.29.' }
    ]
  }
];

const eventTypes = [
  { label: '매치', value: 'match' },
  { label: '자체', value: 'practice' },
  { label: '회식', value: 'dinner' },
  { label: '기타', value: 'other' }
];

// 업로드 설정
const UPLOAD_CONFIG = {
  MAX_FILES: 10, // 최대 업로드 파일 수
  MAX_TOTAL_SIZE_MB: 5, // 최대 총 용량 (MB)
  TARGET_FILE_SIZE_MB: 0.5, // 목표 파일당 용량 (MB)
  SUPPORTED_FORMATS: ['image/jpeg', 'image/png', 'image/gif', 'image/webp']
};

// 이미지 압축 함수
const compressImage = (file: File, maxSizeMB: number = 0.5): Promise<string> => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = document.createElement('img');
    
    img.onload = () => {
      try {
        // 원본 크기 유지하되 품질 조정
        canvas.width = img.width;
        canvas.height = img.height;
        
        if (ctx) {
          ctx.drawImage(img, 0, 0);
          
          // 품질을 점진적으로 낮춰가며 용량 조정
          let quality = 0.9;
          let dataUrl = canvas.toDataURL('image/jpeg', quality);
          
          // 목표 크기 (bytes)
          const targetSize = maxSizeMB * 1024 * 1024;
          const currentSize = dataUrl.length * 0.75; // base64는 실제 크기의 약 4/3배
          
          console.log(`압축 시작: 현재 크기 ${(currentSize / (1024 * 1024)).toFixed(2)}MB, 목표 ${maxSizeMB}MB`);
          
          // 용량이 목표보다 크면 품질을 낮춤
          while (dataUrl.length * 0.75 > targetSize && quality > 0.1) {
            quality -= 0.1;
            dataUrl = canvas.toDataURL('image/jpeg', quality);
          }
          
          const finalSize = dataUrl.length * 0.75;
          console.log(`압축 완료: 최종 크기 ${(finalSize / (1024 * 1024)).toFixed(2)}MB, 품질 ${quality}`);
          
          // 메모리 정리
          URL.revokeObjectURL(img.src);
          
          resolve(dataUrl);
        } else {
          reject(new Error('Canvas context를 생성할 수 없습니다.'));
        }
      } catch (error) {
        console.error('압축 중 오류:', error);
        reject(error);
      }
    };
    
    img.onerror = () => {
      URL.revokeObjectURL(img.src);
      reject(new Error('이미지를 로드할 수 없습니다.'));
    };
    
    img.src = URL.createObjectURL(file);
  });
};

// 파일을 base64로 변환하는 함수 (압축 없음)
const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result);
      } else {
        reject(new Error('파일 읽기에 실패했습니다.'));
      }
    };
    
    reader.onerror = () => {
      reject(new Error('파일 읽기 오류가 발생했습니다.'));
    };
    
    reader.readAsDataURL(file);
  });
};

export default function PhotoGalleryPage() {
  const { user } = useAuthStore();
  const [filter, setFilter] = useState('all');
  const [sort, setSort] = useState('latest');
  const [search, setSearch] = useState('');
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [items, setItems] = useState(photoItems);
  const [selectedItem, setSelectedItem] = useState<any>(null);
  const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);
  const [isUploadModalOpen, setIsUploadModalOpen] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [uploadFiles, setUploadFiles] = useState<File[]>([]);
  const [uploadTitle, setUploadTitle] = useState('');
  const [uploadEventType, setUploadEventType] = useState('');
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<any>(null);
  const [isDownloadModalOpen, setIsDownloadModalOpen] = useState(false);
  const [downloadItem, setDownloadItem] = useState<any>(null);
  const [selectedPhotos, setSelectedPhotos] = useState<number[]>([]);
  const [selectedPhotoIndex, setSelectedPhotoIndex] = useState(0);
  const [editingCommentIndex, setEditingCommentIndex] = useState<number | null>(null);
  const [editCommentText, setEditCommentText] = useState('');
  const [isAddPhotoModalOpen, setIsAddPhotoModalOpen] = useState(false);
  const [addPhotoFiles, setAddPhotoFiles] = useState<File[]>([]);
  const [addPhotoEventType, setAddPhotoEventType] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);
  const addPhotoFileInputRef = useRef<HTMLInputElement>(null);
  const toast = useToast();

  // localStorage에서 데이터 로드
  useEffect(() => {
    const savedItems = localStorage.getItem('photoGalleryItems');
    if (savedItems) {
      try {
        const parsedItems = JSON.parse(savedItems);
        setItems(parsedItems);
      } catch (error) {
        console.error('localStorage 데이터 파싱 오류:', error);
        setItems(photoItems);
      }
    } else {
      setItems(photoItems);
    }
  }, []);

  // localStorage 용량 체크 함수
  const checkStorageQuota = (data: string): boolean => {
    try {
      let currentSize = 0;
      for (let key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
          currentSize += localStorage[key].length;
        }
      }
      
      const newDataSize = data.length;
      const totalSize = currentSize + newDataSize;
      const maxSize = 5 * 1024 * 1024; // 5MB
      
      console.log(`현재 크기: ${currentSize}, 새 데이터 크기: ${newDataSize}, 총 크기: ${totalSize}, 최대 크기: ${maxSize}`);
      
      return totalSize < maxSize;
    } catch (error) {
      console.error('저장소 용량 체크 오류:', error);
      return false;
    }
  };

  // 사진 그룹핑 함수
  const groupPhotosByDate = useCallback((photos: any[]) => {
    const groups: { [key: string]: any[] } = {};
    
    photos.forEach(photo => {
      const date = `${photo.author}_${photo.date}`;
      if (!groups[date]) {
        groups[date] = [];
      }
      groups[date].push(photo);
    });
    
    return Object.entries(groups).map(([dateKey, photos]) => {
      if (photos.length === 1) {
        return photos[0];
      } else {
        return {
          ...photos[0],
          isGroup: true,
          groupCount: photos.length,
          groupPhotos: photos
        };
      }
    });
  }, []);

  // 그룹화된 아이템들
  const groupedItems = useMemo(() => {
    return groupPhotosByDate(items);
  }, [items, groupPhotosByDate]);

  // 필터링된 아이템들
  const filteredItems = useMemo(() => {
    let filtered = groupedItems;

    // 타입 필터 (사진만 표시)
    filtered = filtered.filter(item => item.type === 'photo');
    
    // 검색 필터
    if (search) {
      filtered = filtered.filter(item => 
        item.description.toLowerCase().includes(search.toLowerCase()) ||
        item.author.toLowerCase().includes(search.toLowerCase()) ||
        item.tags.some((tag: string) => tag.toLowerCase().includes(search.toLowerCase()))
      );
    }
    
    // 태그 필터
    if (selectedTags.length > 0) {
      filtered = filtered.filter(item => 
        selectedTags.every(tag => item.tags.includes(tag))
      );
    }
    
    return filtered;
  }, [groupedItems, search, selectedTags]);

  // 정렬된 아이템들
  const sortedItems = useMemo(() => {
    let sorted = [...filteredItems];
    
    switch (sort) {
      case 'latest':
        sorted.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
        break;
      case 'oldest':
        sorted.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
        break;
      case 'likes':
        sorted.sort((a, b) => b.likes - a.likes);
        break;
      case 'comments':
        sorted.sort((a, b) => b.comments - a.comments);
        break;
    }
    
    return sorted;
  }, [filteredItems, sort]);

  // 파일 선택 처리 (자동 압축 포함)
  const handleFileSelect = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || []);
    
    // 파일 수 제한 체크
    if (files.length > UPLOAD_CONFIG.MAX_FILES) {
      toast({
        title: '파일 수 초과',
        description: `최대 ${UPLOAD_CONFIG.MAX_FILES}장까지 업로드 가능합니다.`,
        status: 'error',
        duration: 3000,
      });
      return;
    }
    
    // 파일 형식 체크
    const invalidFiles = files.filter(file => !UPLOAD_CONFIG.SUPPORTED_FORMATS.includes(file.type));
    if (invalidFiles.length > 0) {
      toast({
        title: '지원하지 않는 파일 형식',
        description: 'JPG, PNG, GIF, WEBP 형식만 지원됩니다.',
        status: 'error',
        duration: 3000,
      });
      return;
    }
    
    // 총 용량 체크
    const totalSizeMB = files.reduce((sum, file) => sum + file.size / (1024 * 1024), 0);
    if (totalSizeMB > UPLOAD_CONFIG.MAX_TOTAL_SIZE_MB) {
      toast({
        title: '용량 초과',
        description: `총 용량이 ${UPLOAD_CONFIG.MAX_TOTAL_SIZE_MB}MB를 초과합니다. 자동으로 압축하여 업로드합니다.`,
        status: 'warning',
        duration: 3000,
      });
    }
    
    setUploadFiles(files);
    
    // 파일 정보 로그
    console.log(`선택된 파일: ${files.length}개, 총 용량: ${totalSizeMB.toFixed(2)}MB`);
  }, [toast]);

  // 날짜 선택 처리
  const handleDateSelect = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.value) {
      const selectedDate = new Date(event.target.value);
      const formattedDate = selectedDate.toLocaleDateString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        weekday: 'short'
      });
      setUploadTitle(formattedDate);
    }
  }, []);

  // 업로드 처리
  const handleUpload = useCallback(() => {
    console.log('업로드 검증:', { user: !!user, files: uploadFiles.length, title: uploadTitle });
    
    if (!user) {
      toast({
        title: '오류',
        description: '로그인이 필요합니다.',
        status: 'error',
        duration: 3000,
      });
      return;
    }
    
    if (uploadFiles.length === 0) {
      toast({
        title: '오류',
        description: '사진 파일을 선택해주세요.',
        status: 'error',
        duration: 3000,
      });
      return;
    }
    
    if (!uploadTitle || !uploadTitle.trim()) {
      toast({
        title: '오류',
        description: '날짜를 선택해주세요.',
        status: 'error',
        duration: 3000,
      });
      return;
    }

    setIsProcessing(true);

    const processFiles = async () => {
      try {
        const newItems = [];
        
        for (let i = 0; i < uploadFiles.length; i++) {
          const file = uploadFiles[i];
          
          // 파일 크기에 따라 압축 여부 결정
          const fileSizeMB = file.size / (1024 * 1024);
          let base64: string;
          
          if (fileSizeMB > UPLOAD_CONFIG.TARGET_FILE_SIZE_MB) {
            // 큰 파일은 압축
            console.log(`파일 압축 중: ${file.name} (${fileSizeMB.toFixed(2)}MB -> ${UPLOAD_CONFIG.TARGET_FILE_SIZE_MB}MB)`);
            try {
              base64 = await compressImage(file, UPLOAD_CONFIG.TARGET_FILE_SIZE_MB);
            } catch (compressError) {
              console.warn('압축 실패, 원본 파일 사용:', compressError);
              base64 = await fileToBase64(file);
            }
          } else {
            // 작은 파일은 그대로
            base64 = await fileToBase64(file);
          }
          
          newItems.push({
            id: Date.now() + i,
            type: 'photo',
            src: base64,
            date: uploadTitle,
            author: user.name,
            likes: 0,
            comments: 0,
            badge: '+1',
            label: '사진',
            tags: [],
            description: uploadTitle,
            eventType: uploadEventType ? eventTypes.find(type => type.value === uploadEventType)?.label || '기타' : '기타',
            thumbnail: base64,
            isLiked: false,
            commentsList: []
          });
        }

        const updatedItems = [...newItems, ...items];
        
        // localStorage 용량 체크
        const dataToSave = JSON.stringify(updatedItems);
        if (!checkStorageQuota(dataToSave)) {
          setIsProcessing(false);
          
          toast({
            title: '용량 초과 오류',
            description: '저장소 용량이 부족합니다. 더 적은 수의 사진이나 더 작은 크기의 사진을 업로드해주세요.',
            status: 'error',
            duration: 5000,
          });
          
          return;
        }
        
        setItems(updatedItems);
        localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
        
        setIsProcessing(false);
        setIsUploadModalOpen(false);
        
        setUploadEventType('');
        setUploadTitle('');
        setUploadFiles([]);

        // 압축된 파일 수 계산
        const compressedCount = uploadFiles.filter(file => 
          file.size / (1024 * 1024) > UPLOAD_CONFIG.TARGET_FILE_SIZE_MB
        ).length;
        
        let successMessage = `${uploadFiles.length}장의 사진 업로드가 완료되었습니다.`;
        if (compressedCount > 0) {
          successMessage += ` (${compressedCount}장 자동 압축됨)`;
        }
        
        toast({
          title: '성공',
          description: successMessage,
          status: 'success',
          duration: 3000,
        });
      } catch (error) {
        console.error('업로드 오류:', error);
        setIsProcessing(false);
        
        let errorMessage = '업로드 중 오류가 발생했습니다.';
        if (error instanceof Error) {
          if (error.message.includes('QuotaExceededError')) {
            errorMessage = '저장소 용량이 부족합니다. 더 작은 이미지나 적은 수의 이미지를 업로드해주세요.';
          } else if (error.message.includes('파일 읽기')) {
            errorMessage = '파일 읽기에 실패했습니다. 다른 이미지를 선택해주세요.';
          }
        }
        
        toast({
          title: '오류',
          description: errorMessage,
          status: 'error',
          duration: 5000,
        });
      }
    };

    setTimeout(() => {
      processFiles();
    }, 2000);
  }, [uploadFiles, uploadTitle, uploadEventType, user, toast, items]);

  // 아이템 클릭 처리
  const handleItemClick = useCallback((item: any) => {
    setSelectedItem(item);
    setSelectedPhotoIndex(0);
    setIsDetailModalOpen(true);
  }, []);

  // 좋아요 토글
  const handleLikeToggle = useCallback((item: any) => {
    const updatedItems = items.map(i => {
      if (i.id === item.id) {
        return {
          ...i,
          isLiked: !i.isLiked,
          likes: i.isLiked ? i.likes - 1 : i.likes + 1
        };
      }
      return i;
    });
    
    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    if (selectedItem && selectedItem.id === item.id) {
      setSelectedItem(updatedItems.find(i => i.id === item.id));
    }
  }, [items, selectedItem]);

  // 댓글 추가
  const handleAddComment = useCallback((text: string) => {
    if (!user || !selectedItem || !text.trim()) return;

    const newComment = {
      id: Date.now(),
      author: user.name,
      text: text.trim(),
      date: new Date().toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' })
    };

    const updatedItems = items.map(item => {
      if (item.id === selectedItem.id) {
        return {
          ...item,
          comments: item.comments + 1,
          commentsList: [...item.commentsList, newComment]
        };
      }
      return item;
    });

    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    const updatedSelectedItem = updatedItems.find(item => item.id === selectedItem.id);
    setSelectedItem(updatedSelectedItem);
  }, [user, selectedItem, items]);

  // 댓글 편집
  const handleEditComment = useCallback((commentIndex: number, newText: string) => {
    if (!selectedItem || !newText.trim()) return;

    const updatedComments = [...selectedItem.commentsList];
    updatedComments[commentIndex] = {
      ...updatedComments[commentIndex],
      text: newText.trim()
    };

    const updatedItems = items.map(item => {
      if (item.id === selectedItem.id) {
        return {
          ...item,
          commentsList: updatedComments
        };
      }
      return item;
    });

    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    const updatedSelectedItem = updatedItems.find(item => item.id === selectedItem.id);
    setSelectedItem(updatedSelectedItem);
    setEditingCommentIndex(null);
    setEditCommentText('');
  }, [selectedItem, items]);

  // 댓글 삭제
  const handleDeleteComment = useCallback((commentIndex: number) => {
    if (!selectedItem) return;

    const updatedComments = selectedItem.commentsList.filter((_: any, index: number) => index !== commentIndex);

    const updatedItems = items.map(item => {
      if (item.id === selectedItem.id) {
        return {
          ...item,
          comments: item.comments - 1,
          commentsList: updatedComments
        };
      }
      return item;
    });

    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    const updatedSelectedItem = updatedItems.find(item => item.id === selectedItem.id);
    setSelectedItem(updatedSelectedItem);
  }, [selectedItem, items]);

  // 편집 모달 열기
  const handleEdit = useCallback((item: any) => {
    setEditingItem({ ...item, originalDate: item.date });
    setIsEditModalOpen(true);
  }, []);

  // 편집 저장
  const handleSaveEdit = useCallback(() => {
    if (!editingItem) return;

    const updatedItems = items.map(item => {
      if (editingItem.isGroup && editingItem.groupPhotos) {
        // 그룹된 사진의 경우 모든 사진의 날짜와 이벤트타입 변경
        const matchingPhotos = items.filter(i => 
          i.author === editingItem.author && 
          i.date === editingItem.originalDate
        );
        
        if (matchingPhotos.some(photo => photo.id === item.id)) {
          return {
            ...item,
            date: editingItem.date,
            description: editingItem.date,
            eventType: editingItem.eventType
          };
        }
      } else if (item.id === editingItem.id) {
        return {
          ...item,
          date: editingItem.date,
          description: editingItem.date,
          eventType: editingItem.eventType
        };
      }
      return item;
    });

    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    if (selectedItem && selectedItem.id === editingItem.id) {
      setSelectedItem(updatedItems.find(item => item.id === editingItem.id));
    }

    setIsEditModalOpen(false);
    setEditingItem(null);

    const updateCount = editingItem.isGroup ? editingItem.groupCount : 1;
    toast({
      title: '성공',
      description: `${updateCount}장의 사진 정보가 수정되었습니다.`,
      status: 'success',
      duration: 3000,
    });
  }, [editingItem, items, selectedItem, toast]);

  // 삭제 처리
  const handleDelete = useCallback((item: any) => {
    if (!window.confirm('정말로 이 사진을 삭제하시겠습니까?')) return;

    const updatedItems = items.filter(i => i.id !== item.id);
    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    if (selectedItem && selectedItem.id === item.id) {
      setIsDetailModalOpen(false);
      setSelectedItem(null);
    }

    toast({
      title: '성공',
      description: '사진이 삭제되었습니다.',
      status: 'success',
      duration: 3000,
    });
  }, [items, selectedItem, toast]);

  // 다운로드 모달 열기
  const handleDownloadModal = useCallback((item: any) => {
    if (item.isGroup && item.groupPhotos) {
      setDownloadItem(item);
      setSelectedPhotos([]);
      setIsDownloadModalOpen(true);
    } else {
      handleDirectDownload(item);
    }
  }, []);

  // 직접 다운로드
  const handleDirectDownload = useCallback((item: any) => {
    const link = document.createElement('a');
    link.href = item.src;
    link.download = `gallery_${item.id}.jpg`;
    link.click();
  }, []);

  // 선택적 다운로드
  const handleSelectiveDownload = useCallback(() => {
    if (!downloadItem || selectedPhotos.length === 0) return;

    selectedPhotos.forEach((index, i) => {
      setTimeout(() => {
        const photo = downloadItem.groupPhotos[index];
        const link = document.createElement('a');
        link.href = photo.src;
        link.download = `gallery_${downloadItem.date}_${index + 1}.jpg`;
        link.click();
      }, i * 100);
    });

    setIsDownloadModalOpen(false);
    setDownloadItem(null);
    setSelectedPhotos([]);

    toast({
      title: '다운로드 시작',
      description: `${selectedPhotos.length}장의 사진을 다운로드합니다.`,
      status: 'info',
      duration: 3000,
    });
  }, [downloadItem, selectedPhotos, toast]);

  // 사진 선택 토글
  const togglePhotoSelection = useCallback((index: number) => {
    setSelectedPhotos(prev => {
      if (prev.includes(index)) {
        return prev.filter(i => i !== index);
      } else if (prev.length < 10) {
        return [...prev, index];
      }
      return prev;
    });
  }, []);

  return (
    <Box minH="100vh" bg="#f7f9fb" w="100vw" minW="100vw" pt="18mm">
      {/* 상단 컨트롤 영역 */}
      <Box px={{ base: 2, md: 8, lg: 24 }} py={6}>
        <Flex direction={{ base: 'column', md: 'row' }} gap={4} align={{ base: 'stretch', md: 'center' }} justify="space-between" mb={1.5}>
          {/* 필터 탭 */}
          <HStack spacing={2} flexWrap="wrap">
            
          </HStack>

          {/* 정렬 및 업로드 */}
          <HStack spacing={2}>
            <Select size="sm" value={sort} onChange={(e) => setSort(e.target.value)} w="100px">
              <option value="latest">최신순</option>
              <option value="oldest">오래된순</option>
              <option value="likes">좋아요순</option>
              <option value="comments">댓글순</option>
            </Select>
            <Tooltip label="업로드">
              <IconButton 
                size="sm" 
                icon={<PlusSquareIcon />} 
                aria-label="업로드" 
                bg="#004ea8"
                color="white"
                _hover={{ bg: '#004ea8' }}
                onClick={() => setIsUploadModalOpen(true)}
              />
            </Tooltip>
          </HStack>
        </Flex>
      </Box>

      {/* 갤러리 그리드 */}
      <Box px={{ base: 2, md: 8, lg: 24 }} pb={10}>
        <SimpleGrid columns={{ base: 1, sm: 2, md: 3, lg: 4 }} spacing={6}>
          {sortedItems.map((item) => (
            <Box 
              key={item.id} 
              bg="white" 
              borderRadius="2xl" 
              boxShadow="md" 
              overflow="hidden" 
              position="relative" 
              _hover={{ boxShadow: 'xl', transform: 'translateY(-2px)' }} 
              transition="all 0.2s"
              cursor="pointer"
              onClick={() => handleItemClick(item)}
            >
              {/* 썸네일/라벨/뱃지 */}
              <Box position="relative">
                <Image 
                  src={item.thumbnail} 
                  alt={item.label} 
                  w="100%" 
                  h="160px" 
                  objectFit="cover" 
                />

                
                {/* 그룹 사진 표시 */}
                {item.isGroup && item.groupCount > 1 && (
                  <Badge 
                    position="absolute" 
                    top={2} 
                    right={2} 
                    colorScheme="purple" 
                    fontSize="xs" 
                    px={2} 
                    py={0.5} 
                    borderRadius="md"
                  >
                    +{item.groupCount - 1}
                  </Badge>
                )}
              </Box>

              {/* 정보 영역 */}
              <VStack align="stretch" spacing={1} p={3}>
                {/* 제목과 뱃지 */}
                <Flex justify="space-between" align="center">
                  <Text fontSize="sm" color="black" fontWeight="bold" noOfLines={2} flex={1} mr={2}>
                    {item.description || item.date}
                  </Text>
                  {item.eventType ? (
                    <Badge 
                      colorScheme={item.eventType === '매치' ? 'blue' : item.eventType === '자체' ? 'green' : 'gray'} 
                      fontSize="xs" 
                      px={1.5} 
                      py={0.3}
                      borderRadius="sm"
                      flexShrink={0}
                    >
                      {item.eventType}
                    </Badge>
                  ) : null}
                </Flex>
                
                {/* 작성자와 좋아요/댓글 */}
                <Flex justify="space-between" align="center">
                  <Text fontSize="xs" color="gray.500">작성자: {item.author}</Text>
                  <HStack spacing={2}>
                    <HStack 
                      spacing={1} 
                      cursor="pointer"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleLikeToggle(item);
                      }}
                    >
                      <Text fontSize="sm" color={item.isLiked ? 'red.500' : 'gray.400'}>♡</Text>
                      <Text fontSize="sm">{item.likes}</Text>
                    </HStack>
                    <HStack spacing={1}>
                      <Text fontSize="sm">💬</Text>
                      <Text fontSize="sm">{item.comments}</Text>
                    </HStack>
                  </HStack>
                </Flex>
              </VStack>
            </Box>
          ))}
        </SimpleGrid>
      </Box>

      {/* 업로드 모달 */}
      <Modal isOpen={isUploadModalOpen} onClose={() => setIsUploadModalOpen(false)} size="lg">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>📸 사진 업로드</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            <VStack spacing={4}>
              <Box w="full">
                <Text mb={2} fontSize="sm" fontWeight="bold">
                  제목 (날짜)
                </Text>
                <Input
                  type="date"
                  onChange={handleDateSelect}
                />
                {uploadTitle && (
                  <Text fontSize="sm" color="blue.600" mt={1}>
                    선택된 날짜: {uploadTitle}
                  </Text>
                )}
              </Box>

              <Box w="full">
                <Text mb={2} fontSize="sm" fontWeight="bold">
                  사진 파일 선택
                </Text>
                <Input
                  ref={fileInputRef}
                  type="file"
                  multiple
                  accept="image/*"
                  onChange={handleFileSelect}
                  display="none"
                />
                <Button
                  w="full"
                  onClick={() => fileInputRef.current?.click()}
                  variant="outline"
                >
                  파일 선택
                </Button>
                <Text fontSize="xs" color="gray.500" mt={1}>
                  지원 형식: JPG, PNG, GIF, WEBP | 최대 {UPLOAD_CONFIG.MAX_FILES}장 | 총 용량 {UPLOAD_CONFIG.MAX_TOTAL_SIZE_MB}MB
                </Text>
                {uploadFiles.length > 0 && (
                  <VStack spacing={1} mt={1} align="start" w="full">
                    <Text fontSize="sm" color="blue.500">
                      {uploadFiles.length}개 사진 선택됨
                    </Text>
                    <Text fontSize="xs" color="gray.600">
                      총 용량: {(uploadFiles.reduce((sum, file) => sum + file.size, 0) / (1024 * 1024)).toFixed(2)}MB
                    </Text>
                    {uploadFiles.some(file => file.size / (1024 * 1024) > UPLOAD_CONFIG.TARGET_FILE_SIZE_MB) && (
                      <Text fontSize="xs" color="orange.500">
                        일부 파일이 자동으로 압축됩니다 (목표: {UPLOAD_CONFIG.TARGET_FILE_SIZE_MB}MB/파일)
                      </Text>
                    )}
                  </VStack>
                )}
              </Box>

              <Box w="full">
                <Text mb={2} fontSize="sm" fontWeight="bold">
                  이벤트 타입 선택 (선택사항)
                </Text>
                <HStack spacing={2}>
                  {eventTypes.map((type) => (
                    <Button
                      key={type.value}
                      size="sm"
                      variant={uploadEventType === type.value ? 'solid' : 'outline'}
                      onClick={() => setUploadEventType(type.value)}
                    >
                      {type.label}
                    </Button>
                  ))}
                </HStack>
              </Box>

              <Button
                w="full"
                colorScheme="blue"
                onClick={handleUpload}
                isLoading={isProcessing}
                loadingText="업로드 중..."
                isDisabled={!uploadTitle || !uploadTitle.trim() || uploadFiles.length === 0}
              >
                업로드
              </Button>
            </VStack>
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* 상세 모달 */}
      <Modal isOpen={isDetailModalOpen} onClose={() => setIsDetailModalOpen(false)} size="xl">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>
            <Text>📸 사진 상세보기</Text>
          </ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            {selectedItem && (
              <VStack spacing={4}>
                {selectedItem.isGroup ? (
                  <>
                    <Image
                      src={selectedItem.groupPhotos[selectedPhotoIndex].src}
                      alt="메인 사진"
                      maxH="300px"
                      objectFit="contain"
                      cursor="pointer"
                      onClick={() => window.open(selectedItem.groupPhotos[selectedPhotoIndex].src, '_blank')}
                    />
                    
                    <HStack spacing={2} justify="center">
                      {selectedItem.groupPhotos.map((photo: any, index: number) => (
                        <Image
                          key={photo.id}
                          src={photo.thumbnail}
                          alt={`썸네일 ${index + 1}`}
                          w="60px"
                          h="60px"
                          objectFit="cover"
                          borderRadius="md"
                          cursor="pointer"
                          border={selectedPhotoIndex === index ? "2px solid" : "1px solid"}
                          borderColor={selectedPhotoIndex === index ? "blue.500" : "gray.200"}
                          onClick={() => setSelectedPhotoIndex(index)}
                        />
                      ))}
                    </HStack>
                  </>
                ) : (
                  <Image
                    src={selectedItem.src}
                    alt={selectedItem.description}
                    maxH="300px"
                    objectFit="contain"
                    cursor="pointer"
                    onClick={() => window.open(selectedItem.src, '_blank')}
                  />
                )}

                {/* 액션 버튼들 - 사진 하단으로 이동 */}
                <HStack spacing={2} justify="center">
                  <Button
                    size="sm"
                    variant="outline"
                    leftIcon={<DownloadIcon />}
                    onClick={() => handleDownloadModal(selectedItem)}
                  >
                    다운로드
                  </Button>
                  {(user?.name === selectedItem?.author || user?.role === 'admin' || user?.role === 'superadmin') && (
                    <>
                      <Button
                        size="sm"
                        variant="outline"
                        leftIcon={<EditIcon />}
                        onClick={() => handleEdit(selectedItem)}
                      >
                        수정
                      </Button>
                      <Button
                        size="sm"
                        variant="outline"
                        colorScheme="red"
                        leftIcon={<DeleteIcon />}
                        onClick={() => handleDelete(selectedItem)}
                      >
                        삭제
                      </Button>
                    </>
                  )}
                </HStack>

                <Divider />

                {/* 작성자와 좋아요 버튼 */}
                <Flex justify="space-between" align="center" w="full">
                  <Text>작성자: {selectedItem.author}</Text>
                  <Button
                    size="sm"
                    variant={selectedItem.isLiked ? 'solid' : 'outline'}
                    colorScheme="red"
                    onClick={() => handleLikeToggle(selectedItem)}
                  >
                    {selectedItem.isLiked ? '❤️ 좋아요 취소' : '🤍 좋아요'}
                  </Button>
                </Flex>

                <Divider />

                {/* 댓글 섹션 */}
                <VStack spacing={2} w="full" align="stretch">
                  <Text fontWeight="bold">댓글</Text>
                    {selectedItem.commentsList.map((comment: any, index: number) => (
                      <Box key={comment.id} p={2} bg="gray.50" borderRadius="md">
                        {editingCommentIndex === index ? (
                          <VStack spacing={2} align="stretch">
                            <Textarea
                              value={editCommentText}
                              onChange={(e) => setEditCommentText(e.target.value)}
                              size="sm"
                              placeholder="댓글을 수정하세요..."
                            />
                            <HStack spacing={2}>
                              <Button
                                size="sm"
                                onClick={() => handleEditComment(index, editCommentText)}
                              >
                                저장
                              </Button>
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => {
                                  setEditingCommentIndex(null);
                                  setEditCommentText('');
                                }}
                              >
                                취소
                              </Button>
                            </HStack>
                          </VStack>
                        ) : (
                          <>
                            <Text fontSize="sm" textAlign="left" mb={1}>
                              {comment.text}
                            </Text>
                            <Flex justify="space-between" align="center">
                              <Text fontSize="xs" color="gray.500">
                                {comment.author} • {comment.date}
                              </Text>
                              {(user?.name === comment.author || user?.role === 'admin' || user?.role === 'superadmin') && (
                                <HStack spacing={1}>
                                  <Button
                                    size="xs"
                                    variant="ghost"
                                    onClick={() => {
                                      setEditingCommentIndex(index);
                                      setEditCommentText(comment.text);
                                    }}
                                  >
                                    수정
                                  </Button>
                                  <Button
                                    size="xs"
                                    variant="ghost"
                                    colorScheme="red"
                                    onClick={() => handleDeleteComment(index)}
                                  >
                                    삭제
                                  </Button>
                                </HStack>
                              )}
                            </Flex>
                          </>
                        )}
                      </Box>
                    ))}

                    <HStack spacing={2}>
                      <Input
                        placeholder="댓글을 입력하세요..."
                        size="sm"
                        onKeyPress={(e) => {
                          if (e.key === 'Enter' && e.currentTarget.value.trim()) {
                            handleAddComment(e.currentTarget.value);
                            e.currentTarget.value = '';
                          }
                        }}
                      />
                      <Button
                        size="sm"
                        onClick={(e) => {
                          const input = e.currentTarget.previousElementSibling as HTMLInputElement;
                          if (input.value.trim()) {
                            handleAddComment(input.value);
                            input.value = '';
                          }
                        }}
                      >
                        작성
                      </Button>
                    </HStack>
                  </VStack>
                </VStack>
              </VStack>
            )}
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* 편집 모달 */}
      <Modal isOpen={isEditModalOpen} onClose={() => setIsEditModalOpen(false)} size="md">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>✏️ 사진 정보 수정</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            {editingItem && (
              <VStack spacing={4}>
                <Image
                  src={editingItem.src}
                  alt="미리보기"
                  maxH="200px"
                  objectFit="contain"
                />
                
                <Box w="full">
                  <Text mb={2} fontSize="sm" fontWeight="bold">
                    현재 날짜
                  </Text>
                  <Text fontSize="sm" color="blue.500" mb={2}>
                    {editingItem.originalDate}
                  </Text>
                  
                  <Text mb={2} fontSize="sm" fontWeight="bold">
                    수정 날짜
                  </Text>
                  <Input
                    type="date"
                    onChange={(e) => {
                      if (e.target.value) {
                        const selectedDate = new Date(e.target.value);
                        const formattedDate = selectedDate.toLocaleDateString('ko-KR', {
                          year: 'numeric',
                          month: '2-digit',
                          day: '2-digit',
                          weekday: 'short'
                        });
                        setEditingItem({ ...editingItem, date: formattedDate });
                      }
                    }}
                  />
                  {editingItem.date && editingItem.date !== editingItem.originalDate && (
                    <Text fontSize="sm" color="orange.500" mt={1}>
                      수정 날짜: {editingItem.date}
                    </Text>
                  )}
                </Box>

                <Box w="full">
                  <Text mb={2} fontSize="sm" fontWeight="bold">
                    이벤트 타입
                  </Text>
                  <HStack spacing={2}>
                    {eventTypes.map((type) => (
                      <Button
                        key={type.value}
                        size="sm"
                        variant={editingItem.eventType === type.label ? 'solid' : 'outline'}
                        onClick={() => setEditingItem({ ...editingItem, eventType: type.label })}
                      >
                        {type.label}
                      </Button>
                    ))}
                  </HStack>
                </Box>

                <Button
                  w="full"
                  colorScheme="blue"
                  onClick={handleSaveEdit}
                >
                  저장
                </Button>
              </VStack>
            )}
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* 다운로드 모달 */}
      <Modal isOpen={isDownloadModalOpen} onClose={() => setIsDownloadModalOpen(false)} size="xl">
        <ModalOverlay />
        <ModalContent maxH="90vh" display="flex" flexDirection="column">
          <ModalHeader flexShrink={0}>
            <HStack>
              <Text>📸</Text>
              <Text>사진 선택 다운로드</Text>
            </HStack>
          </ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6} flex="1" display="flex" minH="0">
            {downloadItem && (
              <VStack spacing={4} h="full">
                <HStack spacing={4} w="full" justify="space-between" bg="gray.50" p={3} borderRadius="md" flexShrink={0}>
                  <Text fontSize="sm" color="gray.600">
                    다운로드할 사진을 선택하세요 (최대 10장)
                  </Text>
                  
                  <HStack spacing={2} align="center">
                    <Text fontSize="sm" color="gray.600" fontWeight="bold">
                      선택된 사진: {selectedPhotos.length}장
                    </Text>
                    <IconButton
                      icon={<DownloadIcon />}
                      aria-label="다운로드"
                      colorScheme="blue"
                      onClick={handleSelectiveDownload}
                      isDisabled={selectedPhotos.length === 0}
                      size="sm"
                    />
                  </HStack>
                </HStack>

                <Box 
                  flex="1"
                  maxH="50vh" 
                  overflowY="auto" 
                  overflowX="hidden"
                  w="full"
                  style={{ 
                    scrollbarWidth: 'thin',
                    scrollbarColor: '#CBD5E0 #F7FAFC'
                  }}
                >
                  <SimpleGrid columns={3} spacing={4} w="full">
                    {downloadItem.groupPhotos.map((photo: any, index: number) => (
                      <Box
                        key={photo.id}
                        position="relative"
                        cursor="pointer"
                        onClick={() => togglePhotoSelection(index)}
                      >
                        <Image
                          src={photo.thumbnail}
                          alt={`사진 ${index + 1}`}
                          w="full"
                          h="120px"
                          objectFit="cover"
                          borderRadius="md"
                          border={selectedPhotos.includes(index) ? "3px solid" : "1px solid"}
                          borderColor={selectedPhotos.includes(index) ? "blue.500" : "gray.200"}
                        />
                        {selectedPhotos.includes(index) && (
                          <Box
                            position="absolute"
                            top={2}
                            right={2}
                            bg="blue.500"
                            color="white"
                            borderRadius="full"
                            w="24px"
                            h="24px"
                            display="flex"
                            alignItems="center"
                            justifyContent="center"
                            fontSize="sm"
                            fontWeight="bold"
                          >
                            {selectedPhotos.indexOf(index) + 1}
                          </Box>
                        )}
                      </Box>
                    ))}
                  </SimpleGrid>
                </Box>
              </VStack>
            )}
          </ModalBody>
        </ModalContent>
      </Modal>
    </Box>
  );
}