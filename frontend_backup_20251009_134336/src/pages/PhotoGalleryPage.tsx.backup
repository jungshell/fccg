import { 
  Box, 
  Flex, 
  Text, 
  HStack, 
  VStack, 
  Button, 
  Input, 
  Badge, 
  IconButton, 
  Image, 
  SimpleGrid,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  Select,
  Tooltip,
  Divider,
  useToast,
  Textarea
} from '@chakra-ui/react';
import { 
  useState, 
  useRef, 
  useCallback, 
  useEffect,
  useMemo
} from 'react';
import { 
  PlusSquareIcon, 
  DownloadIcon,
  DeleteIcon,
  EditIcon,
  ArrowUpIcon
} from '@chakra-ui/icons';
import { useAuthStore } from '../store/auth';

// ì‚¬ì§„ ë°ì´í„°
const photoItems = [
  {
    id: 1,
    type: 'photo',
    src: 'https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=400&q=80',
    date: '2025.06.30.(ì›”)',
    author: 'ì •ì„±ì¸',
    likes: 12,
    comments: 5,
    badge: '+3',
    label: 'ì‚¬ì§„',
    tags: ['ê²½ê¸°', 'íŒ€', 'ì¶•êµ¬'],
    description: 'ì˜¤ëŠ˜ ê²½ê¸°ì—ì„œ ì°ì€ ë©‹ì§„ ì‚¬ì§„ë“¤',
    eventType: 'ë§¤ì¹˜',
    thumbnail: 'https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=400&q=80',
    isLiked: false,
    commentsList: [
      { id: 1, author: 'ê¹€ì² ìˆ˜', text: 'ì •ë§ ë©‹ì§„ ì‚¬ì§„ì´ë„¤ìš”!', date: '06.30.' },
      { id: 2, author: 'ì´ì˜í¬', text: 'ë‹¤ìŒ ê²½ê¸°ë„ í™”ì´íŒ…!', date: '06.30.' }
    ]
  },
  {
    id: 2,
    type: 'photo',
    src: 'https://images.unsplash.com/photo-1519125323398-675f0ddb6308?auto=format&fit=crop&w=400&q=80',
    date: '2025.06.29.(ì¼)',
    author: 'ì •ì„±ì¸',
    likes: 8,
    comments: 3,
    badge: '+2',
    label: 'ì‚¬ì§„',
    tags: ['ì—°ìŠµ', 'ê¸°ìˆ '],
    description: 'ê¸°ìˆ  ì—°ìŠµ ì¤‘',
    eventType: 'ìì²´',
    thumbnail: 'https://images.unsplash.com/photo-1519125323398-675f0ddb6308?auto=format&fit=crop&w=400&q=80',
    isLiked: true,
    commentsList: [
      { id: 1, author: 'ë°•ë¯¼ìˆ˜', text: 'ê¸°ìˆ ì´ ë§ì´ ëŠ˜ì—ˆë„¤ìš”!', date: '06.29.' }
    ]
  }
];

const eventTypes = [
  { label: 'ë§¤ì¹˜', value: 'match' },
  { label: 'ìì²´', value: 'practice' },
  { label: 'íšŒì‹', value: 'dinner' },
  { label: 'ê¸°íƒ€', value: 'other' }
];

// ì—…ë¡œë“œ ì„¤ì •
const UPLOAD_CONFIG = {
  MAX_FILES: 10, // ìµœëŒ€ ì—…ë¡œë“œ íŒŒì¼ ìˆ˜
  MAX_TOTAL_SIZE_MB: 5, // ìµœëŒ€ ì´ ìš©ëŸ‰ (MB)
  TARGET_FILE_SIZE_MB: 0.5, // ëª©í‘œ íŒŒì¼ë‹¹ ìš©ëŸ‰ (MB)
  SUPPORTED_FORMATS: ['image/jpeg', 'image/png', 'image/gif', 'image/webp']
};

// ì´ë¯¸ì§€ ì••ì¶• í•¨ìˆ˜
const compressImage = (file: File, maxSizeMB: number = 0.5): Promise<string> => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = document.createElement('img');
    
    img.onload = () => {
      try {
        // ì›ë³¸ í¬ê¸° ìœ ì§€í•˜ë˜ í’ˆì§ˆ ì¡°ì •
        canvas.width = img.width;
        canvas.height = img.height;
        
        if (ctx) {
          ctx.drawImage(img, 0, 0);
          
          // í’ˆì§ˆì„ ì ì§„ì ìœ¼ë¡œ ë‚®ì¶°ê°€ë©° ìš©ëŸ‰ ì¡°ì •
          let quality = 0.9;
          let dataUrl = canvas.toDataURL('image/jpeg', quality);
          
          // ëª©í‘œ í¬ê¸° (bytes)
          const targetSize = maxSizeMB * 1024 * 1024;
          const currentSize = dataUrl.length * 0.75; // base64ëŠ” ì‹¤ì œ í¬ê¸°ì˜ ì•½ 4/3ë°°
          
          console.log(`ì••ì¶• ì‹œì‘: í˜„ì¬ í¬ê¸° ${(currentSize / (1024 * 1024)).toFixed(2)}MB, ëª©í‘œ ${maxSizeMB}MB`);
          
          // ìš©ëŸ‰ì´ ëª©í‘œë³´ë‹¤ í¬ë©´ í’ˆì§ˆì„ ë‚®ì¶¤
          while (dataUrl.length * 0.75 > targetSize && quality > 0.1) {
            quality -= 0.1;
            dataUrl = canvas.toDataURL('image/jpeg', quality);
          }
          
          const finalSize = dataUrl.length * 0.75;
          console.log(`ì••ì¶• ì™„ë£Œ: ìµœì¢… í¬ê¸° ${(finalSize / (1024 * 1024)).toFixed(2)}MB, í’ˆì§ˆ ${quality}`);
          
          // ë©”ëª¨ë¦¬ ì •ë¦¬
          URL.revokeObjectURL(img.src);
          
          resolve(dataUrl);
        } else {
          reject(new Error('Canvas contextë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'));
        }
      } catch (error) {
        console.error('ì••ì¶• ì¤‘ ì˜¤ë¥˜:', error);
        reject(error);
      }
    };
    
    img.onerror = () => {
      URL.revokeObjectURL(img.src);
      reject(new Error('ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'));
    };
    
    img.src = URL.createObjectURL(file);
  });
};

// íŒŒì¼ì„ base64ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ (ì••ì¶• ì—†ìŒ)
const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result);
      } else {
        reject(new Error('íŒŒì¼ ì½ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.'));
      }
    };
    
    reader.onerror = () => {
      reject(new Error('íŒŒì¼ ì½ê¸° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'));
    };
    
    reader.readAsDataURL(file);
  });
};

export default function PhotoGalleryPage() {
  const { user } = useAuthStore();
  const [filter, setFilter] = useState('all');
  const [sort, setSort] = useState('latest');
  const [search, setSearch] = useState('');
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [items, setItems] = useState(photoItems);
  const [selectedItem, setSelectedItem] = useState<any>(null);
  const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);
  const [isUploadModalOpen, setIsUploadModalOpen] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [uploadFiles, setUploadFiles] = useState<File[]>([]);
  const [uploadTitle, setUploadTitle] = useState('');
  const [uploadEventType, setUploadEventType] = useState('');
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<any>(null);
  const [isDownloadModalOpen, setIsDownloadModalOpen] = useState(false);
  const [downloadItem, setDownloadItem] = useState<any>(null);
  const [selectedPhotos, setSelectedPhotos] = useState<number[]>([]);
  const [selectedPhotoIndex, setSelectedPhotoIndex] = useState(0);
  const [editingCommentIndex, setEditingCommentIndex] = useState<number | null>(null);
  const [editCommentText, setEditCommentText] = useState('');
  const [isAddPhotoModalOpen, setIsAddPhotoModalOpen] = useState(false);
  const [addPhotoFiles, setAddPhotoFiles] = useState<File[]>([]);
  const [addPhotoEventType, setAddPhotoEventType] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);
  const addPhotoFileInputRef = useRef<HTMLInputElement>(null);
  const toast = useToast();

  // localStorageì—ì„œ ë°ì´í„° ë¡œë“œ
  useEffect(() => {
    const savedItems = localStorage.getItem('photoGalleryItems');
    if (savedItems) {
      try {
        const parsedItems = JSON.parse(savedItems);
        setItems(parsedItems);
      } catch (error) {
        console.error('localStorage ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
        setItems(photoItems);
      }
    } else {
      setItems(photoItems);
    }
  }, []);

  // localStorage ìš©ëŸ‰ ì²´í¬ í•¨ìˆ˜
  const checkStorageQuota = (data: string): boolean => {
    try {
      let currentSize = 0;
      for (let key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
          currentSize += localStorage[key].length;
        }
      }
      
      const newDataSize = data.length;
      const totalSize = currentSize + newDataSize;
      const maxSize = 5 * 1024 * 1024; // 5MB
      
      console.log(`í˜„ì¬ í¬ê¸°: ${currentSize}, ìƒˆ ë°ì´í„° í¬ê¸°: ${newDataSize}, ì´ í¬ê¸°: ${totalSize}, ìµœëŒ€ í¬ê¸°: ${maxSize}`);
      
      return totalSize < maxSize;
    } catch (error) {
      console.error('ì €ì¥ì†Œ ìš©ëŸ‰ ì²´í¬ ì˜¤ë¥˜:', error);
      return false;
    }
  };

  // ì‚¬ì§„ ê·¸ë£¹í•‘ í•¨ìˆ˜
  const groupPhotosByDate = useCallback((photos: any[]) => {
    const groups: { [key: string]: any[] } = {};
    
    photos.forEach(photo => {
      const date = `${photo.author}_${photo.date}`;
      if (!groups[date]) {
        groups[date] = [];
      }
      groups[date].push(photo);
    });
    
    return Object.entries(groups).map(([dateKey, photos]) => {
      if (photos.length === 1) {
        return photos[0];
      } else {
        return {
          ...photos[0],
          isGroup: true,
          groupCount: photos.length,
          groupPhotos: photos
        };
      }
    });
  }, []);

  // ê·¸ë£¹í™”ëœ ì•„ì´í…œë“¤
  const groupedItems = useMemo(() => {
    return groupPhotosByDate(items);
  }, [items, groupPhotosByDate]);

  // í•„í„°ë§ëœ ì•„ì´í…œë“¤
  const filteredItems = useMemo(() => {
    let filtered = groupedItems;

    // íƒ€ì… í•„í„° (ì‚¬ì§„ë§Œ í‘œì‹œ)
    filtered = filtered.filter(item => item.type === 'photo');
    
    // ê²€ìƒ‰ í•„í„°
    if (search) {
      filtered = filtered.filter(item => 
        item.description.toLowerCase().includes(search.toLowerCase()) ||
        item.author.toLowerCase().includes(search.toLowerCase()) ||
        item.tags.some((tag: string) => tag.toLowerCase().includes(search.toLowerCase()))
      );
    }
    
    // íƒœê·¸ í•„í„°
    if (selectedTags.length > 0) {
      filtered = filtered.filter(item => 
        selectedTags.every(tag => item.tags.includes(tag))
      );
    }
    
    return filtered;
  }, [groupedItems, search, selectedTags]);

  // ì •ë ¬ëœ ì•„ì´í…œë“¤
  const sortedItems = useMemo(() => {
    let sorted = [...filteredItems];
    
    switch (sort) {
      case 'latest':
        sorted.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
        break;
      case 'oldest':
        sorted.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
        break;
      case 'likes':
        sorted.sort((a, b) => b.likes - a.likes);
        break;
      case 'comments':
        sorted.sort((a, b) => b.comments - a.comments);
        break;
    }
    
    return sorted;
  }, [filteredItems, sort]);

  // íŒŒì¼ ì„ íƒ ì²˜ë¦¬ (ìë™ ì••ì¶• í¬í•¨)
  const handleFileSelect = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || []);
    
    // íŒŒì¼ ìˆ˜ ì œí•œ ì²´í¬
    if (files.length > UPLOAD_CONFIG.MAX_FILES) {
      toast({
        title: 'íŒŒì¼ ìˆ˜ ì´ˆê³¼',
        description: `ìµœëŒ€ ${UPLOAD_CONFIG.MAX_FILES}ì¥ê¹Œì§€ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.`,
        status: 'error',
        duration: 3000,
      });
      return;
    }
    
    // íŒŒì¼ í˜•ì‹ ì²´í¬
    const invalidFiles = files.filter(file => !UPLOAD_CONFIG.SUPPORTED_FORMATS.includes(file.type));
    if (invalidFiles.length > 0) {
      toast({
        title: 'ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹',
        description: 'JPG, PNG, GIF, WEBP í˜•ì‹ë§Œ ì§€ì›ë©ë‹ˆë‹¤.',
        status: 'error',
        duration: 3000,
      });
      return;
    }
    
    // ì´ ìš©ëŸ‰ ì²´í¬
    const totalSizeMB = files.reduce((sum, file) => sum + file.size / (1024 * 1024), 0);
    if (totalSizeMB > UPLOAD_CONFIG.MAX_TOTAL_SIZE_MB) {
      toast({
        title: 'ìš©ëŸ‰ ì´ˆê³¼',
        description: `ì´ ìš©ëŸ‰ì´ ${UPLOAD_CONFIG.MAX_TOTAL_SIZE_MB}MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤. ìë™ìœ¼ë¡œ ì••ì¶•í•˜ì—¬ ì—…ë¡œë“œí•©ë‹ˆë‹¤.`,
        status: 'warning',
        duration: 3000,
      });
    }
    
    setUploadFiles(files);
    
    // íŒŒì¼ ì •ë³´ ë¡œê·¸
    console.log(`ì„ íƒëœ íŒŒì¼: ${files.length}ê°œ, ì´ ìš©ëŸ‰: ${totalSizeMB.toFixed(2)}MB`);
  }, [toast]);

  // ë‚ ì§œ ì„ íƒ ì²˜ë¦¬
  const handleDateSelect = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.value) {
      const selectedDate = new Date(event.target.value);
      const formattedDate = selectedDate.toLocaleDateString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        weekday: 'short'
      });
      setUploadTitle(formattedDate);
    }
  }, []);

  // ì—…ë¡œë“œ ì²˜ë¦¬
  const handleUpload = useCallback(() => {
    console.log('ì—…ë¡œë“œ ê²€ì¦:', { user: !!user, files: uploadFiles.length, title: uploadTitle });
    
    if (!user) {
      toast({
        title: 'ì˜¤ë¥˜',
        description: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.',
        status: 'error',
        duration: 3000,
      });
      return;
    }
    
    if (uploadFiles.length === 0) {
      toast({
        title: 'ì˜¤ë¥˜',
        description: 'ì‚¬ì§„ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.',
        status: 'error',
        duration: 3000,
      });
      return;
    }
    
    if (!uploadTitle || !uploadTitle.trim()) {
      toast({
        title: 'ì˜¤ë¥˜',
        description: 'ë‚ ì§œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.',
        status: 'error',
        duration: 3000,
      });
      return;
    }

    setIsProcessing(true);

    const processFiles = async () => {
      try {
        const newItems = [];
        
        for (let i = 0; i < uploadFiles.length; i++) {
          const file = uploadFiles[i];
          
          // íŒŒì¼ í¬ê¸°ì— ë”°ë¼ ì••ì¶• ì—¬ë¶€ ê²°ì •
          const fileSizeMB = file.size / (1024 * 1024);
          let base64: string;
          
          if (fileSizeMB > UPLOAD_CONFIG.TARGET_FILE_SIZE_MB) {
            // í° íŒŒì¼ì€ ì••ì¶•
            console.log(`íŒŒì¼ ì••ì¶• ì¤‘: ${file.name} (${fileSizeMB.toFixed(2)}MB -> ${UPLOAD_CONFIG.TARGET_FILE_SIZE_MB}MB)`);
            try {
              base64 = await compressImage(file, UPLOAD_CONFIG.TARGET_FILE_SIZE_MB);
            } catch (compressError) {
              console.warn('ì••ì¶• ì‹¤íŒ¨, ì›ë³¸ íŒŒì¼ ì‚¬ìš©:', compressError);
              base64 = await fileToBase64(file);
            }
          } else {
            // ì‘ì€ íŒŒì¼ì€ ê·¸ëŒ€ë¡œ
            base64 = await fileToBase64(file);
          }
          
          newItems.push({
            id: Date.now() + i,
            type: 'photo',
            src: base64,
            date: uploadTitle,
            author: user.name,
            likes: 0,
            comments: 0,
            badge: '+1',
            label: 'ì‚¬ì§„',
            tags: [],
            description: uploadTitle,
            eventType: uploadEventType ? eventTypes.find(type => type.value === uploadEventType)?.label || 'ê¸°íƒ€' : 'ê¸°íƒ€',
            thumbnail: base64,
            isLiked: false,
            commentsList: []
          });
        }

        const updatedItems = [...newItems, ...items];
        
        // localStorage ìš©ëŸ‰ ì²´í¬
        const dataToSave = JSON.stringify(updatedItems);
        if (!checkStorageQuota(dataToSave)) {
          setIsProcessing(false);
          
          toast({
            title: 'ìš©ëŸ‰ ì´ˆê³¼ ì˜¤ë¥˜',
            description: 'ì €ì¥ì†Œ ìš©ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ë” ì ì€ ìˆ˜ì˜ ì‚¬ì§„ì´ë‚˜ ë” ì‘ì€ í¬ê¸°ì˜ ì‚¬ì§„ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.',
            status: 'error',
            duration: 5000,
          });
          
          return;
        }
        
        setItems(updatedItems);
        localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
        
        setIsProcessing(false);
        setIsUploadModalOpen(false);
        
        setUploadEventType('');
        setUploadTitle('');
        setUploadFiles([]);

        // ì••ì¶•ëœ íŒŒì¼ ìˆ˜ ê³„ì‚°
        const compressedCount = uploadFiles.filter(file => 
          file.size / (1024 * 1024) > UPLOAD_CONFIG.TARGET_FILE_SIZE_MB
        ).length;
        
        let successMessage = `${uploadFiles.length}ì¥ì˜ ì‚¬ì§„ ì—…ë¡œë“œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`;
        if (compressedCount > 0) {
          successMessage += ` (${compressedCount}ì¥ ìë™ ì••ì¶•ë¨)`;
        }
        
        toast({
          title: 'ì„±ê³µ',
          description: successMessage,
          status: 'success',
          duration: 3000,
        });
      } catch (error) {
        console.error('ì—…ë¡œë“œ ì˜¤ë¥˜:', error);
        setIsProcessing(false);
        
        let errorMessage = 'ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
        if (error instanceof Error) {
          if (error.message.includes('QuotaExceededError')) {
            errorMessage = 'ì €ì¥ì†Œ ìš©ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ë” ì‘ì€ ì´ë¯¸ì§€ë‚˜ ì ì€ ìˆ˜ì˜ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.';
          } else if (error.message.includes('íŒŒì¼ ì½ê¸°')) {
            errorMessage = 'íŒŒì¼ ì½ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.';
          }
        }
        
        toast({
          title: 'ì˜¤ë¥˜',
          description: errorMessage,
          status: 'error',
          duration: 5000,
        });
      }
    };

    setTimeout(() => {
      processFiles();
    }, 2000);
  }, [uploadFiles, uploadTitle, uploadEventType, user, toast, items]);

  // ì•„ì´í…œ í´ë¦­ ì²˜ë¦¬
  const handleItemClick = useCallback((item: any) => {
    setSelectedItem(item);
    setSelectedPhotoIndex(0);
    setIsDetailModalOpen(true);
  }, []);

  // ì¢‹ì•„ìš” í† ê¸€
  const handleLikeToggle = useCallback((item: any) => {
    const updatedItems = items.map(i => {
      if (i.id === item.id) {
        return {
          ...i,
          isLiked: !i.isLiked,
          likes: i.isLiked ? i.likes - 1 : i.likes + 1
        };
      }
      return i;
    });
    
    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    if (selectedItem && selectedItem.id === item.id) {
      setSelectedItem(updatedItems.find(i => i.id === item.id));
    }
  }, [items, selectedItem]);

  // ëŒ“ê¸€ ì¶”ê°€
  const handleAddComment = useCallback((text: string) => {
    if (!user || !selectedItem || !text.trim()) return;

    const newComment = {
      id: Date.now(),
      author: user.name,
      text: text.trim(),
      date: new Date().toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' })
    };

    const updatedItems = items.map(item => {
      if (item.id === selectedItem.id) {
        return {
          ...item,
          comments: item.comments + 1,
          commentsList: [...item.commentsList, newComment]
        };
      }
      return item;
    });

    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    const updatedSelectedItem = updatedItems.find(item => item.id === selectedItem.id);
    setSelectedItem(updatedSelectedItem);
  }, [user, selectedItem, items]);

  // ëŒ“ê¸€ í¸ì§‘
  const handleEditComment = useCallback((commentIndex: number, newText: string) => {
    if (!selectedItem || !newText.trim()) return;

    const updatedComments = [...selectedItem.commentsList];
    updatedComments[commentIndex] = {
      ...updatedComments[commentIndex],
      text: newText.trim()
    };

    const updatedItems = items.map(item => {
      if (item.id === selectedItem.id) {
        return {
          ...item,
          commentsList: updatedComments
        };
      }
      return item;
    });

    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    const updatedSelectedItem = updatedItems.find(item => item.id === selectedItem.id);
    setSelectedItem(updatedSelectedItem);
    setEditingCommentIndex(null);
    setEditCommentText('');
  }, [selectedItem, items]);

  // ëŒ“ê¸€ ì‚­ì œ
  const handleDeleteComment = useCallback((commentIndex: number) => {
    if (!selectedItem) return;

    const updatedComments = selectedItem.commentsList.filter((_: any, index: number) => index !== commentIndex);

    const updatedItems = items.map(item => {
      if (item.id === selectedItem.id) {
        return {
          ...item,
          comments: item.comments - 1,
          commentsList: updatedComments
        };
      }
      return item;
    });

    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    const updatedSelectedItem = updatedItems.find(item => item.id === selectedItem.id);
    setSelectedItem(updatedSelectedItem);
  }, [selectedItem, items]);

  // í¸ì§‘ ëª¨ë‹¬ ì—´ê¸°
  const handleEdit = useCallback((item: any) => {
    setEditingItem({ ...item, originalDate: item.date });
    setIsEditModalOpen(true);
  }, []);

  // í¸ì§‘ ì €ì¥
  const handleSaveEdit = useCallback(() => {
    if (!editingItem) return;

    const updatedItems = items.map(item => {
      if (editingItem.isGroup && editingItem.groupPhotos) {
        // ê·¸ë£¹ëœ ì‚¬ì§„ì˜ ê²½ìš° ëª¨ë“  ì‚¬ì§„ì˜ ë‚ ì§œì™€ ì´ë²¤íŠ¸íƒ€ì… ë³€ê²½
        const matchingPhotos = items.filter(i => 
          i.author === editingItem.author && 
          i.date === editingItem.originalDate
        );
        
        if (matchingPhotos.some(photo => photo.id === item.id)) {
          return {
            ...item,
            date: editingItem.date,
            description: editingItem.date,
            eventType: editingItem.eventType
          };
        }
      } else if (item.id === editingItem.id) {
        return {
          ...item,
          date: editingItem.date,
          description: editingItem.date,
          eventType: editingItem.eventType
        };
      }
      return item;
    });

    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    if (selectedItem && selectedItem.id === editingItem.id) {
      setSelectedItem(updatedItems.find(item => item.id === editingItem.id));
    }

    setIsEditModalOpen(false);
    setEditingItem(null);

    const updateCount = editingItem.isGroup ? editingItem.groupCount : 1;
    toast({
      title: 'ì„±ê³µ',
      description: `${updateCount}ì¥ì˜ ì‚¬ì§„ ì •ë³´ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`,
      status: 'success',
      duration: 3000,
    });
  }, [editingItem, items, selectedItem, toast]);

  // ì‚­ì œ ì²˜ë¦¬
  const handleDelete = useCallback((item: any) => {
    if (!window.confirm('ì •ë§ë¡œ ì´ ì‚¬ì§„ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

    const updatedItems = items.filter(i => i.id !== item.id);
    setItems(updatedItems);
    localStorage.setItem('photoGalleryItems', JSON.stringify(updatedItems));
    
    if (selectedItem && selectedItem.id === item.id) {
      setIsDetailModalOpen(false);
      setSelectedItem(null);
    }

    toast({
      title: 'ì„±ê³µ',
      description: 'ì‚¬ì§„ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.',
      status: 'success',
      duration: 3000,
    });
  }, [items, selectedItem, toast]);

  // ë‹¤ìš´ë¡œë“œ ëª¨ë‹¬ ì—´ê¸°
  const handleDownloadModal = useCallback((item: any) => {
    if (item.isGroup && item.groupPhotos) {
      setDownloadItem(item);
      setSelectedPhotos([]);
      setIsDownloadModalOpen(true);
    } else {
      handleDirectDownload(item);
    }
  }, []);

  // ì§ì ‘ ë‹¤ìš´ë¡œë“œ
  const handleDirectDownload = useCallback((item: any) => {
    const link = document.createElement('a');
    link.href = item.src;
    link.download = `gallery_${item.id}.jpg`;
    link.click();
  }, []);

  // ì„ íƒì  ë‹¤ìš´ë¡œë“œ
  const handleSelectiveDownload = useCallback(() => {
    if (!downloadItem || selectedPhotos.length === 0) return;

    selectedPhotos.forEach((index, i) => {
      setTimeout(() => {
        const photo = downloadItem.groupPhotos[index];
        const link = document.createElement('a');
        link.href = photo.src;
        link.download = `gallery_${downloadItem.date}_${index + 1}.jpg`;
        link.click();
      }, i * 100);
    });

    setIsDownloadModalOpen(false);
    setDownloadItem(null);
    setSelectedPhotos([]);

    toast({
      title: 'ë‹¤ìš´ë¡œë“œ ì‹œì‘',
      description: `${selectedPhotos.length}ì¥ì˜ ì‚¬ì§„ì„ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.`,
      status: 'info',
      duration: 3000,
    });
  }, [downloadItem, selectedPhotos, toast]);

  // ì‚¬ì§„ ì„ íƒ í† ê¸€
  const togglePhotoSelection = useCallback((index: number) => {
    setSelectedPhotos(prev => {
      if (prev.includes(index)) {
        return prev.filter(i => i !== index);
      } else if (prev.length < 10) {
        return [...prev, index];
      }
      return prev;
    });
  }, []);

  return (
    <Box minH="100vh" bg="#f7f9fb" w="100vw" minW="100vw" pt="18mm">
      {/* ìƒë‹¨ ì»¨íŠ¸ë¡¤ ì˜ì—­ */}
      <Box px={{ base: 2, md: 8, lg: 24 }} py={6}>
        <Flex direction={{ base: 'column', md: 'row' }} gap={4} align={{ base: 'stretch', md: 'center' }} justify="space-between" mb={1.5}>
          {/* í•„í„° íƒ­ */}
          <HStack spacing={2} flexWrap="wrap">
            
          </HStack>

          {/* ì •ë ¬ ë° ì—…ë¡œë“œ */}
          <HStack spacing={2}>
            <Select size="sm" value={sort} onChange={(e) => setSort(e.target.value)} w="100px">
              <option value="latest">ìµœì‹ ìˆœ</option>
              <option value="oldest">ì˜¤ë˜ëœìˆœ</option>
              <option value="likes">ì¢‹ì•„ìš”ìˆœ</option>
              <option value="comments">ëŒ“ê¸€ìˆœ</option>
            </Select>
            <Tooltip label="ì—…ë¡œë“œ">
              <IconButton 
                size="sm" 
                icon={<PlusSquareIcon />} 
                aria-label="ì—…ë¡œë“œ" 
                bg="#004ea8"
                color="white"
                _hover={{ bg: '#004ea8' }}
                onClick={() => setIsUploadModalOpen(true)}
              />
            </Tooltip>
          </HStack>
        </Flex>
      </Box>

      {/* ê°¤ëŸ¬ë¦¬ ê·¸ë¦¬ë“œ */}
      <Box px={{ base: 2, md: 8, lg: 24 }} pb={10}>
        <SimpleGrid columns={{ base: 1, sm: 2, md: 3, lg: 4 }} spacing={6}>
          {sortedItems.map((item) => (
            <Box 
              key={item.id} 
              bg="white" 
              borderRadius="2xl" 
              boxShadow="md" 
              overflow="hidden" 
              position="relative" 
              _hover={{ boxShadow: 'xl', transform: 'translateY(-2px)' }} 
              transition="all 0.2s"
              cursor="pointer"
              onClick={() => handleItemClick(item)}
            >
              {/* ì¸ë„¤ì¼/ë¼ë²¨/ë±ƒì§€ */}
              <Box position="relative">
                <Image 
                  src={item.thumbnail} 
                  alt={item.label} 
                  w="100%" 
                  h="160px" 
                  objectFit="cover" 
                />

                
                {/* ê·¸ë£¹ ì‚¬ì§„ í‘œì‹œ */}
                {item.isGroup && item.groupCount > 1 && (
                  <Badge 
                    position="absolute" 
                    top={2} 
                    right={2} 
                    colorScheme="purple" 
                    fontSize="xs" 
                    px={2} 
                    py={0.5} 
                    borderRadius="md"
                  >
                    +{item.groupCount - 1}
                  </Badge>
                )}
              </Box>

              {/* ì •ë³´ ì˜ì—­ */}
              <VStack align="stretch" spacing={1} p={3}>
                {/* ì œëª©ê³¼ ë±ƒì§€ */}
                <Flex justify="space-between" align="center">
                  <Text fontSize="sm" color="black" fontWeight="bold" noOfLines={2} flex={1} mr={2}>
                    {item.description || item.date}
                  </Text>
                  {item.eventType ? (
                    <Badge 
                      colorScheme={item.eventType === 'ë§¤ì¹˜' ? 'blue' : item.eventType === 'ìì²´' ? 'green' : 'gray'} 
                      fontSize="xs" 
                      px={1.5} 
                      py={0.3}
                      borderRadius="sm"
                      flexShrink={0}
                    >
                      {item.eventType}
                    </Badge>
                  ) : null}
                </Flex>
                
                {/* ì‘ì„±ìì™€ ì¢‹ì•„ìš”/ëŒ“ê¸€ */}
                <Flex justify="space-between" align="center">
                  <Text fontSize="xs" color="gray.500">ì‘ì„±ì: {item.author}</Text>
                  <HStack spacing={2}>
                    <HStack 
                      spacing={1} 
                      cursor="pointer"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleLikeToggle(item);
                      }}
                    >
                      <Text fontSize="sm" color={item.isLiked ? 'red.500' : 'gray.400'}>â™¡</Text>
                      <Text fontSize="sm">{item.likes}</Text>
                    </HStack>
                    <HStack spacing={1}>
                      <Text fontSize="sm">ğŸ’¬</Text>
                      <Text fontSize="sm">{item.comments}</Text>
                    </HStack>
                  </HStack>
                </Flex>
              </VStack>
            </Box>
          ))}
        </SimpleGrid>
      </Box>

      {/* ì—…ë¡œë“œ ëª¨ë‹¬ */}
      <Modal isOpen={isUploadModalOpen} onClose={() => setIsUploadModalOpen(false)} size="lg">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>ğŸ“¸ ì‚¬ì§„ ì—…ë¡œë“œ</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            <VStack spacing={4}>
              <Box w="full">
                <Text mb={2} fontSize="sm" fontWeight="bold">
                  ì œëª© (ë‚ ì§œ)
                </Text>
                <Input
                  type="date"
                  onChange={handleDateSelect}
                />
                {uploadTitle && (
                  <Text fontSize="sm" color="blue.600" mt={1}>
                    ì„ íƒëœ ë‚ ì§œ: {uploadTitle}
                  </Text>
                )}
              </Box>

              <Box w="full">
                <Text mb={2} fontSize="sm" fontWeight="bold">
                  ì‚¬ì§„ íŒŒì¼ ì„ íƒ
                </Text>
                <Input
                  ref={fileInputRef}
                  type="file"
                  multiple
                  accept="image/*"
                  onChange={handleFileSelect}
                  display="none"
                />
                <Button
                  w="full"
                  onClick={() => fileInputRef.current?.click()}
                  variant="outline"
                >
                  íŒŒì¼ ì„ íƒ
                </Button>
                <Text fontSize="xs" color="gray.500" mt={1}>
                  ì§€ì› í˜•ì‹: JPG, PNG, GIF, WEBP | ìµœëŒ€ {UPLOAD_CONFIG.MAX_FILES}ì¥ | ì´ ìš©ëŸ‰ {UPLOAD_CONFIG.MAX_TOTAL_SIZE_MB}MB
                </Text>
                {uploadFiles.length > 0 && (
                  <VStack spacing={1} mt={1} align="start" w="full">
                    <Text fontSize="sm" color="blue.500">
                      {uploadFiles.length}ê°œ ì‚¬ì§„ ì„ íƒë¨
                    </Text>
                    <Text fontSize="xs" color="gray.600">
                      ì´ ìš©ëŸ‰: {(uploadFiles.reduce((sum, file) => sum + file.size, 0) / (1024 * 1024)).toFixed(2)}MB
                    </Text>
                    {uploadFiles.some(file => file.size / (1024 * 1024) > UPLOAD_CONFIG.TARGET_FILE_SIZE_MB) && (
                      <Text fontSize="xs" color="orange.500">
                        ì¼ë¶€ íŒŒì¼ì´ ìë™ìœ¼ë¡œ ì••ì¶•ë©ë‹ˆë‹¤ (ëª©í‘œ: {UPLOAD_CONFIG.TARGET_FILE_SIZE_MB}MB/íŒŒì¼)
                      </Text>
                    )}
                  </VStack>
                )}
              </Box>

              <Box w="full">
                <Text mb={2} fontSize="sm" fontWeight="bold">
                  ì´ë²¤íŠ¸ íƒ€ì… ì„ íƒ (ì„ íƒì‚¬í•­)
                </Text>
                <HStack spacing={2}>
                  {eventTypes.map((type) => (
                    <Button
                      key={type.value}
                      size="sm"
                      variant={uploadEventType === type.value ? 'solid' : 'outline'}
                      onClick={() => setUploadEventType(type.value)}
                    >
                      {type.label}
                    </Button>
                  ))}
                </HStack>
              </Box>

              <Button
                w="full"
                colorScheme="blue"
                onClick={handleUpload}
                isLoading={isProcessing}
                loadingText="ì—…ë¡œë“œ ì¤‘..."
                isDisabled={!uploadTitle || !uploadTitle.trim() || uploadFiles.length === 0}
              >
                ì—…ë¡œë“œ
              </Button>
            </VStack>
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* ìƒì„¸ ëª¨ë‹¬ */}
      <Modal isOpen={isDetailModalOpen} onClose={() => setIsDetailModalOpen(false)} size="xl">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>
            <Text>ğŸ“¸ ì‚¬ì§„ ìƒì„¸ë³´ê¸°</Text>
          </ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            {selectedItem && (
              <VStack spacing={4}>
                {selectedItem.isGroup ? (
                  <>
                    <Image
                      src={selectedItem.groupPhotos[selectedPhotoIndex].src}
                      alt="ë©”ì¸ ì‚¬ì§„"
                      maxH="300px"
                      objectFit="contain"
                      cursor="pointer"
                      onClick={() => window.open(selectedItem.groupPhotos[selectedPhotoIndex].src, '_blank')}
                    />
                    
                    <HStack spacing={2} justify="center">
                      {selectedItem.groupPhotos.map((photo: any, index: number) => (
                        <Image
                          key={photo.id}
                          src={photo.thumbnail}
                          alt={`ì¸ë„¤ì¼ ${index + 1}`}
                          w="60px"
                          h="60px"
                          objectFit="cover"
                          borderRadius="md"
                          cursor="pointer"
                          border={selectedPhotoIndex === index ? "2px solid" : "1px solid"}
                          borderColor={selectedPhotoIndex === index ? "blue.500" : "gray.200"}
                          onClick={() => setSelectedPhotoIndex(index)}
                        />
                      ))}
                    </HStack>
                  </>
                ) : (
                  <Image
                    src={selectedItem.src}
                    alt={selectedItem.description}
                    maxH="300px"
                    objectFit="contain"
                    cursor="pointer"
                    onClick={() => window.open(selectedItem.src, '_blank')}
                  />
                )}

                {/* ì•¡ì…˜ ë²„íŠ¼ë“¤ - ì‚¬ì§„ í•˜ë‹¨ìœ¼ë¡œ ì´ë™ */}
                <HStack spacing={2} justify="center">
                  <Button
                    size="sm"
                    variant="outline"
                    leftIcon={<DownloadIcon />}
                    onClick={() => handleDownloadModal(selectedItem)}
                  >
                    ë‹¤ìš´ë¡œë“œ
                  </Button>
                  {(user?.name === selectedItem?.author || user?.role === 'admin' || user?.role === 'superadmin') && (
                    <>
                      <Button
                        size="sm"
                        variant="outline"
                        leftIcon={<EditIcon />}
                        onClick={() => handleEdit(selectedItem)}
                      >
                        ìˆ˜ì •
                      </Button>
                      <Button
                        size="sm"
                        variant="outline"
                        colorScheme="red"
                        leftIcon={<DeleteIcon />}
                        onClick={() => handleDelete(selectedItem)}
                      >
                        ì‚­ì œ
                      </Button>
                    </>
                  )}
                </HStack>

                <Divider />

                {/* ì‘ì„±ìì™€ ì¢‹ì•„ìš” ë²„íŠ¼ */}
                <Flex justify="space-between" align="center" w="full">
                  <Text>ì‘ì„±ì: {selectedItem.author}</Text>
                  <Button
                    size="sm"
                    variant={selectedItem.isLiked ? 'solid' : 'outline'}
                    colorScheme="red"
                    onClick={() => handleLikeToggle(selectedItem)}
                  >
                    {selectedItem.isLiked ? 'â¤ï¸ ì¢‹ì•„ìš” ì·¨ì†Œ' : 'ğŸ¤ ì¢‹ì•„ìš”'}
                  </Button>
                </Flex>

                <Divider />

                {/* ëŒ“ê¸€ ì„¹ì…˜ */}
                <VStack spacing={2} w="full" align="stretch">
                  <Text fontWeight="bold">ëŒ“ê¸€</Text>
                    {selectedItem.commentsList.map((comment: any, index: number) => (
                      <Box key={comment.id} p={2} bg="gray.50" borderRadius="md">
                        {editingCommentIndex === index ? (
                          <VStack spacing={2} align="stretch">
                            <Textarea
                              value={editCommentText}
                              onChange={(e) => setEditCommentText(e.target.value)}
                              size="sm"
                              placeholder="ëŒ“ê¸€ì„ ìˆ˜ì •í•˜ì„¸ìš”..."
                            />
                            <HStack spacing={2}>
                              <Button
                                size="sm"
                                onClick={() => handleEditComment(index, editCommentText)}
                              >
                                ì €ì¥
                              </Button>
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => {
                                  setEditingCommentIndex(null);
                                  setEditCommentText('');
                                }}
                              >
                                ì·¨ì†Œ
                              </Button>
                            </HStack>
                          </VStack>
                        ) : (
                          <>
                            <Text fontSize="sm" textAlign="left" mb={1}>
                              {comment.text}
                            </Text>
                            <Flex justify="space-between" align="center">
                              <Text fontSize="xs" color="gray.500">
                                {comment.author} â€¢ {comment.date}
                              </Text>
                              {(user?.name === comment.author || user?.role === 'admin' || user?.role === 'superadmin') && (
                                <HStack spacing={1}>
                                  <Button
                                    size="xs"
                                    variant="ghost"
                                    onClick={() => {
                                      setEditingCommentIndex(index);
                                      setEditCommentText(comment.text);
                                    }}
                                  >
                                    ìˆ˜ì •
                                  </Button>
                                  <Button
                                    size="xs"
                                    variant="ghost"
                                    colorScheme="red"
                                    onClick={() => handleDeleteComment(index)}
                                  >
                                    ì‚­ì œ
                                  </Button>
                                </HStack>
                              )}
                            </Flex>
                          </>
                        )}
                      </Box>
                    ))}

                    <HStack spacing={2}>
                      <Input
                        placeholder="ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”..."
                        size="sm"
                        onKeyPress={(e) => {
                          if (e.key === 'Enter' && e.currentTarget.value.trim()) {
                            handleAddComment(e.currentTarget.value);
                            e.currentTarget.value = '';
                          }
                        }}
                      />
                      <Button
                        size="sm"
                        onClick={(e) => {
                          const input = e.currentTarget.previousElementSibling as HTMLInputElement;
                          if (input.value.trim()) {
                            handleAddComment(input.value);
                            input.value = '';
                          }
                        }}
                      >
                        ì‘ì„±
                      </Button>
                    </HStack>
                  </VStack>
                </VStack>
              </VStack>
            )}
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* í¸ì§‘ ëª¨ë‹¬ */}
      <Modal isOpen={isEditModalOpen} onClose={() => setIsEditModalOpen(false)} size="md">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>âœï¸ ì‚¬ì§„ ì •ë³´ ìˆ˜ì •</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            {editingItem && (
              <VStack spacing={4}>
                <Image
                  src={editingItem.src}
                  alt="ë¯¸ë¦¬ë³´ê¸°"
                  maxH="200px"
                  objectFit="contain"
                />
                
                <Box w="full">
                  <Text mb={2} fontSize="sm" fontWeight="bold">
                    í˜„ì¬ ë‚ ì§œ
                  </Text>
                  <Text fontSize="sm" color="blue.500" mb={2}>
                    {editingItem.originalDate}
                  </Text>
                  
                  <Text mb={2} fontSize="sm" fontWeight="bold">
                    ìˆ˜ì • ë‚ ì§œ
                  </Text>
                  <Input
                    type="date"
                    onChange={(e) => {
                      if (e.target.value) {
                        const selectedDate = new Date(e.target.value);
                        const formattedDate = selectedDate.toLocaleDateString('ko-KR', {
                          year: 'numeric',
                          month: '2-digit',
                          day: '2-digit',
                          weekday: 'short'
                        });
                        setEditingItem({ ...editingItem, date: formattedDate });
                      }
                    }}
                  />
                  {editingItem.date && editingItem.date !== editingItem.originalDate && (
                    <Text fontSize="sm" color="orange.500" mt={1}>
                      ìˆ˜ì • ë‚ ì§œ: {editingItem.date}
                    </Text>
                  )}
                </Box>

                <Box w="full">
                  <Text mb={2} fontSize="sm" fontWeight="bold">
                    ì´ë²¤íŠ¸ íƒ€ì…
                  </Text>
                  <HStack spacing={2}>
                    {eventTypes.map((type) => (
                      <Button
                        key={type.value}
                        size="sm"
                        variant={editingItem.eventType === type.label ? 'solid' : 'outline'}
                        onClick={() => setEditingItem({ ...editingItem, eventType: type.label })}
                      >
                        {type.label}
                      </Button>
                    ))}
                  </HStack>
                </Box>

                <Button
                  w="full"
                  colorScheme="blue"
                  onClick={handleSaveEdit}
                >
                  ì €ì¥
                </Button>
              </VStack>
            )}
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* ë‹¤ìš´ë¡œë“œ ëª¨ë‹¬ */}
      <Modal isOpen={isDownloadModalOpen} onClose={() => setIsDownloadModalOpen(false)} size="xl">
        <ModalOverlay />
        <ModalContent maxH="90vh" display="flex" flexDirection="column">
          <ModalHeader flexShrink={0}>
            <HStack>
              <Text>ğŸ“¸</Text>
              <Text>ì‚¬ì§„ ì„ íƒ ë‹¤ìš´ë¡œë“œ</Text>
            </HStack>
          </ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6} flex="1" display="flex" minH="0">
            {downloadItem && (
              <VStack spacing={4} h="full">
                <HStack spacing={4} w="full" justify="space-between" bg="gray.50" p={3} borderRadius="md" flexShrink={0}>
                  <Text fontSize="sm" color="gray.600">
                    ë‹¤ìš´ë¡œë“œí•  ì‚¬ì§„ì„ ì„ íƒí•˜ì„¸ìš” (ìµœëŒ€ 10ì¥)
                  </Text>
                  
                  <HStack spacing={2} align="center">
                    <Text fontSize="sm" color="gray.600" fontWeight="bold">
                      ì„ íƒëœ ì‚¬ì§„: {selectedPhotos.length}ì¥
                    </Text>
                    <IconButton
                      icon={<DownloadIcon />}
                      aria-label="ë‹¤ìš´ë¡œë“œ"
                      colorScheme="blue"
                      onClick={handleSelectiveDownload}
                      isDisabled={selectedPhotos.length === 0}
                      size="sm"
                    />
                  </HStack>
                </HStack>

                <Box 
                  flex="1"
                  maxH="50vh" 
                  overflowY="auto" 
                  overflowX="hidden"
                  w="full"
                  style={{ 
                    scrollbarWidth: 'thin',
                    scrollbarColor: '#CBD5E0 #F7FAFC'
                  }}
                >
                  <SimpleGrid columns={3} spacing={4} w="full">
                    {downloadItem.groupPhotos.map((photo: any, index: number) => (
                      <Box
                        key={photo.id}
                        position="relative"
                        cursor="pointer"
                        onClick={() => togglePhotoSelection(index)}
                      >
                        <Image
                          src={photo.thumbnail}
                          alt={`ì‚¬ì§„ ${index + 1}`}
                          w="full"
                          h="120px"
                          objectFit="cover"
                          borderRadius="md"
                          border={selectedPhotos.includes(index) ? "3px solid" : "1px solid"}
                          borderColor={selectedPhotos.includes(index) ? "blue.500" : "gray.200"}
                        />
                        {selectedPhotos.includes(index) && (
                          <Box
                            position="absolute"
                            top={2}
                            right={2}
                            bg="blue.500"
                            color="white"
                            borderRadius="full"
                            w="24px"
                            h="24px"
                            display="flex"
                            alignItems="center"
                            justifyContent="center"
                            fontSize="sm"
                            fontWeight="bold"
                          >
                            {selectedPhotos.indexOf(index) + 1}
                          </Box>
                        )}
                      </Box>
                    ))}
                  </SimpleGrid>
                </Box>
              </VStack>
            )}
          </ModalBody>
        </ModalContent>
      </Modal>
    </Box>
  );
}