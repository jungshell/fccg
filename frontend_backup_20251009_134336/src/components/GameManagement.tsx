import React, { useState } from 'react';
import {
  Box,
  Button,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  Badge,
  IconButton,
  HStack,
  VStack,
  Text,
  Alert,
  AlertIcon,
  useDisclosure,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  FormControl,
  FormLabel,
  Input,
  Select,
  useToast,
  Tooltip
} from '@chakra-ui/react';
import { AddIcon, EditIcon, DeleteIcon, CalendarIcon } from '@chakra-ui/icons';
import { getValidToken } from '../api/auth';
import { emitGameConfirmed, emitDataRefreshNeeded, emitAlert } from '../utils/eventBus';

interface Game {
  id: number;
  date: string;
  time?: string;
  location: string;
  eventType?: '매치' | '회식' | '자체';
  mercenaryCount: number;
  memberNames: string[];
  selectedMembers?: string[];
  createdById: number;
  createdAt: string;
  updatedAt: string;
  createdBy?: {
    id: number;
    name: string;
  };
  attendances?: any[];
  autoGenerated?: boolean; // 자동 생성된 경기임을 표시하는 필드
}

interface GameManagementProps {
  games: Game[];
  onGamesChange: (games: Game[]) => void;
  userList: any[]; // 회원 목록 추가
  onGameDataChanged?: () => void; // 경기 데이터 변경 시 호출할 콜백
}

export default function GameManagement({ games, onGamesChange, userList, onGameDataChanged }: GameManagementProps) {
  console.log('=== GameManagement 컴포넌트 렌더링 ===');
  console.log('GameManagement - 받은 games prop:', games);
  console.log('GameManagement - games 길이:', games?.length);
  console.log('GameManagement - games 타입:', typeof games);
  console.log('GameManagement - games가 배열인가:', Array.isArray(games));
  console.log('GameManagement - games 내용:', JSON.stringify(games, null, 2));
  const { isOpen, onOpen, onClose } = useDisclosure();
  const [editingGame, setEditingGame] = useState<Game | null>(null);
  const [formData, setFormData] = useState({
    date: '',
    time: '',
    location: '',
    eventType: '자체' as '매치' | '회식' | '자체',
    mercenaryCount: 0,
    memberNames: ['']
  });
  
  // 선택된 회원들을 별도로 관리
  const [selectedMembers, setSelectedMembers] = useState<string[]>([]);
  
  // 컴포넌트 마운트 시 경기 목록 불러오기 (AdminPageNew에서 이미 로드됨)
  // React.useEffect(() => {
  //   fetchGames();
  // }, []);
  
  // 경기 목록 불러오기
  const fetchGames = async () => {
    try {
      const response = await fetch('http://localhost:4000/api/auth/games');
      if (response.ok) {
        const gamesData = await response.json();
        
        // 실제 데이터베이스의 경기 데이터 사용
        if (gamesData && gamesData.length > 0) {
          console.log('🔄 실제 경기 데이터 로드 완료:', gamesData.length, '개');
          
          // 자동 생성된 경기인지 확인 (백엔드에서 받은 autoGenerated 값 사용)
          const processedGames = gamesData.map((game: any) => ({
            ...game,
            autoGenerated: game.autoGenerated === true, // 백엔드에서 받은 autoGenerated 값을 명시적으로 boolean으로 변환
            time: game.time || '', // 시간이 없으면 빈 문자열
            location: game.location || '장소 미정', // 장소가 없으면 기본값
            eventType: game.eventType || '자체' // 이벤트 유형이 없으면 기본값
          }));
          
          onGamesChange(processedGames);
          console.log('✅ 경기 데이터 처리 완료');
        } else {
          console.log('📝 등록된 경기가 없습니다');
          onGamesChange([]);
        }
      }
    } catch (error) {
      console.error('경기 목록 불러오기 오류:', error);
      onGamesChange([]);
    }
  };
  
  // 카카오맵 검색 관련 상태
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [showSearchResults, setShowSearchResults] = useState(false);
  
  const toast = useToast();

  const handleAddGame = () => {
    setEditingGame(null);
    setSelectedMembers([]); // 선택된 회원 초기화
    setFormData({
      date: '',
      time: '',
      location: '',
      eventType: '자체',
      mercenaryCount: 0,
      memberNames: ['']
    });
    onOpen();
  };

  const handleEditGame = (game: Game) => {
    console.log('🎯 handleEditGame 호출 (v2):', game);
    console.log('🎯 game.autoGenerated:', game.autoGenerated);
    
    // autoGenerated 속성을 명시적으로 설정
    const gameWithAutoGenerated = {
      ...game,
      autoGenerated: game.autoGenerated === true // 명시적으로 boolean으로 변환
    };
    
    setEditingGame(gameWithAutoGenerated);
    console.log('🎯 setEditingGame 완료 (v2):', gameWithAutoGenerated);
    console.log('🎯 autoGenerated 확인:', gameWithAutoGenerated.autoGenerated);
    
    // 날짜를 YYYY-MM-DD 형식으로 변환
    const gameDate = new Date(game.date);
    const formattedDate = gameDate.toISOString().split('T')[0];
    
    // 기존 selectedMembers와 memberNames를 분리하여 로드
    const existingSelectedMembers = parseMemberNames(game.selectedMembers || []);
    const allMemberNames = parseMemberNames(game.memberNames);
    
    // selectedMembers에 없는 것들만 수기입력으로 분리
    const existingManualMembers = allMemberNames.filter(name => 
      !existingSelectedMembers.includes(name) && 
      !name.startsWith('용병') // 용병도 제외
    );
    
    setSelectedMembers(existingSelectedMembers);
    
    setFormData({
      date: formattedDate,
      time: (game.autoGenerated && game.time === '미정') ? '' : (game.time || ''), // 자동생성된 게임의 "미정" 시간은 빈 문자열로 처리
      location: (game.autoGenerated && game.location === '미정') ? '' : game.location, // 자동생성된 게임의 "미정" 장소는 빈 문자열로 처리
      eventType: (game.autoGenerated && (game as any).eventType === '미정') ? '자체' : (game.eventType || '자체'), // 타입 가드
      mercenaryCount: game.mercenaryCount || 0,
      memberNames: existingManualMembers.length > 0 ? existingManualMembers : ['']
    });
    onOpen();
  };

  const handleDeleteGame = async (id: number) => {
    try {
      // 통일 유틸로 토큰 확보
      const token = await getValidToken();

      console.log('🔍 경기 삭제 시도:', { gameId: id, tokenLength: token.length });

      // 백엔드 API 호출로 경기 삭제
      const response = await fetch(`http://localhost:4000/api/auth/games/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`경기 삭제 실패: ${response.status} - ${errorData.error || response.statusText}`);
      }
      
      await fetchGames();
      
      // SchedulePageV2에 경기 데이터 변경 알림
      if (onGameDataChanged) {
        onGameDataChanged();
      }
      
      toast({
        title: '경기 삭제 완료',
        description: '경기가 삭제되었습니다.',
        status: 'success',
        duration: 2000,
        isClosable: true,
      });
    } catch (error) {
      console.error('경기 삭제 오류:', error);
      toast({
        title: '경기 삭제 실패',
        description: '경기 삭제 중 오류가 발생했습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };


  // 인원명 추가
  const addMemberName = () => {
    setFormData(prev => ({
      ...prev,
      memberNames: [...prev.memberNames, '']
    }));
  };

  // 인원명 제거
  const removeMemberName = (index: number) => {
    if (formData.memberNames.length > 1) {
      setFormData(prev => ({
        ...prev,
        memberNames: prev.memberNames.filter((_, i) => i !== index)
      }));
    }
  };

  // 인원명 변경
  const updateMemberName = (index: number, value: string) => {
    setFormData(prev => ({
      ...prev,
      memberNames: prev.memberNames.map((name, i) => i === index ? value : name)
    }));
  };

  // memberNames를 배열로 변환하는 함수
  const parseMemberNames = (memberNames: any): string[] => {
    // null, undefined 체크
    if (memberNames == null) {
      return [];
    }
    
    // 이미 배열인 경우
    if (Array.isArray(memberNames)) {
      return memberNames.filter(name => name && typeof name === 'string' && name.trim() !== '');
    }
    
    // 문자열인 경우 JSON 파싱 시도
    if (typeof memberNames === 'string') {
      try {
        const parsed = JSON.parse(memberNames);
        if (Array.isArray(parsed)) {
          return parsed.filter(name => name && typeof name === 'string' && name.trim() !== '');
        }
      } catch (error) {
        console.warn('parseMemberNames JSON 파싱 실패:', error);
      }
    }
    
    // 기본값으로 빈 배열 반환
    return [];
  };
  
  // 전체 인원 계산 - 선택된 회원, 용병, 수기입력 모두 계산
  const getTotalCount = () => {
    // 선택된 회원들 (별도 상태로 관리)
    const selectedCount = selectedMembers.length;
    
    // 용병 수
    const mercenaryCount = formData.mercenaryCount;
    
    // 수기입력된 회원들 (빈 문자열 제외)
    const manualCount = formData.memberNames.filter(name => 
      name.trim() !== ''
    ).length;
    
    return mercenaryCount + selectedCount + manualCount;
  };

  
  // formData 변경 시 실시간으로 인원수 업데이트
  React.useEffect(() => {
    // 인원수 변경 감지 (의존성 배열에 formData 추가)
  }, [formData.mercenaryCount, formData.memberNames]);

  // 카카오맵 장소 검색
  const searchLocation = async (query: string) => {
    if (!query.trim()) return;
    
    setIsSearching(true);
    try {
      const response = await fetch(`http://localhost:4000/api/auth/search-location?query=${encodeURIComponent(query)}`);
      if (response.ok) {
        const data = await response.json();
        setSearchResults(data.documents || []);
        setShowSearchResults(true);
      } else {
        toast({
          title: '검색 실패',
          description: '장소 검색에 실패했습니다.',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('장소 검색 오류:', error);
      toast({
        title: '검색 오류',
        description: '장소 검색 중 오류가 발생했습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    } finally {
      setIsSearching(false);
    }
  };

  // 장소 선택
  const selectLocation = (place: any) => {
    setFormData(prev => ({
      ...prev,
      location: place.place_name
    }));
    setSearchQuery(place.place_name);
    setShowSearchResults(false);
  };

  const handleSubmit = async () => {
    if (!formData.date || !formData.location) {
      toast({
        title: '입력 오류',
        description: '날짜와 장소를 모두 입력해주세요.',
        status: 'error',
        duration: 2000,
        isClosable: true,
      });
      return;
    }

    // 중복 일정 체크 (자동생성된 경기는 제외)
    const selectedDate = new Date(formData.date);
    const existingGameOnDate = games.find(game => {
      const gameDate = new Date(game.date);
      return gameDate.toDateString() === selectedDate.toDateString() && 
             (!editingGame || game.id !== editingGame.id) &&
             !game.autoGenerated; // 자동생성된 경기는 중복 체크에서 제외
    });

    if (existingGameOnDate) {
      toast({
        title: '중복 일정',
        description: '해당 날짜에 이미 경기가 있습니다.',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    try {
      if (editingGame) {
        // 자동생성된 경기를 수정하는 경우 - 일정확정 기능 수행
        if (editingGame.autoGenerated === true) {
          console.log('🎯 자동생성 경기 수정 - 일정확정 기능 수행');
          
          // 통일 유틸로 토큰 확보
          const token = await getValidToken();

          // 필수 정보 확인
          if (!formData.time || !formData.location || !formData.eventType) {
            toast({
              title: '정보 부족',
              description: '시간, 장소, 이벤트 유형을 모두 입력해주세요.',
              status: 'warning',
              duration: 3000,
              isClosable: true,
            });
            return;
          }

          console.log('🎯 자동생성 경기 일정확정 시도:', { 
            gameId: editingGame.id, 
            hasToken: !!token
          });

          // 백엔드 API 호출로 게임 수정 (확정)
          const updatedFormData = {
            ...formData,
            eventType: formData.eventType || '자체',
            memberNames: formData.memberNames.filter(name => name.trim() !== ''),
            selectedMembers: selectedMembers,
            mercenaryCount: formData.mercenaryCount || 0,
            gameType: (formData.eventType === '매치') ? 'MATCH' : 'SELF',
          };

          console.log('🎯 자동생성 경기 일정확정 데이터:', {
            gameId: editingGame.id,
            formData: updatedFormData
          });

          const response = await fetch(`http://localhost:4000/api/auth/games/${parseInt(editingGame.id.toString())}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(updatedFormData)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('자동생성 경기 일정확정 실패 응답:', {
              status: response.status,
              statusText: response.statusText,
              errorData
            });
            throw new Error(`일정확정 실패: ${response.status} - ${errorData.details || response.statusText}`);
          }

                const result = await response.json();
                console.log('자동생성 경기 일정확정 성공:', result);
                
                // 🔄 이벤트 시스템으로 다른 페이지에 동기화 알림
                emitGameConfirmed({
                  gameId: editingGame.id,
                  gameData: result,
                  confirmedBy: '관리자'
                });
                emitDataRefreshNeeded('games');
                emitAlert(`경기 일정이 확정되었습니다! 회원들에게 알림이 발송되었습니다.`, 'success');
                
                // 자동생성 일정 확정 후 항상 페이지 새로고침 (다른 자동생성 일정들이 삭제되었을 수 있음)
                console.log('🎯 자동생성 일정 확정 완료 - UI 새로고침');
                setTimeout(() => {
                  window.location.reload();
                }, 1000);
          
          // SchedulePageV2에 경기 데이터 변경 알림
          if (onGameDataChanged) {
            onGameDataChanged();
          }
          
          // 모달 닫기
          onClose();
          
          // 성공 메시지
          toast({
            title: '🎯 경기 일정 확정 완료!',
            description: '회원들에게 알림이 발송되었습니다.',
            status: 'success',
            duration: 5000,
            isClosable: true,
          });
          
          return; // 자동생성 경기 처리 완료
        }
        
        // 일반 경기 수정
        // 경기 수정 - 백엔드 API 호출
        const updatedFormData = {
          ...formData,
          // eventType이 null이거나 빈 값이면 기본값 설정
          eventType: formData.eventType || '자체',
          // selectedMembers는 별도로 저장하고, memberNames는 수기 입력만 포함
          memberNames: formData.memberNames.filter(name => name.trim() !== ''),
          selectedMembers: selectedMembers, // 선택된 회원을 별도 필드로 저장
          mercenaryCount: formData.mercenaryCount || 0,
          // 백엔드가 기대하는 gameType 보정
          gameType: (formData.eventType === '매치') ? 'MATCH' : 'SELF'
        };
        
        // 통일 유틸로 토큰 확보
        const token = await getValidToken();

        if (!token) {
          toast({
            title: '인증 오류',
            description: '로그인이 필요합니다.',
            status: 'error',
            duration: 3000,
            isClosable: true,
          });
          return;
        }

        console.log('🔍 경기 수정 시도:', { 
          gameId: editingGame.id, 
          tokenLength: token.length,
          hasToken: !!token
        });

        // DB에 존재하지 않는 임시 id면 생성(POST), 정수형 id면 수정(PUT)
        const gameIdStr = editingGame.id.toString();
        const isPersistedId = typeof editingGame.id === 'number' 
          && Number.isSafeInteger(editingGame.id)
          && editingGame.id > 0 
          && editingGame.id < 1000000000 // 비정상적으로 큰 임시 ID(타임스탬프형) 방지
          && !gameIdStr.includes('.') // 소수점이 포함된 타임스탬프 ID 제외
          && gameIdStr.length < 10; // 타임스탬프는 보통 13자리 이상
        const requestUrl = isPersistedId
          ? `http://localhost:4000/api/auth/games/${editingGame.id}`
          : `http://localhost:4000/api/auth/games`;
        const requestMethod = isPersistedId ? 'PUT' : 'POST';

        console.log('🔍 API 요청 정보:', {
          url: requestUrl,
          method: requestMethod,
          tokenLength: token.length,
          hasToken: !!token
        });

        const response = await fetch(requestUrl, {
          method: requestMethod,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            ...updatedFormData
          })
        });

        console.log('🔍 API 응답 상태:', response.status, response.statusText);

        if (!response.ok) {
          throw new Error('경기 수정 실패');
        }

        const result = await response.json();
        console.log('경기 수정 성공:', result);
        
        // 자동생성 일정이 삭제되었는지 확인
        if (result.autoGeneratedGamesDeleted) {
          console.log('🎯 자동생성 일정이 삭제됨 - UI 새로고침 필요');
          // 페이지 전체 새로고침을 통해 모든 데이터 동기화
          setTimeout(() => {
            window.location.reload();
          }, 1000);
        } else {
          // 일반적인 경우에는 fetchGames 호출
          await fetchGames();
        }
        
        // SchedulePageV2에 경기 데이터 변경 알림
        if (onGameDataChanged) {
          onGameDataChanged();
        }
        
        // 자동생성된 게임이 확정된 경우 특별한 메시지 표시
        const isAutoGeneratedConfirmed = editingGame.autoGenerated && 
          formData.time && formData.location && formData.eventType &&
          formData.time !== '미정' && formData.location !== '미정';
        
        if (isAutoGeneratedConfirmed) {
          toast({
            title: '🎯 경기 일정 확정 완료!',
            description: '회원들에게 알림이 발송되었습니다. 같은 주의 다른 자동생성된 일정들은 삭제되었습니다.',
            status: 'success',
            duration: 5000,
            isClosable: true,
          });
        } else {
          toast({
            title: '경기 수정 완료',
            description: '경기 정보가 수정되었습니다.',
            status: 'success',
            duration: 2000,
            isClosable: true,
          });
        }
      } else {
        // 새 경기 추가 - 백엔드 API 호출
        const newFormData = {
          ...formData,
          // eventType이 null이거나 빈 값이면 기본값 설정
          eventType: formData.eventType || '자체',
          // selectedMembers는 별도로 저장하고, memberNames는 수기 입력만 포함
          memberNames: formData.memberNames.filter(name => name.trim() !== ''),
          selectedMembers: selectedMembers, // 선택된 회원을 별도 필드로 저장
          createdById: 1,
          gameType: (formData.eventType === '매치') ? 'MATCH' : 'SELF'
        };
        
        // 토큰 가져오기 (여러 위치에서 시도)
        const token = await getValidToken();
        
        if (!token) {
          toast({
            title: '인증 오류',
            description: '로그인이 필요합니다.',
            status: 'error',
            duration: 3000,
            isClosable: true,
          });
          return;
        }

        console.log('🔍 경기 추가 시도:', { tokenLength: token.length });

        const response = await fetch('http://localhost:4000/api/auth/games', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(newFormData)
        });

        if (!response.ok) {
          throw new Error('경기 추가 실패');
        }
        
        const result = await response.json();
        console.log('경기 추가 성공:', result);
        
        // 자동생성 일정이 삭제되었는지 확인
        if (result.autoGeneratedGamesDeleted) {
          console.log('🎯 자동생성 일정이 삭제됨 - UI 새로고침 필요');
          // 페이지 전체 새로고침을 통해 모든 데이터 동기화
          setTimeout(() => {
            window.location.reload();
          }, 1000);
        }
        
        await fetchGames();
        
        // SchedulePageV2에 경기 데이터 변경 알림
        if (onGameDataChanged) {
          onGameDataChanged();
        }
        
        toast({
          title: '경기 추가 완료',
          description: '새 경기가 추가되었습니다.',
          status: 'success',
          duration: 2000,
          isClosable: true,
        });
      }

      onClose();
    } catch (error) {
      console.error('경기 저장 오류:', error);
      const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다.';
      toast({
        title: '저장 실패',
        description: `경기 정보 저장 중 오류가 발생했습니다: ${errorMessage}`,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  };

  const getEventTypeName = (type: string) => {
    switch (type) {
      case '자체': return '자체';
      case '매치': return '매치';
      case '회식': return '회식';
      default: return '자체';
    }
  };

  return (
    <>
      <VStack spacing={6} align="stretch">
        <HStack justify="space-between">
          <VStack align="start" spacing={2}>
            <HStack spacing={3}>
          <Text fontSize="2xl">⚽</Text>
          <Text fontSize="2xl" fontWeight="bold">경기 관리</Text>
        </HStack>
            <Text>경기 일정을 관리할 수 있습니다.</Text>
          </VStack>
          <Button 
            colorScheme="blue" 
            bg="#004ea8"
            _hover={{ bg: "#003d7a" }}
            leftIcon={<AddIcon />}
            onClick={handleAddGame}
            size="sm"
          >
            추가
          </Button>
        </HStack>
        
        <Box
          bg="white"
          border="1px"
          borderColor="gray.200"
          borderRadius="lg"
          overflow="hidden"
        >
                    {(() => {
            console.log('=== GameManagement - 렌더링 조건 체크 ===');
            console.log('games:', games);
            console.log('games?.length:', games?.length);
            console.log('games?.length === 0:', games?.length === 0);
            return games?.length === 0 ? (
              <Box p={6} textAlign="center">
                <Alert status="info">
                  <AlertIcon />
                  등록된 경기가 없습니다.
                </Alert>
              </Box>
            ) : (
              <Table variant="simple">
                <Thead bg="gray.50">
                  <Tr>
                    <Th textAlign="center">날짜</Th>
                    <Th textAlign="center">장소</Th>
                    <Th textAlign="center">이벤트 유형</Th>
                    <Th textAlign="center">전체 인원</Th>
                    <Th textAlign="center">생성자</Th>
                    <Th textAlign="center">작업</Th>
                  </Tr>
                </Thead>
                <Tbody>
                  {games.map((game) => (
                    <Tr key={game.id} bg={game.autoGenerated ? "blue.50" : "white"}>
                      <Td textAlign="center">
                        <VStack spacing={1} align="center">
                          <Text fontWeight="medium">
                            {(() => {
                              const date = new Date(game.date);
                              const year = date.getFullYear();
                              const month = String(date.getMonth() + 1).padStart(2, '0');
                              const day = String(date.getDate()).padStart(2, '0');
                              const weekdays = ['일', '월', '화', '수', '목', '금', '토'];
                              const weekday = weekdays[date.getDay()];
                              
                              // 자동생성된 게임은 시간을 "미정"으로 표시
                              if (game.autoGenerated) {
                                return `${year}.${month}.${day}.(${weekday}) 미정`;
                              } else if (game.time) {
                                return `${year}.${month}.${day}.(${weekday}) ${game.time}`;
                              } else {
                                return `${year}.${month}.${day}.(${weekday})`;
                              }
                            })()}
                          </Text>
                          {game.autoGenerated && (
                            <Badge colorScheme="blue" variant="outline" size="sm">
                              자동생성
                            </Badge>
                          )}
                        </VStack>
                      </Td>
                      <Td textAlign="center">
                        <Text fontSize="sm" color="gray.600">
                          {game.autoGenerated ? '미정' : game.location}
                        </Text>
                      </Td>
                      <Td textAlign="center">
                        <Badge 
                          colorScheme={
                            game.autoGenerated ? 'gray' :
                            game.eventType === '매치' ? 'blue' : 
                            game.eventType === '회식' ? 'orange' : 
                            'purple'
                          }
                          variant="subtle"
                        >
                          {game.autoGenerated ? '미정' : getEventTypeName(game.eventType || '자체')}
                        </Badge>
                      </Td>
                      <Td textAlign="center">
                        <Badge colorScheme="blackAlpha" variant="subtle">
                          {(() => {
                            const selectedMembersArray = game.selectedMembers ? 
                              (Array.isArray(game.selectedMembers) ? game.selectedMembers : JSON.parse(game.selectedMembers)) : [];
                            const memberNamesArray = parseMemberNames(game.memberNames);
                            const mercenaryCount = game.mercenaryCount || 0;
                            return selectedMembersArray.length + memberNamesArray.length + mercenaryCount;
                          })()}명
                        </Badge>
                      </Td>
                      <Td textAlign="center">
                        <Text fontSize="sm" color="gray.600">
                          {game.createdBy?.name || '알 수 없음'}
                        </Text>
                      </Td>
                      <Td textAlign="center">
                        <HStack spacing={2} justify="center">
                          <Tooltip 
                            label={game.autoGenerated ? "일정확정" : "경기 수정"} 
                            placement="top" 
                            hasArrow
                            bg={game.autoGenerated ? "green.600" : "blue.600"}
                            color="white"
                            fontSize="sm"
                          >
                            <IconButton
                              aria-label={game.autoGenerated ? "일정확정" : "경기 수정"}
                              icon={<EditIcon />}
                              size="sm"
                              variant="ghost"
                              colorScheme={game.autoGenerated ? "green" : "blue"}
                              onClick={() => handleEditGame(game)}
                            />
                          </Tooltip>
                          <Tooltip 
                            label="경기 삭제" 
                            placement="top" 
                            hasArrow
                            bg="red.600"
                            color="white"
                            fontSize="sm"
                          >
                            <IconButton
                              aria-label="경기 삭제"
                              icon={<DeleteIcon />}
                              size="sm"
                              variant="ghost"
                              colorScheme="red"
                              onClick={() => handleDeleteGame(game.id)}
                            />
                          </Tooltip>
                        </HStack>
                      </Td>
                    </Tr>
                  ))}
                </Tbody>
              </Table>
            );
          })()}
        </Box>
      </VStack>

      {/* 경기 추가/수정 모달 */}
      <Modal isOpen={isOpen} onClose={onClose}>
        <ModalOverlay />
        <ModalContent maxW="500px">
          <ModalHeader py={4}>
            {editingGame ? (editingGame.autoGenerated ? '⚽ 일정확정' : '⚽ 경기 수정') : '⚽ 경기 추가'}
          </ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={4}>
            <VStack spacing={3}>
              {/* 날짜와 이벤트 유형을 같은 행에 배치하되 y축 위치는 장소, 인원관리와 맞춤 */}
              <FormControl>
                                        <FormLabel>📅 일시 & 이벤트</FormLabel>
                                  <HStack spacing={4} align="start">
                    <Input
                      type="date"
                      value={formData.date}
                      onChange={(e) => setFormData({ ...formData, date: e.target.value })}
                      size="md"
                      h="40px"
                      flex={1}
                    />
                    <Select
                      value={formData.time || ''}
                      onChange={(e) => setFormData({ ...formData, time: e.target.value })}
                      placeholder="시간 선택"
                      size="md"
                      h="40px"
                      flex={1}
                    >
                      <option value="18:00">오후 6:00</option>
                      <option value="18:30">오후 6:30</option>
                      <option value="19:00">오후 7:00</option>
                      <option value="19:30">오후 7:30</option>
                      <option value="20:00">오후 8:00</option>
                      <option value="20:30">오후 8:30</option>
                    </Select>
                    <Select
                      value={formData.eventType}
                      onChange={(e) => setFormData({ ...formData, eventType: e.target.value as '매치' | '회식' | '자체' })}
                      size="md"
                      h="40px"
                      flex={1}
                    >
                      <option value="자체">자체</option>
                      <option value="매치">매치</option>
                      <option value="회식">회식</option>
                    </Select>
                  </HStack>
              </FormControl>
              
              <FormControl>
                <FormLabel>📍 장소</FormLabel>
                <VStack spacing={2} align="stretch">
                  <HStack>
                    <Input
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      placeholder="장소명을 검색하세요"
                      onKeyPress={(e) => e.key === 'Enter' && searchLocation(searchQuery)}
                    />
                    <Button
                      onClick={() => searchLocation(searchQuery)}
                      isLoading={isSearching}
                      colorScheme="blue"
                      size="sm"
                    >
                      검색
                    </Button>
                  </HStack>
                  
                  {/* 검색 결과 */}
                  {showSearchResults && searchResults.length > 0 && (
                    <Box
                      border="1px solid"
                      borderColor="gray.200"
                      borderRadius="md"
                      maxH="200px"
                      overflowY="auto"
                      bg="white"
                      zIndex={10}
                    >
                      {searchResults.map((place, index) => (
                        <Box
                          key={index}
                          p={3}
                          borderBottom="1px solid"
                          borderColor="gray.100"
                          cursor="pointer"
                          _hover={{ bg: "gray.50" }}
                          onClick={() => selectLocation(place)}
                        >
                          <Text fontWeight="bold">{place.place_name}</Text>
                          <Text fontSize="sm" color="gray.600">{place.address_name}</Text>
                        </Box>
                      ))}
                    </Box>
                  )}
                  
                  <Input
                    value={formData.location}
                    onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                    placeholder="선택된 장소 또는 직접 입력"
                  />
                </VStack>
              </FormControl>
              

              

              
                            {/* 인원 관리 - 좌우 병기 */}
              <FormControl>
                <HStack justify="space-between" align="center" mb={2}>
                  <FormLabel mb={0}>👥 인원 관리</FormLabel>
                  <Box ml={4}>
                    <Text fontSize="sm" fontWeight="bold" color="blue.600">
                      전체 인원: {getTotalCount()}명 (회원 {selectedMembers.length}명 + 용병 {formData.mercenaryCount}명 + 수기입력 {formData.memberNames.filter(name => name.trim() !== '').length}명)
                    </Text>
                  </Box>
                </HStack>
                <HStack spacing={4} align="start">
                  {/* 왼쪽: 회원 선택 */}
                  <Box flex={1}>
                    <Text fontSize="sm" color="gray.600" mb={2} fontWeight="bold">회원 선택</Text>
                    <Box>
                      {userList.map((user, index) => (
                        <Button
                          key={user.id}
                          size="sm"
                          variant={selectedMembers.includes(user.name) ? "solid" : "outline"}
                          colorScheme={selectedMembers.includes(user.name) ? "blue" : "gray"}
                          onClick={() => {
                            if (selectedMembers.includes(user.name)) {
                              // 이미 선택된 경우 제거
                              setSelectedMembers(prev => prev.filter(name => name !== user.name));
                            } else {
                              // 선택되지 않은 경우 추가 (수기입력칸에는 추가하지 않음)
                              setSelectedMembers(prev => [...prev, user.name]);
                            }
                          }}
                          mr={2}
                          mb={index % 4 === 3 ? 2 : 0}
                        >
                          {user.name}
                        </Button>
                      ))}
                    </Box>

                  </Box>
                  
                  {/* 오른쪽: 용병 및 수기 입력을 1행 2열로 재분할 */}
                  <Box flex={1}>
                    <Text fontSize="sm" color="gray.600" mb={2} fontWeight="bold">용병 & 수기 입력</Text>
                    <HStack spacing={4} align="start">
                      {/* 용병 입력 부분 */}
                      <Box flex={1}>
                        <Text fontSize="xs" color="gray.500" mb={1}>용병 인원</Text>
                        <Input
                          type="number"
                          value={formData.mercenaryCount}
                          onChange={(e) => setFormData({ ...formData, mercenaryCount: parseInt(e.target.value) || 0 })}
                          placeholder="0"
                          min="0"
                          size="sm"
                        />
                      </Box>
                      
                      {/* 수기 입력 부분 */}
                      <Box flex={1}>
                        <Text fontSize="xs" color="gray.500" mb={1}>수기 입력</Text>
                        {formData.memberNames.map((name, index) => (
                          <HStack key={index} mb={1}>
                            <Input
                              value={name}
                              onChange={(e) => updateMemberName(index, e.target.value)}
                              placeholder={`팀원 ${index + 1} 이름`}
                              size="sm"
                            />
                            {formData.memberNames.length > 1 && (
                              <Button
                                size="sm"
                                colorScheme="red"
                                variant="ghost"
                                onClick={() => removeMemberName(index)}
                              >
                                삭제
                              </Button>
                            )}
                          </HStack>
                        ))}
                        <Button
                          size="sm"
                          colorScheme="blue"
                          variant="outline"
                          onClick={addMemberName}
                          leftIcon={<AddIcon />}
                          w="100%"
                        >
                          팀원 추가
                        </Button>
                      </Box>
                    </HStack>
                  </Box>
                </HStack>
              </FormControl>
              

              
              <HStack spacing={3} w="100%">
                <Button 
                  colorScheme="blue" 
                  onClick={handleSubmit} 
                  flex={1}
                >
                  {editingGame ? '수정' : '추가'}
                </Button>
                <Button onClick={onClose} flex={1}>
                  취소
                </Button>
              </HStack>

              {/* 자동생성된 경기일 때만 표시되는 일정확정 섹션 */}
              {editingGame && editingGame.autoGenerated === true && (
                <Box 
                  mt={4} 
                  p={4} 
                  bg="green.50" 
                  borderRadius="md" 
                  border="1px" 
                  borderColor="green.200"
                >
                  <Text fontSize="md" fontWeight="bold" color="green.700" mb={2}>
                    이 게임을 최종 확정하시겠습니까?
                  </Text>
                  <Text fontSize="sm" color="green.600" mb={3}>
                    확정 시 회원들에게 알림이 발송되고, 같은 주의 다른 자동생성된 일정들은 삭제됩니다.
                  </Text>
                  <Button 
                    colorScheme="green" 
                    size="lg" 
                    w="100%"
                    leftIcon={<CalendarIcon />}
                    onClick={handleSubmit}
                  >
                    일정확정
                  </Button>
                </Box>
              )}
            </VStack>
          </ModalBody>
        </ModalContent>
      </Modal>
    </>
  );
}
